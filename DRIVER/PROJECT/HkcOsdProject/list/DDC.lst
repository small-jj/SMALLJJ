C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DDC
OBJECT MODULE PLACED IN .\obj\DDC.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\DDC.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC;..\
                    -..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL\SYS
                    -TEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\INC)
                    - DEFINE(ModelName=JRY_TESTBOARD_C_BOARD) DEBUG OBJECTEXTEND PRINT(.\list\DDC.lst) OBJECT(.\obj\DDC.obj)

line level    source

   1          #include "types.h"
   2          #include "ms_reg.h"
*** MESSAGE C320 IN LINE 337 OF ..\..\CONFIG\BOARD.H: "Please remember to disable the debug function!" 
   3          #include "ms_rwreg.h"
   4          #include "Global.h"
   5          #include "MsID_V1.h"
   6          #include "UserPref.h"
   7          #include "nvram.h"      //120420 Modify
   8          #include "msflash.h"
   9          
  10          #include "EDID.H"
  11          
  12          #include "I2C.H"
  13          
  14          extern void SetPWMFreq(WORD freq);
  15          #define CheckDDCAddr1   0x10
  16          #define CheckDDCAddr2   0x20
  17          
  18          #if (CHIP_ID==CHIP_TSUMF)
              #define _BIT(a)                         (BIT0 << a)
              #define MASKBIT(a)                      (_BIT((1?a) +1) -_BIT((0?a)))
              #endif
  22          //extern void i2c_WriteTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count);
  23          //extern void i2c_ReadTBL(BYTE deviceID,WORD addr,BYTE * buffer,BYTE count);
  24          
  25          
  26          #define NVRAM_ADDR_EDID          0x00
  27          #if ((!VGA_Write_EEPROM&&ENABLE_VGA)||(!DVI_Write_EEPROM&&ENABLE_DVI))
  28          void mStar_ClrDDC_WP(void)   
  29          {
  30   1              #if (ENABLE_DVI&&(!DVI_Write_EEPROM))
                              msWriteByte(REG_3E45, BIT7);//æ‰“å¼€DVIå†…éƒ¨Buffer
                      #else
  33   1                      msWriteByte(REG_3E45, BIT0);//å…³é—­DVIå†…éƒ¨Buffer
  34   1              #endif
  35   1              msWriteByte(REG_3E49, BIT7); //ADC DDC disable write protect//æ‰“å¼€VGAå†…éƒ¨Buffer
  36   1              msWriteByte(REG_3E4B,msReadByte(REG_3E4B)&~BIT7);//è®¾ç½®VGAå†…éƒ¨Bufferä¸ºå¯å†™
  37   1      }
  38          
  39          void mStar_SetDDC_WP(void)    //
  40          {
  41   1              #if (ENABLE_DVI&&(!DVI_Write_EEPROM))
                              msWriteByte(REG_3E45, BIT7|BIT5);//å¼€å¯DVIå†™ä¿æŠ¤
                      #else
  44   1                      msWriteByte(REG_3E45, BIT0);//å…³é—­DVIå†…éƒ¨Buffer
  45   1              #endif
  46   1         #if CHIP_ID==CHIP_TSUMF
                  msWriteByteMask(REG_3EFA, 0, 0x0F);   // REG_DDC_BANK_7D[4:0]: Select A0 EDID sram base address//é€‰æ‹
             -©åŸºåœ°å€
                  msWriteByte(REG_3E49, BIT7|BIT5); //ADC DDC Enable write protect//å¼€å¯VGAå†…éƒ¨Buffer
                 #else
  50   1              msWriteByte(REG_3E49, BIT7|BIT5); //ADC DDC Enable write protect
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 2   

  51   1           #endif     
  52   1              msWriteByte(REG_3E4B,msReadByte(REG_3E4B)|BIT7);
  53   1      }
  54          #endif
  55          #if User_DDCTO_FlashSave
  56          Bool CheckFlashEDIDData(void)
  57          {
  58   1              if(DDC1[0]==0x00&&DDC1[1]==0xFF&&DDC1[2]==0xFF&&DDC1[3]==0xFF&&DDC1[4]==0xFF&&DDC1[5]==0xFF&&DDC1[6]==0xF
             -F&&DDC1[7]==0x00)
  59   1              {
  60   2                      return TRUE;
  61   2              }
  62   1              else
  63   1                      return FALSE;   
  64   1      }
  65          #endif
  66          
  67          #if ((!VGA_Write_EEPROM)&&ENABLE_VGA)
  68          void mStar_VGADDC_Base_Address(void)
  69          {
  70   1      
  71   1             #if CHIP_ID==CHIP_TSUMF
                      msWriteByteMask(REG_0260, 0, BIT2|BIT3);
                      #endif
  74   1      
  75   1              #if (CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD)
  76   1               msWriteByte( REG_3EEC, 0x11);                                           // EDID Set Base address
  77   1               msWriteByte( REG_3EED, 0x03);
  78   1              #elif (CHIP_ID==CHIP_TSUMF)
                     msWriteByte( REG_3EEC, 0x11);    
                      #endif
  81   1      
  82   1           #if (CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD) 
  83   1           msWriteByteMask( REG_3EEB, 0x00, 0xF0);
  84   1           #elif (CHIP_ID==CHIP_TSUMF)        
                   msWriteByteMask(REG_3EEB, 0, 0x0F);   // REG_DDC_BANK_75[12:8]: Select EDID sram base address for cpu
             - read/write 
                   #endif
  87   1      }
  88          #endif
  89          #if ((!DVI_Write_EEPROM)&&ENABLE_DVI)
              void mStar_DVIDDC_Base_Address(void)
              {
                      #if CHIP_ID==CHIP_TSUMF
                      msWriteByteMask(REG_0260, 0, BIT2|BIT3);
                      #endif
              
                      #if (CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD)
                              msWriteByte( REG_3EEC, 0x11);                                           // EDID Set Base address
                              msWriteByte( REG_3EED, 0x03);
                      #elif (CHIP_ID==CHIP_TSUMF)     
                               msWriteByte( REG_3EEC, 0x11);    
                                msWriteByteMask(REG_3EEB, 1, MASKBIT(4:0));
                              msWriteByteMask(REG_3E43, 0, BIT1);
                      #endif
              
                   #if (CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD)  
                              msWriteByteMask( REG_3EEB, 0x10, 0xF0);
                   #elif (CHIP_ID==CHIP_TSUMF)        
                   msWriteByteMask(REG_3EEB, 0x01, 0x1F);   // REG_DDC_BANK_75[12:8]: Select EDID sram base address for 
             -cpu read/write         
                   #endif
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 3   

              }
              #endif
 112          
 113          #if User_DDCTO_FlashSave
 114          void CleanDDCBuff (void)
 115          {
 116   1              BYTE i=0;
 117   1      
 118   1              for(i=0;i<20;i++)
 119   1                      DDC1[i]=0xFF;
 120   1      }
 121          #endif
 122          
 123          //2·µ»ØÖµ :   ÉÕÂ¼³É¹¦/Ê§°Ü
 124          #define         TryToModDdcFunction     0
 125          
 126          
 127          #if             TryToModDdcFunction
              Bool            Init_AllPort_Ddc_ToE2PROM_Func(const BYTE DdcPort,const BYTE DdcDate[],const WORD DdcCount)
              {
              
                              BYTE dd=0;
                              WORD i=0;
                              Bool Result = FALSE;
                              BYTE  ReadCheckSum=0;
              
                              EnableReadDDCType=DdcPort;      
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
              
                              hw_ClrDDC_WP();
                              for(i=0; i<DdcCount; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, DdcDate[i]);
                               }      
                              hw_SetDDC_WP();
                              Delay1ms(2);
                              
                              ReadCheckSum = 0;
              
                               for(i=0; i<DdcCount; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;
                                      ReadCheckSum+=DDC1[i];
                               }
              
              
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==DdcDate[0x7F]))
                              {
                                      if ((ReadCheckSum)==0)
                                      {
                                              Result=TRUE;
                                      }
                              }
              
              
                              EnableReadDDCType=I2C_EEPROM;   
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
              
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 4   

                              return Result;
                              
              }
              
              
              #if ENABLE_VGA
              void mStar_VGA_InitDDC(void)
              {
              #if VGA_Write_EEPROM//æ˜¯å¦å¤–æŒ‚eeprom
              
              if (Load_VGAEDID_Flag)//æ˜¯å¦åŽ»è¯»EDID
              {
              
                              BYTE ChecKVGADoubleFlag=0;
                              #if User_DDCTO_FlashSave
                                      BYTE EDID_CheckSum=0 ;
                              #endif
                              
                              #if USEFLASH
                              #if User_DDCTO_FlashSave//æ˜¯å¦å¤–çƒ§
                                      CleanDDCBuff ();//æ¸…ç©ºddc1æ•°ç»„
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, &DDC1, DDCAKEY_SIZE);//å°†falshä¸­çš„E
             -DIDè¯»åˆ°ddc1ä¸­
                                      EDID_CheckSum=DDC1[0x7F];//å°†æ ¡éªŒä½çš„å€¼èµ‹ç»™è¯¥å˜é‡
                              #else
                                      #message "VGA DDC Data User Default EDID"
                              #endif
                              #endif
              
                      #if User_DDCTO_FlashSave
                    if (CheckFlashEDIDData())
                      {       
                              ChecKVGADoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(VGA_EDID,DDC1,128);
                      }
                      else
                      #endif
                      {       
                              ChecKVGADoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(VGA_EDID,EDID_vga,128);
                      }
              
                              if (ChecKVGADoubleFlag)
                              {
                                      Clr_Load_VGAEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
              }
              
              #else
              
                      BYTE i;
              
                      mStar_ClrDDC_WP();
              
                      mStar_VGADDC_Base_Address();
                      
                      #if USEFLASH
                      #if User_DDCTO_FlashSave
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, &DDC1, DDCAKEY_SIZE);
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 5   

                      #else
                              #message "VGA DDC Data User Default EDID"
                      #endif
                      #else
                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
                      
                      #if User_DDCTO_FlashSave
                      if(CheckFlashEDIDData())
                      {       
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, DDC1[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
              
                                      while(msReadByte(REG_3E7B) & BIT5);  
                              }
                      }
                      else
                      #endif
                      {
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, EDID_vga[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
              
                                      while(msReadByte(REG_3E7B) & BIT5);  
                              }
                      }
                      
                      mStar_SetDDC_WP();
                      
              #endif
              
              }
              #endif
              #if ENABLE_DVI
              void mStar_DVI_InitDDC(void)
              {
              #if DVI_Write_EEPROM
              #if DEBUG_PRINTDATA
              printData("Load_DVIIEDID_FlagAA=%d",Load_DVIIEDID_Flag);    
              #endif          
              
              if (Load_DVIIEDID_Flag)
              {
              
                              BYTE ChecKDVIDoubleFlag=0;
                              #if User_DDCTO_FlashSave
                                      BYTE EDID_CheckSum=0 ;
                              #endif
                              
                              #if USEFLASH
                              #if User_DDCTO_FlashSave
                                      CleanDDCBuff ();
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0, DDCDKEY_SIZE, &DDC1, DDCDKEY_SIZE);
                                      EDID_CheckSum=DDC1[0x7F];
                              #else
                                      #message "DVI DDC Data User Default EDID"
                              #endif
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 6   

                              #endif
              
                      #if User_DDCTO_FlashSave
                    if (CheckFlashEDIDData())
                      {       
                              ChecKDVIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(DVI_EDID,DDC1,128);
                      }
                      else
                      #endif
                      {       
                              ChecKDVIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(DVI_EDID,EDID_dvi,128);
                      }
              
                              if (ChecKDVIDoubleFlag)
                              {
                                      Clr_Load_DVIEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
              }
              #else
              
                      BYTE i;
              
                      mStar_ClrDDC_WP();
              
                      mStar_DVIDDC_Base_Address();
                      
                      #if USEFLASH
                      #if User_DDCTO_FlashSave
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0, DDCDKEY_SIZE, &DDC1, DDCDKEY_SIZE);
                      #else
                              #message "DVI DDC Data User Default EDID"
                      #endif
                      #else
                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
                      
                      #if User_DDCTO_FlashSave
                      if(CheckFlashEDIDData())
                      {       
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, DDC1[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
                              }
                      }
                      else
                      #endif
                      {
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, EDID_dvi[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
                              }
                      }
                      
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 7   

                      Delay1ms(100);
                      mStar_SetDDC_WP(void)();
                      
              #endif
              }
              #endif
              #if ENABLE_HDMI
              void mStar_HDMI_InitDDC(void)
              {
              #if HDMI_Write_EEPROM
                      if (Load_HDMIEDID_Flag)
                      {
              
                              BYTE ChecKHDMIDoubleFlag=0;
                              #if User_DDCTO_FlashSave
                                      BYTE EDID_CheckSum=0 ;
                              #endif
                              
                              #if USEFLASH
                              #if User_DDCTO_FlashSave
                                      CleanDDCBuff ();
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0, DDCHKEY_SIZE, &DDC1, DDCHKEY_SIZE);
                                      EDID_CheckSum=DDC1[0x7F];
                              #else
                                      #message "HDMI DDC Data User Default EDID"
                              #endif
                              #endif
              
                      #if User_DDCTO_FlashSave
                    if (CheckFlashEDIDData())
                      {       
                              ChecKHDMIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(HDMI_EDID,DDC1,256);
                      }
                      else
                      #endif
                      {       
                              ChecKHDMIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(HDMI_EDID,EDID_hdmi,256);
                      }
              
                              if (ChecKHDMIDoubleFlag)
                              {
                                      Clr_Load_HDMIEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
              }
              #endif          
              #if CHIP_ID==CHIP_TSUMF
              DDC_Port_Sel();
              #endif
              
              }
              #endif
              #if ENABLE_HDMI2
              void mStar_HDMI2_InitDDC(void)
              {
              #if HDMI2_Write_EEPROM
                      if (Load_HDMI2EDID_Flag)
                      {
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 8   

              
                              BYTE ChecKHDMIDoubleFlag=0;
                              #if User_DDCTO_FlashSave
                                      BYTE EDID_CheckSum=0 ;
                              #endif
                              
                              #if USEFLASH
                              #if User_DDCTO_FlashSave
                                      CleanDDCBuff ();
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0, DDCHKEY_SIZE, &DDC1, DDCHKEY_SIZE);
                                      EDID_CheckSum=DDC1[0x7F];
                              #else
                                      #message "HDMI2 DDC Data User Default EDID"
                              #endif
                              #endif
              
                      #if User_DDCTO_FlashSave
                    if (CheckFlashEDIDData())
                      {       
                              ChecKHDMIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(HDMI2_EDID,DDC1,256);
                      }
                      else
                      #endif
                      {       
                              ChecKHDMIDoubleFlag = Init_AllPort_Ddc_ToE2PROM_Func(HDMI2_EDID,EDID_hdmi2,256);
                      }
              
                              if (ChecKHDMIDoubleFlag)
                              {
                                      Clr_Load_HDMI2EDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
              }
              #endif          
              }
              #endif
              
              
              #else
 462          
 463          
 464          
 465          #if ENABLE_VGA
 466          void mStar_VGA_InitDDC(void)
 467          {
 468   1      #if VGA_Write_EEPROM//æ˜¯å¦å¤–æŒ‚eeprom
              
              if (Load_VGAEDID_Flag)//æ˜¯å¦è¯»EDID
              {
                      BYTE i;
                      BYTE  ReadCheckSum=0;
                      BYTE  dd=0;
                      BYTE CheckVGADoubleFlag=0;
                      #if User_DDCTO_FlashSave
                      BYTE EDID_CheckSum=0 ;
                      #endif
                      
                      #if USEFLASH
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 9   

                      #if User_DDCTO_FlashSave//å¦‚æžœå¤–çƒ§
                              CleanDDCBuff();//æ¸…ç©ºDDC1æ•°ç»„
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, &DDC1, DDCAKEY_SIZE);//å°†falshä¸­çš„ED
             -IDè¯»åˆ°DDC1ä¸­
                              EDID_CheckSum=DDC1[0x7F];//å°†æ ¡éªŒä½çš„å€¼èµ‹ç»™è¯¥å˜é‡
                      #else
                              #message "VGA DDC Data User Default EDID"
                      #endif
                      #else
                              //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
              
              #if 1
              #if User_DDCTO_FlashSave
                   if (CheckFlashEDIDData())//æ ¡éªŒEDIDçš„å¤´
                      {
                              hw_ClrDDC_WP();//æ¸…é™¤å†™ä¿æŠ¤
                                      
                              Delay1ms(2);
                              
                              EnableReadDDCType=VGA_EDID;//åˆ‡æ¢ç›¸åº”çš„IICç±»åž‹
                              Init_NVRAM_I2C_SCL_Pin(); //åˆå§‹åŒ–IICçš„æ—¶é’Ÿçº¿
                              Init_NVRAM_I2C_SDA_Pin();//åˆå§‹åŒ–iicçš„æ•°æ®çº¿
              
                              for(i=0; i<128; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, DDC1[i]);//å°†DDC1ä¸­çš„EDIDå†™åˆ°eepromä¸­
                               }      
              
                              hw_SetDDC_WP();//å¼€å¯å†™ä¿æŠ¤
                              
                              Delay1ms(2);
              
                              for (i=0; i<128; i++)
                              {
                                      DDC1[i]=0xFF;
                              }
              
                              for(i=0; i<128; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       //å°†ä»Žeepromè¯»çš„EDIDå†™åˆ°DDC1ä¸­
                                      ReadCheckSum+=DDC1[i];//å°†æ•°æ®ç´¯åŠ ï¼Œå¾—åˆ°æ ¡éªŒä½çš„å€¼
                               }      
              
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)//æ ¡éªŒæ‰€è¯»åˆ°ç
             -š„EDIDçš„å¤´å’ŒcheckSumå’Œä¿¡å·ç±»åž‹
                               &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_CheckSum))//
                              {
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)!=0x80))//æ ¡éªŒreadchecksumå’Œä¿¡å·ç±»åž‹
                                      {
                                              CheckVGADoubleFlag=1;//æ¡ä»¶æ»¡è¶³æ ‡å¿—ä½ä¸º1
                                      }
                              }
              
                              if (CheckVGADoubleFlag)
                              {
                                      Clr_Load_VGAEDID_Flag();//æ¸…é™¤æ ‡å¿—ä½ï¼Œé˜²æ­¢ä¸‹æ¬¡ä¸Šç”µé‡æ–°åˆå§‹åŒ–
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );//ä¿å­˜æ ‡å¿—ä½
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 10  

                              #endif
                              }
                              
                      }
                      else    //æ²¡æœ‰è¯»å–EDIDçš„å¤´çš„å€¼
                      #endif
                      {
                              hw_ClrDDC_WP();//æ¸…é™¤å†™ä¿æŠ¤
                                      
                              Delay1ms(5);
                              
                              EnableReadDDCType=VGA_EDID;//åˆ‡æ¢ç›¸åº”çš„IICç±»åž‹
                              Init_NVRAM_I2C_SCL_Pin();//åˆå§‹åŒ–IICæ—¶é’Ÿçº¿
                              Init_NVRAM_I2C_SDA_Pin();//åˆå§‹åŒ–æ•°æ®çº¿
              
                              for(i=0; i<128; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, EDID_vga[i]);//å°†codeä¸­çš„EDIDåˆ°eeprom
                               }      
              
                              hw_SetDDC_WP();//å¼€å¯å†™ä¿æŠ¤
                              
                              Delay1ms(5);
              
                              for(i=0; i<128; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       //å°†eepromè¯»çš„EDIDå†™åˆ°DDC1ä¸­
                                      ReadCheckSum+=DDC1[i];//å°†æ•°æ®ç´¯åŠ ï¼Œå¾—åˆ°æ ¡éªŒä½çš„å€¼
                                    // printMsg("11111111111111");
                                      //  printData("DDC1[i]====%x",DDC1[i]);   
                                      
                               }      
                            // printData("ReadCheckSum", ReadCheckSum);
                                         
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_vga[0x7F]))///æ ¡éªŒæ‰€è¯»åˆ°çš„E
             -DIDçš„å¤´å’ŒcheckSumå’Œä¿¡å·ç±»åž‹
                              {
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)!=0x80))//æ ¡éªŒreadchecksumå’Œä¿¡å·ç±»åž‹
                                      {
                                              CheckVGADoubleFlag=1;
                                      }
                              }
                      //printData("CheckVGADoubleFlag====%d",CheckVGADoubleFlag);
                              if (CheckVGADoubleFlag)
                              {
                                      Clr_Load_VGAEDID_Flag();//æ¸…é™¤æ ‡å¿—ä½ï¼Œé˜²æ­¢ä¸‹æ¬¡ä¸Šç”µé‡æ–°åˆå§‹åŒ–
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );//ä¿å­˜æ ‡å¿—ä½
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
                              EnableReadDDCType=I2C_EEPROM;   
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
                      }
              #endif  
              }
              
              #else                                           //ä¸å¤–æŒ‚
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 11  

 602   1      
 603   1              BYTE i;
 604   1      
 605   1              mStar_ClrDDC_WP();//æ¸…é™¤å†™ä¿æŠ¤
 606   1      
 607   1              mStar_VGADDC_Base_Address();//åˆ†é…åŸºåœ°å€
 608   1              
 609   1              #if USEFLASH
 610   1              #if User_DDCTO_FlashSave
 611   1                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, &DDC1, DDCAKEY_SIZE);//å°†falshä¸­çš„ED
             -IDè¯»åˆ°DDC1ä¸­
 612   1                      #message "VGA DDC Data User Default EDID and Flash EDID"
*** MESSAGE C320 IN LINE 612 OF ..\..\KERNEL\SCALER\DDC.c: "VGA DDC Data User Default EDID and Flash EDID"
 613   1              #else
                              #message "VGA DDC Data User Default EDID"
                      #endif
 616   1              #else
                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
 619   1              
 620   1              #if User_DDCTO_FlashSave//å°†flashä¸­çš„EDIDå†™åˆ°DDCä¸­ï¼Œå†å°†DDCä¸­çš„EDIDå†™åˆ°å†…éƒ¨Buffer
 621   1              if(CheckFlashEDIDData())//æ ¡éªŒEDIDçš„å¤´
 622   1              {       
 623   2                      for(i = 0; i < 128; i++)
 624   2                      {
 625   3                              msWriteByte(REG_3E4B, i);//ä½¿èƒ½DDCå†™
 626   3                              msWriteByte(REG_3E4C, DDC1[i]);                 //å¾—åˆ°DDC1ä¸­çš„EDIDå†™å…¥å†…éƒ¨Buffer                                                                        å¤–çƒ§
 627   3                              msWriteByteMask(REG_3E43, BIT5,BIT5);
 628   3      
 629   3                              while(msReadByte(REG_3E7B) & BIT5); //è¯»å–å†…éƒ¨Bufferä¸­çš„EDIDï¼›æ ¡éªŒä¸€ä¸‹
 630   3                      }
 631   2              }
 632   1              else  // å°†codeä¸­çš„EDIDå†™åˆ°å†…éƒ¨Buffer
 633   1              #endif
 634   1              {
 635   2                      for(i = 0; i < 128; i++)
 636   2                      {
 637   3                              msWriteByte(REG_3E4B, i);//ä½¿èƒ½DDCå†™
 638   3                              msWriteByte(REG_3E4C, EDID_vga[i]);//å¾—åˆ°codeä¸­çš„EDIDå†™å…¥å†…éƒ¨Buffer     
 639   3                              msWriteByteMask(REG_3E43, BIT5,BIT5);//                                                 ä¸å¤–çƒ§
 640   3      
 641   3                              while(msReadByte(REG_3E7B) & BIT5);  //è¯»å–å†…éƒ¨Bufferä¸­çš„EDID 
 642   3                      }
 643   2              }
 644   1              
 645   1              mStar_SetDDC_WP();//å†™ä¿æŠ¤
 646   1              
 647   1      #endif
 648   1      
 649   1      }
 650          #endif
 651          #if ENABLE_DVI
              void mStar_DVI_InitDDC(void)
              {
              #if DVI_Write_EEPROM
              #if DEBUG_PRINTDATA
              printData("Load_DVIIEDID_FlagAA=%d",Load_DVIIEDID_Flag);    
              #endif          
              
              if (Load_DVIIEDID_Flag)
              {
              
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 12  

                      BYTE i;
                      BYTE  ReadCheckSum=0;
                      BYTE  dd=0;
                      BYTE CheckDVIDoubleFlag=0;
                      #if User_DDCTO_FlashSave
                      BYTE EDID_CheckSum=0 ;
                      #endif
                      #if USEFLASH
                      #if User_DDCTO_FlashSave
                              CleanDDCBuff ();
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0, DDCDKEY_SIZE, &DDC1, DDCDKEY_SIZE);
                              EDID_CheckSum=DDC1[0x7F];
                      #else
                              #message "DVI DDC Data User Default EDID"
                      #endif
                      #else
                              //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
                      
              #if User_DDCTO_FlashSave
                   if (CheckFlashEDIDData())
                      {
                              #if ENABLE_DEBUG
                              printMsg("DVI0000000");
                              #endif
                              
                              hw_ClrDDC_WP();
                                      
                              Delay1ms(10);
                              
                              EnableReadDDCType=DVI_EDID;
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
              
                              for(i=0; i<128; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, DDC1[i]);
                               }      
              
                              Delay1ms(100);
              
                              hw_SetDDC_WP();
                              
                              Delay1ms(2);
              
                              for (i=0; i<128; i++)
                              {
                                      DDC1[i]=0xFF;
                              }
              
                              for(i=0; i<128; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       
                                      ReadCheckSum+=DDC1[i];
                               }      
              
                              
                              Delay1ms(100);
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_CheckSum))
                              {
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 13  

                                                      #if ENABLE_DEBUG
                              printMsg("DVI1111111");
                              #endif
              
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
                                      {
                                              CheckDVIDoubleFlag=1;
                                      }
                              }
              
                              if (CheckDVIDoubleFlag)
                              {
                                      Clr_Load_DVIEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
                              EnableReadDDCType=I2C_EEPROM;
              
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                              
                      }
                      else
                      #endif
                      {
                              #if ENABLE_DEBUG
                              printMsg("DVI  EDID  INIT");
                              #endif
                              hw_ClrDDC_WP();
                                      
                              Delay1ms(5);
                              
                              EnableReadDDCType=DVI_EDID;
                              Init_NVRAM_I2C_SCL_Pin();
                              Init_NVRAM_I2C_SDA_Pin();
              
                              for(i=0; i<128; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, EDID_dvi[i]);
                               }      
                              Delay1ms(100);
              
                              hw_SetDDC_WP();
                              
                              Delay1ms(5);
              
                              for(i=0; i<128; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       
                                      ReadCheckSum+=DDC1[i];
                               }      
              
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_dvi[0x7F]))
                              {
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
                                      {
                                              CheckDVIDoubleFlag=1;
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 14  

                                      }
                              }
              
                              if (CheckDVIDoubleFlag)
                              {
                                      Clr_Load_DVIEDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              #if ENABLE_DEBUG
                              printMsg("DVI  EDID  PASS");
                              #endif
                              }
                              EnableReadDDCType=I2C_EEPROM;   
              
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                      }
              }
              #else
              
                      BYTE i;
              
                      mStar_ClrDDC_WP();
              
                      mStar_DVIDDC_Base_Address();
                      
                      #if USEFLASH
                      #if User_DDCTO_FlashSave
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0, DDCDKEY_SIZE, &DDC1, DDCDKEY_SIZE);
                      #else
                              #message "DVI DDC Data User Default EDID"
                      #endif
                      #else
                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                      #endif
                      
                      #if User_DDCTO_FlashSave
                      if(CheckFlashEDIDData())
                      {       
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, DDC1[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
                              }
                      }
                      else
                      #endif
                      {
                              for(i = 0; i < 128; i++)
                              {
                                      msWriteByte(REG_3E4B, i);
                                      msWriteByte(REG_3E4C, EDID_dvi[i]);
                                      msWriteByteMask(REG_3E43, BIT5,BIT5);
                              }
                      }
                      
                  Delay1ms(100);
                      mStar_SetDDC_WP();
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 15  

                      
              #endif
              }
              #endif
 852          #if ENABLE_HDMI
 853          void mStar_HDMI_InitDDC(void)
 854          {
 855   1      #if HDMI_Write_EEPROM
 856   1              if (Load_HDMIEDID_Flag)
 857   1              {
 858   2                      WORD i;
 859   2                      BYTE  ReadCheckSum=0;
 860   2                      BYTE  dd=0;
 861   2                      BYTE ChecKHDMIDoubleFlag=0;
 862   2                      #if User_DDCTO_FlashSave
 863   2                              BYTE EDID_CheckSum=0 ;
 864   2                      #endif
 865   2                      
 866   2                      #if USEFLASH
 867   2                      #if User_DDCTO_FlashSave
 868   2                              CleanDDCBuff ();
 869   2                              #if 0//ENABLE_HDMI2
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0, DDCHKEY_SIZE, &DDC1, DDCHKEY_SIZE);
                                      #else
 872   2                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0, DDCHKEY_SIZE, &DDC1, DDCHKEY_SIZE);
 873   2                              #endif
 874   2                              EDID_CheckSum=DDC1[0x7F];
 875   2                              #message "HDMI DDC Data User Default EDID and Flash EDID"
*** MESSAGE C320 IN LINE 875 OF ..\..\KERNEL\SCALER\DDC.c: "HDMI DDC Data User Default EDID and Flash EDID"
 876   2                      #else
                                      #message "HDMI DDC Data User Default EDID"
                              #endif
 879   2                      #else
                                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                              #endif
 882   2      
 883   2      #if User_DDCTO_FlashSave
 884   2           if (CheckFlashEDIDData())
 885   2              {
 886   3                      hw_ClrDDC_WP();
 887   3                              
 888   3                      Delay1ms(2);
 889   3                      
 890   3                      EnableReadDDCType=HDMI_EDID;
 891   3                      Init_NVRAM_I2C_SCL_Pin();
 892   3                      Init_NVRAM_I2C_SDA_Pin();
 893   3      
 894   3                      for(i=0; i<256; i++)
 895   3                       {
 896   4                          NVRam_WriteByte(NVRAM_ADDR_EDID+i, DDC1[i]);
 897   4                       }      
 898   3                      Delay1ms(100);
 899   3      
 900   3                      hw_SetDDC_WP();
 901   3                      
 902   3                      Delay1ms(2);
 903   3      
 904   3                      for (i=0; i<256; i++)
 905   3                      {
 906   4                              DDC1[i]=0xFF;
 907   4                      }
 908   3      
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 16  

 909   3                      for(i=0; i<256; i++)
 910   3                       {
 911   4                              NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
 912   4                              DDC1[i]=dd;       
 913   4                              ReadCheckSum+=DDC1[i];
 914   4                       }      
 915   3      
 916   3                      if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
 917   3                      &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_CheckSum))
 918   3                      {
 919   4                              if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
 920   4                              {
 921   5                                      ChecKHDMIDoubleFlag=1;
 922   5                              }
 923   4                      }
 924   3      
 925   3                      if (ChecKHDMIDoubleFlag)
 926   3                      {
 927   4                              Clr_Load_HDMIEDID_Flag();
 928   4                      #if USEFLASH
 929   4                              UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
 930   4                      #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
 933   4                      }
 934   3      
 935   3                      
 936   3                      EnableReadDDCType=I2C_EEPROM;
 937   3      
 938   3                              Init_NVRAM_I2C_SCL_Pin();
 939   3                              Init_NVRAM_I2C_SDA_Pin();
 940   3                      
 941   3              }
 942   2              else
 943   2              #endif
 944   2              {
 945   3                      hw_ClrDDC_WP();
 946   3                              
 947   3                      Delay1ms(2);
 948   3                      
 949   3                      EnableReadDDCType=HDMI_EDID;
 950   3                      Init_NVRAM_I2C_SCL_Pin();
 951   3                      Init_NVRAM_I2C_SDA_Pin();
 952   3      
 953   3                      for(i=0; i<256; i++)
 954   3                       {
 955   4                          NVRam_WriteByte(NVRAM_ADDR_EDID+i, EDID_hdmi[i]);
 956   4                       }      
 957   3                      Delay1ms(100);
 958   3      
 959   3                      hw_SetDDC_WP();
 960   3                      
 961   3                      Delay1ms(2);
 962   3      
 963   3                      for(i=0; i<256; i++)
 964   3                       {
 965   4                              NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
 966   4                              DDC1[i]=dd;       
 967   4                              ReadCheckSum+=DDC1[i];
 968   4                       }      
 969   3      
 970   3                      if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 17  

 971   3                      &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_hdmi[0x7F]))
 972   3                      {
 973   4                              if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
 974   4                              {
 975   5                                      ChecKHDMIDoubleFlag=1;
 976   5                              }
 977   4                      }
 978   3      
 979   3                      if (ChecKHDMIDoubleFlag)
 980   3                      {
 981   4                              Clr_Load_HDMIEDID_Flag();
 982   4                      #if USEFLASH
 983   4                              UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
 984   4                      #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
 987   4                      }
 988   3                      EnableReadDDCType=I2C_EEPROM;   
 989   3                      Init_NVRAM_I2C_SCL_Pin();
 990   3                      Init_NVRAM_I2C_SDA_Pin();
 991   3              }
 992   2      }
 993   1      #endif          
 994   1      #if CHIP_ID==CHIP_TSUMF
              DDC_Port_Sel();
              #endif
 997   1      
 998   1      }
 999          #endif
1000          
1001          #if ENABLE_HDMI2
              void mStar_HDMI2_InitDDC(void)
              {
              #if HDMI2_Write_EEPROM
              
                      if (Load_HDMI2EDID_Flag)
                      {
                              WORD i;
                              BYTE  ReadCheckSum=0;
                              BYTE  dd=0;
                              bit ChecKHDMIDoubleFlag=0;
                              #if User_DDCTO_FlashSave
                                      BYTE EDID_CheckSum=0 ;
                              #endif
                              
                              #if USEFLASH
                              #if User_DDCTO_FlashSave
                                      CleanDDCBuff ();
                                      Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0, DDCHKEY_SIZE, &DDC1, DDCHKEY_SIZE);
                                      EDID_CheckSum=DDC1[0x7F];
                              #else
                                      #message "HDMI2 DDC Data User Default EDID"
                              #endif
                              #else
                                      //NVRam_ReadTbl(DDC_ADC_ADDR, DDC1, 128);
                              #endif
              
              #if User_DDCTO_FlashSave
                   if (CheckFlashEDIDData())
                      {
                              hw_ClrDDC_WP();
                                      
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 18  

                              Delay1ms(2);
                              
                              EnableReadDDCType=HDMI2_EDID;
              
                              for(i=0; i<256; i++)
                               {
                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, DDC1[i]);
                               }      
              
                              hw_SetDDC_WP();
                              
                              Delay1ms(2);
              
                              for (i=0; i<256; i++)
                              {
                                      DDC1[i]=0xFF;
                              }
              
                              for(i=0; i<256; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       
                                      ReadCheckSum+=DDC1[i];
                               }      
              
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_CheckSum))
                              {
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
                                      {
                                              ChecKHDMIDoubleFlag=1;
                                      }
                              }
              
                              if (ChecKHDMIDoubleFlag)
                              {
                                      Clr_Load_HDMI2EDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
              
                              
                              EnableReadDDCType=I2C_EEPROM;
              
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                              
                      }
                      else
                      #endif
                      {
                              hw_ClrDDC_WP();
                                      
                              Delay1ms(2);
                              
                              EnableReadDDCType=HDMI2_EDID;
              
                              for(i=0; i<256; i++)
                               {
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 19  

                                  NVRam_WriteByte(NVRAM_ADDR_EDID+i, EDID_hdmi2[i]);
                               }      
              
                              hw_SetDDC_WP();
                              
                              Delay1ms(2);
              
                              for(i=0; i<256; i++)
                               {
                                      NVRam_ReadByte(NVRAM_ADDR_EDID+i, &dd);
                                      DDC1[i]=dd;       
                                      ReadCheckSum+=DDC1[i];
                               }      
              
                              if((DDC1[0]==0x00)&&(DDC1[1]==0xFF)&&(DDC1[2]==0xFF)&&(DDC1[3]==0xFF)&&(DDC1[4]==0xFF)
                              &&(DDC1[5]==0xFF)&&(DDC1[6]==0xFF)&&(DDC1[7]==0x00)&&(DDC1[0x7F]==EDID_hdmi[0x7F]))
                              {
                                      if ((ReadCheckSum)==0&&((DDC1[0x14]&0x80)==0x80))
                                      {
                                              ChecKHDMIDoubleFlag=1;
                                      }
                              }
              
                              if (ChecKHDMIDoubleFlag)
                              {
                                      Clr_Load_HDMI2EDID_Flag();
                              #if USEFLASH
                                      UserPref_EnableFlashSaveBit( bFlashSaveMonitorBit );
                              #else   
                                      NVRam_WriteWord(nvrMonitorAddr(MonitorFlag), MonitorFlags);
                              #endif
                              }
                              EnableReadDDCType=I2C_EEPROM;   
              
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                      }
              }
              #endif          
              }
              #endif
1136          
1137          #endif
1138          
1139          
1140          
1141          void mStar_InitDDC(void)
1142          {
1143   1      #if ENABLE_VGA
1144   1              mStar_VGA_InitDDC();                    //my EDID
1145   1      #endif
1146   1      
1147   1      #if ENABLE_DVI
                      mStar_DVI_InitDDC();
              #endif
1150   1      
1151   1      #if ENABLE_HDMI
1152   1              mStar_HDMI_InitDDC();
1153   1      #endif
1154   1      
1155   1      #if ENABLE_HDMI2
                      mStar_HDMI2_InitDDC();
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 20  

              #endif
1158   1      }
1159          
1160          /*********************************************************************************************************
             -/
1161          #if WriteSN_Functiom_New
              extern code BYTE EDID[];
              void ReLoadEDIDtoAddSN(void)
              {
              BYTE Week=0x00,Year=0x1C;
              BYTE SNdata[18];
              WORD i;
              BYTE  ReadCheckSum=0;
              BYTE  dd=0;
              
              //2    1  ¶ÁÈ¡EDID    Ö»½ÓÊÜÒ»Â·
                #if ENABLE_VGA
                           Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, 
              DDC1, DDCAKEY_SIZE);
                #elif ENABLE_DVI
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0,   DDCDKEY_SIZE, DDC1, 
              DDCDKEY_SIZE);  
                #elif ENABLE_HDMI
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0,   DDCHKEY_SIZE, 
              DDC1, DDCHKEY_SIZE);    
                #endif
              
              //2  2 ½ØÈ¡ SN   (±ØÐëÔÚ6C -7D ¼ä)
              
              
              //for(i = 0;i<18;i++) SNdata[i] = DDC1[0X5A+i];
              Week = DDC1[0x10];
              Year = DDC1[0x11];  
              for(i = 0;i<14;i++) SNdata[i] = DDC1[0x70+i];
              
              //2  3 Æ´ºÏSN
              
              #if ENABLE_VGA
              #if VGA_Write_EEPROM
              Set_Load_VGAEDID_Flag();
              #endif
              #endif
              
              #if ENABLE_DVI
              #if !ENABLE_VGA
              Set_Load_DVIEDID_Flag();
              #else
              #if DVI_Write_EEPROM
                    ReadCheckSum = 0;
                      hw_ClrDDC_WP();         
                      Delay1ms(2);
                      EnableReadDDCType=DVI_EDID;
                      NVRam_WriteByte(0x10, Week);
                      NVRam_WriteByte(0x11, Year);
                      for(i=0; i<14; i++)
                       {
                          NVRam_WriteByte(0x70+i, SNdata[i]);
                       }      
                      for(i=0; i<127; i++)
                       {
                              NVRam_ReadByte(i, &dd);
                              ReadCheckSum+=dd;
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 21  

                       }      
                      NVRam_WriteByte(0x7F, 0x100-ReadCheckSum);
                      hw_SetDDC_WP();
              #else
                      for(i=0; i<128; i++) DDC1[i] = DVI_EDID[i];
                      DDC1[0x10] = Week;
                      DDC1[0x11] = Year ;
                      for(i = 0;i<14;i++)  DDC1[0x70+i] = SNdata[i] ;
                      for(i=0; i<127; i++) ReadCheckSum+=DDC1[i];
                      DDC1[0x7F] = 0x100-ReadCheckSum;
                      Flash_Write_Factory_KeySet(FLASH_KEY_DDCD, FALSE,  DDCHKEY_SIZE, DDC1, 
              DDCDKEY_SIZE);
              #endif
              #endif
              #endif
              
              
              //3   HDMI Ò»°ã´æ·ÅÓÚ24C02
              //3(3)  Ö±½Ó²Ù×÷24C02
              #if ENABLE_HDMI
              #if !ENABLE_VGA&&!ENABLE_DVI
                   Set_Load_HDMIEDID_Flag();
              #else
                     ReadCheckSum = 0;
                      hw_ClrDDC_WP();         
                      Delay1ms(2);
                      EnableReadDDCType=HDMI_EDID;
                      NVRam_WriteByte(0x10, Week);
                      NVRam_WriteByte(0x11, Year);
                      for(i=0; i<14; i++)
                       {
                          NVRam_WriteByte(0x70+i, SNdata[i]);
                       }      
                      for(i=0; i<127; i++)
                       {
                              NVRam_ReadByte(i, &dd);
                              ReadCheckSum+=dd;
                       }      
                      NVRam_WriteByte(0x7F, 0x100-ReadCheckSum);
                      hw_SetDDC_WP();
                      
                      EnableReadDDCType=I2C_EEPROM;   
              #endif  
              #endif
              
              #if ENABLE_HDMI2
                      ReadCheckSum = 0;
                      hw_ClrDDC_WP();         
                      Delay1ms(2);
                      EnableReadDDCType=HDMI2_EDID;
                      NVRam_WriteByte(0x10, Week);
                      NVRam_WriteByte(0x11, Year);
                      for(i=0; i<14; i++)
                       {
                          NVRam_WriteByte(0x70+i, SNdata[i]);
                       }      
                      for(i=0; i<127; i++)
                       {
                              NVRam_ReadByte(i, &dd);
                              ReadCheckSum+=dd;
                       }      
                      NVRam_WriteByte(0x7F, 0x100-ReadCheckSum);
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 22  

                      hw_SetDDC_WP();
              
                      EnableReadDDCType=I2C_EEPROM;           
                      
              #endif
              
              
              //3 (4)  DP Òª»Ø´æFlash
              #if ENABLE_DP_INPUT     &&   DP_WRITE_SN
                     ReadCheckSum = 0;
                      for(i=0; i<256; i++) DDC1[i] = EDID[i];
                      DDC1[0x10] = Week;
                      DDC1[0x11] = Year ;
                      for(i = 0;i<14;i++)  DDC1[0x70+i] = SNdata[i] ;
                      for(i=0; i<127; i++) ReadCheckSum+=DDC1[i];
                      DDC1[0x7F] = 0x100-ReadCheckSum;
                      Flash_Write_Factory_KeySet(FLASH_KEY_HDCP, FALSE,  DDCHKEY_SIZE, DDC1, 
              DDCHKEY_SIZE);
              #endif
              
              
              }
              #endif
1303          /*********************************************************************************************************
             -/
1304          
1305          #if FreeSyncSwitchEDID
              //*************************************************
              //Check EDID Support FreeSync or Not
              //If No Support return 0  (HDMI1FreeSyncED&&HDMI2FreeSyncED==0)
              //If Support return 1 HDMI1FreeSyncED&&HDMI2FreeSyncED is the 0xED Addrs  (HDMI1FreeSyncED&&HDMI2FreeSyncE
             -D>=128)
              //*************************************************
              Bool CheckEDIDSupportFreeSync(BYTE Input)
              {
                      BYTE temp;
                      if(Input==HDMI_EDID)
                      {
                      for(temp=0;temp<125;temp++)
                      {
                                      if((EDID_hdmi[128+temp]==0x68)&&(EDID_hdmi[128+temp+1]==0x1A)&&(EDID_hdmi[128+temp+2]==0x00)&&(EDID_hdm
             -i[128+temp+3]==0x00)&&(EDID_hdmi[128+temp+4]==0x01)&&(EDID_hdmi[128+temp+5]==0x01))
                                      {
                                              HDMI1FreeSyncED=temp+8+128;
                                              return 1;
                                      }
                              }
                              if(temp>=124)
                              {
                                      HDMI1FreeSyncED=0;
                                      return 0;
                              }
                      }
              
              #if ENABLE_HDMI2
                      if(Input==HDMI2_EDID)
                      {
              
                      for(temp=0;temp<125;temp++)
                      {
                                      if((EDID_hdmi2[128+temp]==0x68)&&(EDID_hdmi2[128+temp+1]==0x1A)&&(EDID_hdmi2[128+temp+2]==0x00)&&(EDID_
             -hdmi2[128+temp+3]==0x00)&&(EDID_hdmi2[128+temp+4]==0x01)&&(EDID_hdmi2[128+temp+5]==0x01))
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 23  

                                      {
                                              HDMI2FreeSyncED=temp+8+128;
                                              return 1;
                                      }
                              }
                              if(temp>=124)
                              {
                                      HDMI2FreeSyncED=0;
                                      return 0;
                              }               
              
                      }
                      #endif
                      return 0;
              
              
              }
              //*************************************************
              //Í¨¹ýÄ¬ÈÏEDIDÖ±½Ó·µ»ØÒ»¸ö¿ª»ò¹Ø¶ÔÓ¦µÄCheckSum
              //Èç¹ûÄ¬ÈÏEDID²»Ö§³ÖFreeSync ·µ»Ø NULL
              //*************************************************
              BYTE GetEDIDCheckSum(BYTE Input, BYTE OnOff)
              {
                      if(Input==HDMI_EDID)
                      {
                              if(CheckEDIDSupportFreeSync(Input))
                              {
                                      if(EDID_hdmi[HDMI1FreeSyncED]==0xED)
                                      {
                                              if(OnOff)
                                              {
                                                      return (EDID_hdmi[0xFF]+0xED);
                                              }
                                              else
                                              {
                                                      return (EDID_hdmi[0xFF]);
                                              }
                                      }
                                      else
                                      {
                                              if(OnOff)
                                              {
                                                      return (EDID_hdmi[0xFF]);
                                              }
                                              else
                                              {
                                                      return (EDID_hdmi[0xFF]-0xED);
                                              }
                                      }
                              }
                              else
                              {
                                      return 0;
                              }
                      }
                      #if ENABLE_HDMI2
                      if(Input==HDMI2_EDID)
                      {
                              if(CheckEDIDSupportFreeSync(Input))
                              {
                                      if(EDID_hdmi2[HDMI2FreeSyncED]==0xED)
                                      {
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 24  

                                              if(OnOff)
                                              {
                                                      return (EDID_hdmi2[0xFF]+0xED);
                                              }
                                              else
                                              {
                                                      return (EDID_hdmi2[0xFF]);
                                              }
                                      }
                                      else
                                      {
                                              if(OnOff)
                                              {
                                                      return (EDID_hdmi2[0xFF]);
                                              }
                                              else
                                              {
                                                      return (EDID_hdmi2[0xFF]-0xED);
                                              }
                                      }
                              }
                              else
                              {
                                      return 0;
                              }
                      }
                      #endif
              return 0;
              }
              //*************************************************
              //Write Success Return 1
              //Write Fail Or Default EDID NoSupport FreeSync Return 0
              //*************************************************
              Bool  FreeSyncEDIDSwitch(BYTE Input, BYTE OnOff)
              {
                      //BYTE CheckCount;
                      BYTE xdata EDIDCheckSum=GetEDIDCheckSum(Input,OnOff);
              
              
                      #if ENABLE_DEBUG
                      printData("EDIDCheckSum   %d", EDIDCheckSum);
                      #endif
                      
                      if(EDIDCheckSum)
                      {
                              if(Input==HDMI_EDID)
                              {
                                      #if ENABLE_DEBUG
                                      printData("HDMI1FreeSyncED   %d", HDMI1FreeSyncED);
                                      #endif
                                      
                                      EnableReadDDCType = HDMI_EDID;
                                      hw_ClrDDC_WP();
                                      Delay1ms(2);
                                      if(OnOff)
                                      {
              
                                              //i2c_WriteTBL(0xA0, HDMI1FreeSyncED, ,1);      
                                              //i2c_WriteTBL(0xA0, HDMI1FreeSyncED, &ED_0x00, 1);
                                              NVRam_WriteByte(HDMI1FreeSyncED,0x00);
                                              //i2c_WriteTBL(0xA0, 0xFF, &EDIDCheckSum, 1);
                                              NVRam_WriteByte(0xFF,EDIDCheckSum);
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 25  

                                      }
                                      else
                                      {
                                      #if ENABLE_DEBUG
                                      printMsg("close freesync");
                                      #endif
                                              //i2c_WriteTBL(0xA0, HDMI1FreeSyncED, &ED_0xED, 1);
                                              NVRam_WriteByte(HDMI1FreeSyncED,0xED);
                                              //i2c_WriteTBL(0xA0, 0xFF, &EDIDCheckSum, 1);
                                              NVRam_WriteByte(0xFF,EDIDCheckSum);
                                      }
                                      ForceDelay1ms(30);
                                      hw_SetDDC_WP();
                                      EnableReadDDCType = 0xFF;
                              }
                              #if ENABLE_HDMI2
                              if(Input==HDMI2_EDID)
                              {
                                      EnableReadDDCType = Input;
                                      hw_ClrDDC_WP();
                                      if(OnOff)
                                      {//i2c_WriteTBL;
                                              //i2c_WriteTBL(0xA0, HDMI2FreeSyncED, &ED_0x00, 1);
                                              NVRam_WriteByte(HDMI1FreeSyncED,0x00);
                                              //i2c_WriteTBL(0xA0, 0xFF, &EDIDCheckSum, 1);
                                              NVRam_WriteByte(0xFF,EDIDCheckSum);
                                      }
                                      else
                                      {
                                              //i2c_WriteTBL(0xA0, HDMI2FreeSyncED, &ED_0xED, 1);
                                              NVRam_WriteByte(HDMI1FreeSyncED,0xED);
                                              //i2c_WriteTBL(0xA0, 0xFF, &EDIDCheckSum, 1);
                                              NVRam_WriteByte(0xFF,EDIDCheckSum);
                                      }
                                      ForceDelay1ms(30);
                                      hw_SetDDC_WP();
                                      EnableReadDDCType = 0xFF;
                              }
                              #endif
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                      }
                      else
                      {
                              return 0;
                      }
              
              //Check Write OK?
                      if(Input==HDMI_EDID)
                      {
                              BYTE xdata FreeSyncED=0;
                              BYTE xdata EDIDCheckSumTemp=0;
                      
                              EnableReadDDCType = Input;
                              NVRam_ReadByte(HDMI1FreeSyncED,&FreeSyncED);
                              NVRam_ReadByte(0xFF,&EDIDCheckSumTemp);
                              ForceDelay1ms(30);      
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                              EnableReadDDCType = 0xFF;
              
                                                      #if ENABLE_DEBUG
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 26  

                                      printData("EDIDCheckSumTemp   %d", EDIDCheckSumTemp);
                                      printData("EDIDCheckSum   %d", EDIDCheckSum);
                                      
                                      printData("FreeSyncED   %d", FreeSyncED);
                                      printData("HDMI1FreeSyncED   %d", HDMI1FreeSyncED);
                                      printMsg("====================================");
                                      #endif
                              
                              if(OnOff)
                              {
              
              
                                      if((EDIDCheckSumTemp==EDIDCheckSum)&&(FreeSyncED==0x00))
                                              return 1;
                                      else
                                              return 0;
                              }
                              else
                              {
                                      if((EDIDCheckSumTemp==EDIDCheckSum)&&(FreeSyncED==0xED))
                                              return 1;
                                      else
                                              return 0;
                              }
                      }
                      if(Input==HDMI2_EDID)
                      {
                              BYTE xdata FreeSyncED=0;
                              BYTE xdata EDIDCheckSumTemp=0;
                      
                                      EnableReadDDCType = Input;
                              
                              NVRam_ReadByte(HDMI2FreeSyncED,&FreeSyncED);
                              NVRam_ReadByte(0xFF,&EDIDCheckSumTemp);
                                      
                              ForceDelay1ms(30);      
                                      Init_NVRAM_I2C_SCL_Pin();
                                      Init_NVRAM_I2C_SDA_Pin();
                                      
                              EnableReadDDCType = 0xFF;
                              
                              if(OnOff)
                              {
                                      if((EDIDCheckSumTemp==EDIDCheckSum)&&(FreeSyncED==0x00))
                                              return 1;
                                      else
                                              return 0;
                              }
                              else
                              {
                                      if((EDIDCheckSumTemp==EDIDCheckSum)&&(FreeSyncED==0xED))
                                              return 1;
                                      else
                                              return 0;
                              }
                      }
                      return 0;
              }
              
              #endif
1584          
1585          #if LoadAllPortSeriealnumberByOneVGAPort
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 27  

1586          
1587          #define SNStrat         0x71//0x4D
1588          
1589          #define HDMISNStrat             0x71//0x4D
1590          
1591          void ReLoadEDIDtoAddSN(void)
1592          {
1593   1      BYTE Week=0x00,Year=0x1C;
1594   1      BYTE SNdata[18] = {0};
1595   1      WORD i;
1596   1      BYTE  ReadCheckSum=0;
1597   1      BYTE  dd=0;
1598   1      
1599   1      //2    1  ¶ÁÈ¡EDID    Ö»½ÓÊÜÒ»Â·
1600   1        #if ENABLE_VGA
1601   1                   Flash_Read_Factory_KeySet(FLASH_KEY_DDCA, TRUE, 0, DDCAKEY_SIZE, DDC1, DDCAKEY_SIZE);
1602   1        #elif ENABLE_DVI
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCD, TRUE, 0,   DDCDKEY_SIZE, DDC1, DDCDKEY_SIZE); 
                #elif ENABLE_HDMI
                              Flash_Read_Factory_KeySet(FLASH_KEY_DDCH, TRUE, 0,   DDCHKEY_SIZE, DDC1, DDCHKEY_SIZE); 
                #endif
1607   1      
1608   1      //2  2 ½ØÈ¡ SN   (±ØÐëÔÚ6C -7D ¼ä)
1609   1      
1610   1      
1611   1      //for(i = 0;i<18;i++) SNdata[i] = DDC1[0X5A+i];
1612   1      Week = DDC1[0x10];
1613   1      Year = DDC1[0x11];  
1614   1      for(i = 0;i<13;i++) SNdata[i] = DDC1[SNStrat+i];
1615   1      
1616   1      //2  3 Æ´ºÏSN
1617   1      
1618   1      #if ENABLE_VGA
1619   1      #if VGA_Write_EEPROM
              //Set_LoadVGAEDIDFlag_A();
              #endif
1622   1      #endif
1623   1      
1624   1      
1625   1      //3   HDMI Ò»°ã´æ·ÅÓÚ24C02
1626   1      //3(3)  Ö±½Ó²Ù×÷24C02
1627   1      #if ENABLE_HDMI
1628   1      #if 0
                   Set_Load_HDMIEDID_Flag();
              #else
1631   1             ReadCheckSum = 0;
1632   1              hw_ClrDDC_WP();         
1633   1              Delay1ms(2);
1634   1              EnableReadDDCType=HDMI_EDID;
1635   1              NVRam_WriteByte(0x10, Week);
1636   1              NVRam_WriteByte(0x11, Year);
1637   1              for(i=0; i<13; i++)
1638   1               {
1639   2                  NVRam_WriteByte(HDMISNStrat+i, SNdata[i]);
1640   2               }      
1641   1              for(i=0; i<127; i++)
1642   1               {
1643   2                      NVRam_ReadByte(i, &dd);
1644   2                      ReadCheckSum+=dd;
1645   2               }      
1646   1              NVRam_WriteByte(0x7F, 0x100-ReadCheckSum);
1647   1              hw_SetDDC_WP();
C51 COMPILER V9.01   DDC                                                                   08/18/2023 11:33:19 PAGE 28  

1648   1              
1649   1              EnableReadDDCType=I2C_EEPROM;
1650   1      #endif  
1651   1      #endif
1652   1      
1653   1      }
1654          #endif
1655          
1656          
1657          #ifdef  UseVGACableReadWriteAllPortsEDID
              extern void NVRAM_i2c_WriteTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count);
              extern void NVRAM_i2c_ReadTBL(BYTE deviceID, WORD addr, BYTE *buffer, BYTE count);
              
              
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1322    ----
   CONSTANT SIZE    =    530    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      31
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
