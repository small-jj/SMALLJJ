C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MSFLASH
OBJECT MODULE PLACED IN .\obj\msflash.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\KERNEL\SYSTEM\msflash.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC
                    -;..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL
                    -\SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\
                    -INC) DEFINE(ModelName=MODEL_T24_TCL) DEBUG OBJECTEXTEND PRINT(.\list\msflash.lst) OBJECT(.\obj\msflash.obj)

line level    source

   1          /******************************************************************************
   2           Copyright (c) 2005 MStar Semiconductor, Inc.
   3           All rights reserved.
   4          
   5           [Module Name]: Msflash.c
   6           [Date]:        25-Apr-2003
   7           [Comment]:
   8             MST Flash subroutines.
   9           [Reversion History]:
  10          *******************************************************************************/
  11          #define _MSFLASH_C_
  12          
  13          #include <intrins.h>
  14          #include "types.h"
  15          #include "board.h"
*** MESSAGE C320 IN LINE 337 OF ..\..\CONFIG\BOARD.H: "Please remember to disable the debug function!" 
  16          #include "misc.h"
  17          #include "global.h"
  18          #include "ms_reg.h"
  19          #include "ms_rwreg.h"
  20          #include "msflash.h"
  21          #include "misc.h"
  22          #include "Mcu.h"
  23          #include "GPIO_DEF.h"
  24          #if ENABLE_DEBUG
  25          #include "debug.h"
  26          #endif
  27          
  28          #define _FLASH_CODE_VERSION_    0x100
  29          
  30          #define FLASH_DEBUG    0
  31          #if FLASH_DEBUG && ENABLE_DEBUG
                  #define FLASH_printData(str, value)   printData(str, value)
                  #define FLASH_printMsg(str)           printMsg(str)
              #else
  35              #define FLASH_printData(str, value)
  36              #define FLASH_printMsg(str)
  37          #endif
  38          
  39          //#define CacheStatus()   (_bit3_(MEM_MSREAD_BYTE(REG_1018)))
  40          //#define EnableCache()  (MEM_MSWRITE_BIT(REG_1018, BIT3, BIT3), MEM_MSWRITE_BIT(REG_2BA0, 0, BIT0))
  41          //#define DisableCache()  (MEM_MSWRITE_BIT(REG_2BA0, BIT0, BIT0), MEM_MSWRITE_BIT(REG_1018, 0, BIT3))
  42          
  43          Bool xdata bFlashWriteFactory = FALSE;
  44          Bool xdata bFlashEraseBufferFinish = FALSE; // // jeff add it in 2009 0907
  45          BYTE xdata g_ucFlashDeviceID = 0;
  46          BYTE xdata g_FlashSize = FLASH_SIZE_2M;
  47          ///////////////////////////////////////////////////////////////////////////////
  48          // <DRV><Description>: Check current MsFlash.c code version
  49          // <Returns> : MsFlash.c version number
  50          ///////////////////////////////////////////////////////////////////////////////
  51          WORD FlashVersionCheck( void )
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 2   

  52          {
  53   1          BYTE ucTemp = 0;
  54   1          if( ucTemp )
  55   1          {
  56   2              Flash_GetBufferAddr();
  57   2              Flash_AllocateBufferAddr();
  58   2              Flash_CheckBufferType();
  59   2              Flash_ClearModeSet();
  60   2              Flash_WriteFactorySet( &ucTemp, 0 );
  61   2              Flash_ReadFactorySet( &ucTemp, 0 );
  62   2              Flash_WriteMonitorSet( &ucTemp, 0 );
  63   2              Flash_ReadMonitorSet( &ucTemp, 0 );
  64   2              Flash_WriteMonitorSet2( &ucTemp, 0 );
  65   2              Flash_ReadMonitorSet2( &ucTemp, 0 );
  66   2              Flash_WriteModeSet( 0, &ucTemp );
  67   2              Flash_ReadModeSet( 0, &ucTemp );
  68   2          }
  69   1          return _FLASH_CODE_VERSION_;
  70   1      }
  71          
  72          ///////////////////////////////////////////////////////////////////////////////
  73          // <DRV><Description>: Clear SPI Buffer.
  74          ///////////////////////////////////////////////////////////////////////////////
  75          #if 0
              void CleanSPI_SI_BUF( void )
              {
                  BYTE i = 0;
              
                  for( i = 0; i < 8; i ++ )
                      SPI_SI_BUF[i] = 0x00;
              }
              #endif
  84          
  85          void drvFlashWaitSPINotBusy(void)
  86          {
  87   1          BYTE u8Retry=100;
  88   1          while(!(SPI_STATUS&BIT0)&&u8Retry--)
  89   1              ForceDelay1ms(1);
  90   1          if (SPI_STATUS&BIT0)
  91   1              SPI_CLR_STATUS= 0x01; //clr int
  92   1          //printData("u8Retry=%d",u8Retry);
  93   1      }
  94          
  95          ///////////////////////////////////////////////////////////////////////////////
  96          // <DRV><Description>: Return true when flash type is PMC .
  97          ///////////////////////////////////////////////////////////////////////////////
  98          Bool FlashTypeIs_PMC( void )
  99          {
 100   1          BYTE ucID = 0;
 101   1      
 102   1          // 1st
 103   1          SPI_SI_BUF[0] = PMC_READ_ID;
 104   1          
 105   1          // 2nd
 106   1          SPI_SI_BUF[1] = RDSR;
 107   1      
 108   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 109   1          SPI_CTRL1       = (EN_2ND_CMD|EN_AUTO_CHECK|RDSR_IN_2ND);
 110   1          SET_WBF_SIZE(1, 1, 0);
 111   1          SET_RBF_SIZE(3, 1, 0);
 112   1      
 113   1          SPI_TRIGGER  = 0x01; //start flash programming
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 3   

 114   1          drvFlashWaitSPINotBusy();
 115   1          
 116   1          ucID = SPI_SO_BUF[1];
 117   1      
 118   1          if( ucID == FLASH_PMC )
 119   1          {
 120   2              if( SPI_SO_BUF[2] == PM25_LD020 )
 121   2                  g_ucFlashDeviceID = PM25_LD020;
 122   2              else if( SPI_SO_BUF[2] == PM25_LV020 )
 123   2                  g_ucFlashDeviceID = PM25_LV020;
 124   2              else if( SPI_SO_BUF[2] == PM25_LQ020 )
 125   2                  g_ucFlashDeviceID = PM25_LQ020;
 126   2              return TRUE;
 127   2          }
 128   1          return FALSE;
 129   1      }
 130          ///////////////////////////////////////////////////////////////////////////////
 131          // <DRV><Description>: Return true when flash type is SST.
 132          ///////////////////////////////////////////////////////////////////////////////
 133          Bool FlashTypeIs_SST( void )
 134          {
 135   1          BYTE ucID = 0;
 136   1      
 137   1          // 1st
 138   1          SPI_SI_BUF[0] = SST_READ_ID;
 139   1          
 140   1          // 2nd
 141   1          SPI_SI_BUF[1] = RDSR;
 142   1      
 143   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 144   1          SPI_CTRL1       = (EN_2ND_CMD|EN_AUTO_CHECK|RDSR_IN_2ND);
 145   1          SET_WBF_SIZE(1, 1, 0);
 146   1          SET_RBF_SIZE(3, 1, 0);
 147   1      
 148   1          SPI_TRIGGER  = 0x01; //start flash programming
 149   1          drvFlashWaitSPINotBusy();
 150   1          
 151   1          ucID = SPI_SO_BUF[0];
 152   1      
 153   1          if( ucID == FLASH_SST )
 154   1              return TRUE;
 155   1          return FALSE;
 156   1      }
 157          ///////////////////////////////////////////////////////////////////////////////
 158          // <DRV><Description>: Return true when flash type is MXIC.
 159          ///////////////////////////////////////////////////////////////////////////////
 160          Bool FlashTypeIs_MXIC( void )
 161          {
 162   1          BYTE ucID = 0;
 163   1      
 164   1          // 1st
 165   1          SPI_SI_BUF[0] = MXIC_READ_ID;
 166   1          
 167   1          // 2nd
 168   1          SPI_SI_BUF[1] = RDSR;
 169   1      
 170   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 171   1          SPI_CTRL1       = (EN_2ND_CMD|EN_AUTO_CHECK|RDSR_IN_2ND);
 172   1          SET_WBF_SIZE(1, 1, 0);
 173   1          SET_RBF_SIZE(3, 1, 0);
 174   1      
 175   1          SPI_TRIGGER  = 0x01; //start flash programming
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 4   

 176   1          drvFlashWaitSPINotBusy();
 177   1          
 178   1          ucID = SPI_SO_BUF[0];
 179   1      
 180   1          if( ucID == FLASH_MXIC )
 181   1              return TRUE;
 182   1          return FALSE;
 183   1      }
 184          ///////////////////////////////////////////////////////////////////////////////
 185          // <DRV><Description>: Return true when flash type is EON.
 186          ///////////////////////////////////////////////////////////////////////////////
 187          Bool FlashTypeIs_EON( void )
 188          {
 189   1          BYTE ucID = 0;
 190   1      
 191   1          // 1st
 192   1          SPI_SI_BUF[0] = EON_READ_ID;
 193   1          
 194   1          // 2nd
 195   1          SPI_SI_BUF[1] = RDSR;
 196   1      
 197   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 198   1          SPI_CTRL1       = (EN_2ND_CMD|EN_AUTO_CHECK|RDSR_IN_2ND);
 199   1          SET_WBF_SIZE(1, 1, 0);
 200   1          SET_RBF_SIZE(3, 1, 0);
 201   1      
 202   1          SPI_TRIGGER  = 0x01; //start flash programming
 203   1          drvFlashWaitSPINotBusy();
 204   1          
 205   1          ucID = SPI_SO_BUF[0];
 206   1      
 207   1          if( ucID == FLASH_EON )
 208   1              return TRUE;
 209   1          return FALSE;
 210   1      }
 211          ///////////////////////////////////////////////////////////////////////////////
 212          // <DRV><Description>: Return true when flash type is AMIC.
 213          ///////////////////////////////////////////////////////////////////////////////
 214          Bool FlashTypeIs_AMIC( void )
 215          {
 216   1          BYTE ucID = 0;
 217   1      
 218   1          // 1st
 219   1          SPI_SI_BUF[0] = AMIC_READ_ID;
 220   1          
 221   1          // 2nd
 222   1          SPI_SI_BUF[1] = RDSR;
 223   1      
 224   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 225   1          SPI_CTRL1       = (EN_2ND_CMD|EN_AUTO_CHECK|RDSR_IN_2ND);
 226   1          SET_WBF_SIZE(1, 1, 0);
 227   1          SET_RBF_SIZE(3, 1, 0);
 228   1      
 229   1          SPI_TRIGGER  = 0x01; //start flash programming
 230   1          drvFlashWaitSPINotBusy();
 231   1          
 232   1          ucID = SPI_SO_BUF[0];
 233   1      
 234   1          if( ucID == FLASH_AMIC )
 235   1              return TRUE;
 236   1          return FALSE;
 237   1      }
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 5   

 238          ///////////////////////////////////////////////////////////////////////////////
 239          // <DRV><Description>: Return true when flash type is WINBOND.
 240          ///////////////////////////////////////////////////////////////////////////////
 241          Bool FlashTypeIs_WINBOND( void )
 242          {
 243   1          BYTE ucID = 0;
 244   1      
 245   1          // 1st
 246   1          SPI_SI_BUF[0] = WINBOND_READ_ID;
 247   1          
 248   1          // 2nd
 249   1          SPI_SI_BUF[1] = RDSR;
 250   1      
 251   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 252   1          SPI_CTRL1       = (EN_2ND_CMD|EN_AUTO_CHECK|RDSR_IN_2ND);
 253   1          SET_WBF_SIZE(1, 1, 0);
 254   1          SET_RBF_SIZE(3, 1, 0);
 255   1      
 256   1          SPI_TRIGGER  = 0x01; //start flash programming
 257   1          drvFlashWaitSPINotBusy();
 258   1          
 259   1          ucID = SPI_SO_BUF[0];
 260   1          
 261   1          //FLASH_printData("W9F-2:%x",SPI_SO_BUF[2]);
 262   1      
 263   1          if( ucID == FLASH_WINBOND )
 264   1          {
 265   2              ucID = SPI_SO_BUF[2];
 266   2              if(ucID == W25X05CL)
 267   2                  g_ucFlashDeviceID = W25X05CL;
 268   2              else if(ucID == W25X10CL)
 269   2                  g_ucFlashDeviceID = W25X10CL;
 270   2              else if(ucID == W25X20CL)
 271   2                  g_ucFlashDeviceID = W25X20CL;
 272   2              else if(ucID == W25X40BV)
 273   2                  g_ucFlashDeviceID = W25X40BV;
 274   2                  
 275   2              return TRUE;
 276   2          }
 277   1          return FALSE;
 278   1      }
 279          
 280          BYTE ReadFlashUniqueID_Winbond(void)
 281          {
 282   1          // 1st
 283   1          SPI_SI_BUF[0] = WINBOND_READ_UNIQUE_ID; // with 4 dummy bytes
 284   1          
 285   1          // 2nd
 286   1          SPI_SI_BUF[5] = RDSR;
 287   1      
 288   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 289   1          SPI_CTRL1       = (EN_2ND_CMD|EN_AUTO_CHECK|RDSR_IN_2ND);
 290   1          SET_WBF_SIZE(5, 1, 0);
 291   1          SET_RBF_SIZE(1, 1, 0);
 292   1      
 293   1          SPI_TRIGGER  = 0x01; //start flash programming
 294   1          drvFlashWaitSPINotBusy();
 295   1      
 296   1          return SPI_SO_BUF[0];
 297   1      }
 298          
 299          BYTE ReadFlashDeviceID_MXIC( void )
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 6   

 300          {
 301   1          // 1st
 302   1          SPI_SI_BUF[0] = MXIC_RES;
 303   1          SPI_SI_BUF[1] = 0x00;
 304   1          SPI_SI_BUF[2] = 0x00;
 305   1          SPI_SI_BUF[3] = 0x00;
 306   1          // 2nd
 307   1          SPI_SI_BUF[4] = RDSR;
 308   1      
 309   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 310   1          SPI_CTRL1       = (EN_2ND_CMD|EN_AUTO_CHECK|RDSR_IN_2ND);
 311   1          SET_WBF_SIZE(4, 1, 0);
 312   1          SET_RBF_SIZE(1, 1, 0);
 313   1          SPI_TRIGGER  = 0x01; //start flash programming
 314   1          drvFlashWaitSPINotBusy();
 315   1          
 316   1          return SPI_SO_BUF[0];
 317   1      }
 318          
 319          ///////////////////////////////////////////////////////////////////////////////
 320          // <DRV><Description>: Return true when flash type is GIGA DEVICE .
 321          ///////////////////////////////////////////////////////////////////////////////
 322          Bool FlashTypeIs_GigaDevice( void )
 323          {
 324   1          BYTE ucID = 0;
 325   1      
 326   1          // 1st
 327   1          SPI_SI_BUF[0] = GIGADEVICE_READ_ID;
 328   1          
 329   1          // 2nd
 330   1          SPI_SI_BUF[1] = RDSR;
 331   1      
 332   1          SPI_CTRL0       = SPI_CTRL_VALUE;
 333   1          SPI_CTRL1       = (EN_2ND_CMD|EN_AUTO_CHECK|RDSR_IN_2ND);
 334   1          SET_WBF_SIZE(1, 1, 0);
 335   1          SET_RBF_SIZE(3, 1, 0);
 336   1      
 337   1          SPI_TRIGGER  = 0x01;
 338   1          drvFlashWaitSPINotBusy();
 339   1          
 340   1          ucID = SPI_SO_BUF[0];
 341   1          
 342   1          if( ucID == FLASH_GIGADEVICE )
 343   1          {
 344   2              if( SPI_SO_BUF[2] == GD25M21B )
 345   2                  g_ucFlashDeviceID = GD25M21B;
 346   2              else if( SPI_SO_BUF[2] == GD25M41B )
 347   2                  g_ucFlashDeviceID = GD25M41B;
 348   2             
 349   2              return TRUE;
 350   2          }
 351   1          return FALSE;
 352   1      }
 353          
 354          #if Enable_FMFlash_Save
              ///////////////////////////////////////////////////////////////////////////////
              // <DRV><Description>: Return true when flash type is FMSH.
              ///////////////////////////////////////////////////////////////////////////////
              Bool FlashTypeIs_FMSH(void)
              {
                  BYTE ucID = 0;
              
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 7   

                  // 1st
                  SPI_SI_BUF[0] = FMSH_READ_ID;
                  
                  // 2nd
                  SPI_SI_BUF[1] = RDSR;
              
                  SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
                  SPI_CTRL1       = (EN_2ND_CMD|EN_AUTO_CHECK|RDSR_IN_2ND);
                  SET_WBF_SIZE(1, 1, 0);
                  SET_RBF_SIZE(3, 1, 0);
              
                  SPI_TRIGGER  = 0x01; //start flash programming
                  drvFlashWaitSPINotBusy();
                  
                  ucID = SPI_SO_BUF[0];
              
                  if( ucID == FLASH_FMSH)
                  {
                     if( SPI_SO_BUF[2] == FM25Q04)
                          g_ucFlashDeviceID = FM25Q04;
                      else if( SPI_SO_BUF[2] == FM25Q02)
                          g_ucFlashDeviceID = FM25Q02;
              
                      return TRUE;
                  }
              
                  return FALSE;
              }
              #endif
 391          
 392          #define FLASH_IS_MXIC(id)     (id == FLASH_MXIC)
 393          #define FLASH_IS_WINBOND(id)    (id == FLASH_WINBOND)
 394          #define FLASH_IS_GIGADEVICE(id)     (id == FLASH_GIGADEVICE)
 395          #if Enable_FMFlash_Save
              #define FLASH_IS_FMSH(id)     (id == FLASH_FMSH)
              #endif
 398          
 399          #define MXIC_FLASH_4M()   (g_ucFlashDeviceID == MX_4026 || g_ucFlashDeviceID == MX_4025)
 400          #define WINBOND_FLASH_4M()  (g_ucFlashDeviceID == W25X40BV || g_ucFlashDeviceID == W25X41CL)
 401          #define GIGADEVICE_FLASH_4M()   (g_ucFlashDeviceID == GD25M41B)
 402          void CheckFlashSize(FlashID)
 403          {
 404   1          if(FLASH_IS_MXIC(FlashID) && MXIC_FLASH_4M())
 405   1              g_FlashSize = FLASH_SIZE_4M;
 406   1          else if(FLASH_IS_WINBOND(FlashID) && WINBOND_FLASH_4M())
 407   1              g_FlashSize = FLASH_SIZE_4M;
 408   1          else if(FLASH_IS_GIGADEVICE(FlashID) && GIGADEVICE_FLASH_4M())
 409   1              g_FlashSize = FLASH_SIZE_4M;
 410   1          else
 411   1              g_FlashSize = FLASH_SIZE_2M;
 412   1              #if 0//need Modify
                              g_FlashSize = FLASH_SIZE_4M;
                      #endif
 415   1      }
 416          
 417          ///////////////////////////////////////////////////////////////////////////////
 418          // <DRV><Description>: Read flash Manufacturer ID include PMC, MXIC, EON, and SST.
 419          //                Return FLASH_UNKNOW if not found
 420          // <Returns> : Manufacturer ID.
 421          ///////////////////////////////////////////////////////////////////////////////
 422          BYTE ReadFlashID( void )
 423          {
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 8   

 424   1          BYTE ucID;
 425   1      
 426   1          FlashVersionCheck();
 427   1      
 428   1          if( FlashTypeIs_PMC() )
 429   1              ucID = FLASH_PMC;
 430   1          else if( FlashTypeIs_MXIC() )
 431   1          {
 432   2              ucID = ReadFlashDeviceID_MXIC();
 433   2               if( ucID == MX_2026 /*||( ucID == 0x12 )*/)//20130521 for I2460 new 4m flash
 434   2                  g_ucFlashDeviceID = MX_2026;
 435   2                       else if( ucID == MX_4026 )
 436   2                               g_ucFlashDeviceID = MX_4026;
 437   2                       else if( ucID == MX_4025 )
 438   2                               g_ucFlashDeviceID = MX_4025;
 439   2              else
 440   2                  g_ucFlashDeviceID = MX_2025;
 441   2              ucID = FLASH_MXIC;
 442   2              FLASH_printData( "   g_ucFlashDeviceID[%x]", g_ucFlashDeviceID );
 443   2          }
 444   1          else if( FlashTypeIs_EON() )
 445   1              ucID = FLASH_EON;
 446   1          else if( FlashTypeIs_SST() )
 447   1              ucID = FLASH_SST;
 448   1          else if( FlashTypeIs_AMIC() )
 449   1              ucID = FLASH_AMIC;
 450   1          else if( FlashTypeIs_WINBOND() )
 451   1          {
 452   2              ucID = FLASH_WINBOND;
 453   2              if(g_ucFlashDeviceID == W25X20CL)
 454   2              {
 455   3                  if(W25X21CL == ReadFlashUniqueID_Winbond())
 456   3                      g_ucFlashDeviceID = W25X21CL;
 457   3              }
 458   2              else if(g_ucFlashDeviceID == W25X40BV)
 459   2              {
 460   3                  if(W25X41CL == ReadFlashUniqueID_Winbond())
 461   3                      g_ucFlashDeviceID = W25X41CL;
 462   3              }
 463   2              FLASH_printData( "   WinbondUniqueID[%x]", g_ucFlashDeviceID );
 464   2          }
 465   1          else if(FlashTypeIs_GigaDevice())
 466   1              ucID = FLASH_GIGADEVICE;
 467   1      #if     Enable_FMFlash_Save
                  else if(FlashTypeIs_FMSH())
                      ucID = FLASH_FMSH;
              #endif  
 471   1          else
 472   1              ucID = FLASH_UNKNOW;
 473   1      
 474   1          CheckFlashSize(ucID);
 475   1      
 476   1          return ucID;
 477   1      }
 478          
 479          #if 1//USEFLASH //------------------------------------------------------------------------------
 480          ///////////////////////////////////////////////////////////////////////////////
 481          // <DRV><Description>: Read flash status register.
 482          //
 483          // <Returns> : Flash status register.
 484          ///////////////////////////////////////////////////////////////////////////////
 485          BYTE FlashReadSR( void )
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 9   

 486          {
 487   1          SPI_SI_BUF[0]   = RDSR;
 488   1      
 489   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 490   1          SPI_CTRL1       = (RDSR_IN_1ST|EN_AUTO_CHECK);
 491   1          SET_WBF_SIZE(1, 0, 0);
 492   1          SET_RBF_SIZE(1, 0, 0);
 493   1          SPI_TRIGGER     = 0x01; //start flash programming
 494   1          drvFlashWaitSPINotBusy();
 495   1      
 496   1          return SPI_SO_BUF[0];
 497   1      }
 498          ///////////////////////////////////////////////////////////////////////////////
 499          // <DRV><Description>: Flash Write enable
 500          //Prior to any Byte-Program, AAI-Program, Sector-Erase, Block-Erase, or Chip-Erase operation, the Write-En
             -able (WREN)
 501          //instruction must be executed.
 502          //Wait WIP(SR[0]) clear then send WREN command
 503          ///////////////////////////////////////////////////////////////////////////////
 504          //void FlashWriteEnable( void )
 505          //{}
 506          
 507          ///////////////////////////////////////////////////////////////////////////////
 508          // <DRV><Description>: Write value to flash status register
 509          // <Parameter>:  -  <Flow>  -  <Description>
 510          //-----------------------------------------------------------------------------
 511          //  value  -    In    -   which value write to flash status register
 512          ///////////////////////////////////////////////////////////////////////////////
 513          void FlashWriteSR( BYTE value )
 514          {
 515   1          if( g_ucFlashID == FLASH_SST )
 516   1          {
 517   2              // 1st
 518   2              SPI_SI_BUF[0]   = EWSR;
 519   2              // 2nd
 520   2              SPI_SI_BUF[1]   = WRSR;
 521   2              SPI_SI_BUF[2]   = value;
 522   2              // 3rd
 523   2              SPI_SI_BUF[3]   = RDSR;
 524   2      
 525   2              SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 526   2              SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
 527   2              SET_WBF_SIZE(1, 2, 1);
 528   2              SET_RBF_SIZE(0, 0, 1);
 529   2          }
 530   1      
 531   1          else if( g_ucFlashID == FLASH_AMIC )
 532   1          {
 533   2              BYTE SSR = FlashReadSR();
 534   2              if( SSR & 0x40 ) //_BIT6)
 535   2              {
 536   3                  // 1st
 537   3                  SPI_SI_BUF[0]   = WREN;
 538   3                  // 2nd
 539   3                  SPI_SI_BUF[1] = 0x90;
 540   3                  SPI_SI_BUF[2] = 0x00;
 541   3                  SPI_SI_BUF[3] = 0x28;
 542   3                  SPI_SI_BUF[4] = 0x00;
 543   3                  SPI_SI_BUF[5] = 0x3B;
 544   3                  SPI_SI_BUF[6] = 0x00;
 545   3                  SPI_SI_BUF[7] = 0x28;
 546   3                  SPI_SI_BUF[8] = 0xFF;
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 10  

 547   3                  // 3rd
 548   3                  SPI_SI_BUF[9]   = RDSR;
 549   3      
 550   3                  SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 551   3                  SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
 552   3                  SET_WBF_SIZE(1, 8, 1);
 553   3                  SET_RBF_SIZE(0, 0, 1);
 554   3                  
 555   3                  SPI_TRIGGER     = 0x01; //start flash programming
 556   3                  drvFlashWaitSPINotBusy();
 557   3                  
 558   3                  // 1st
 559   3                  SPI_SI_BUF[0]   = WRSR;
 560   3                  SPI_SI_BUF[1]   = value;
 561   3                  // 2nd
 562   3                  SPI_SI_BUF[2]   = RDSR;
 563   3                  
 564   3                  SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 565   3                  SPI_CTRL1       = (EN_2ND_CMD|RDSR_IN_2ND|EN_AUTO_CHECK);
 566   3                  SET_WBF_SIZE(2, 1, 0);
 567   3                  SET_RBF_SIZE(0, 1, 0);
 568   3              }
 569   2              else
 570   2              {
 571   3                  // 1st
 572   3                  SPI_SI_BUF[0]   = WREN;
 573   3                  // 2nd
 574   3                  SPI_SI_BUF[1]   = WRSR;
 575   3                  SPI_SI_BUF[2]   = value;
 576   3                  // 3rd
 577   3                  SPI_SI_BUF[3]   = RDSR;
 578   3      
 579   3                  SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 580   3                  SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
 581   3                  SET_WBF_SIZE(1, 2, 1);
 582   3                  SET_RBF_SIZE(0, 0, 1);
 583   3              }
 584   2          }
 585   1              #if !Enable_GDFlash_Save
                  else if( g_ucFlashID == FLASH_GIGADEVICE && (g_ucFlashDeviceID == GD25M21B || g_ucFlashDeviceID == GD2
             -5M41B))
                  {
                      BYTE SR15_8;
              
                      SPI_SI_BUF[0]   = RDSR;
              
                      SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
                      SPI_CTRL1       = (RDSR_IN_1ST|EN_AUTO_CHECK);
                      SET_WBF_SIZE(1, 0, 0);
                      SET_RBF_SIZE(2, 0, 0);
                      SPI_TRIGGER     = 0x01; //start flash programming
                      drvFlashWaitSPINotBusy();
              
                      // recover status register S15~S8
                      SR15_8 = SPI_SO_BUF[1];
              
                      // 1st
                      SPI_SI_BUF[0]   = WREN;
                      // 2nd
                      SPI_SI_BUF[1]   = WRSR;
                      SPI_SI_BUF[2]   = value;
                      SPI_SI_BUF[3]   = SR15_8;
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 11  

                      // 3rd
                      SPI_SI_BUF[4]   = RDSR;
              
                      SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
                      SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
                      SET_WBF_SIZE(1, 3, 1);
                      SET_RBF_SIZE(0, 0, 1);
                  }
                      #endif
 617   1          else
 618   1          {
 619   2              // 1st
 620   2              SPI_SI_BUF[0]   = WREN;
 621   2              // 2nd
 622   2              SPI_SI_BUF[1]   = WRSR;
 623   2              SPI_SI_BUF[2]   = value;
 624   2              // 3rd
 625   2              SPI_SI_BUF[3]   = RDSR;
 626   2      
 627   2              SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 628   2              SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
 629   2              SET_WBF_SIZE(1, 2, 1);
 630   2              SET_RBF_SIZE(0, 0, 1);
 631   2          }
 632   1          
 633   1          SPI_TRIGGER     = 0x01; //start flash programming
 634   1          drvFlashWaitSPINotBusy();
 635   1          
 636   1      }
 637          ///////////////////////////////////////////////////////////////////////////////
 638          // <DRV><Description>: Only used in PMC type flash. To disable protect of specific sector.
 639          //                     if wAddr < FDATA_FACTORY_ADDR will not unprotect
 640          // <Parameter>:  <Description>
 641          //  wAddr : Which sector address will be unportect
 642          ///////////////////////////////////////////////////////////////////////////////
 643          void FlashPMCUnprotectEnable( WORD wAddr )
 644          {
 645   1          if( wAddr < FDATA_START_ADDR )
 646   1              return;
 647   1      
 648   1          if( g_ucFlashDeviceID == PM25_LD020 || g_ucFlashDeviceID == PM25_LQ020)
 649   1          {
 650   2              // 1st
 651   2              SPI_SI_BUF[0]   = WREN;
 652   2              // 2nd
 653   2              SPI_SI_BUF[1]   = PMC_UNPROTECT;
 654   2              SPI_SI_BUF[2]   = TOTAL_BANK_NUM - 1;
 655   2              SPI_SI_BUF[3]   = ( wAddr >> 8 ) & 0x0f0;
 656   2              SPI_SI_BUF[4]   = 0x00;
 657   2              // 3rd
 658   2              SPI_SI_BUF[5]   = RDSR;
 659   2      
 660   2              SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 661   2              SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
 662   2              SET_WBF_SIZE(1, 4, 1);
 663   2              SET_RBF_SIZE(0, 0, 1);
 664   2      
 665   2              /*
 666   2              SPI_SI_BUF[0] = WREN;
 667   2              SPI_CTRL = 0xF8;
 668   2              SPI_SI_BUF[0] = PMC_UNPROTECT;
 669   2              SPI_SI_BUF[1] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 12  

 670   2              SPI_SI_BUF[2] = ( wAddr >> 8 ) & 0x0f0;
 671   2              SPI_SI_BUF[3] = 0x00; //wAddr&0x0ff;
 672   2              SPI_CTRL = 0xFB;
 673   2              */
 674   2          }
 675   1          else
 676   1          {
 677   2              hw_ClrFlashWP();
 678   2              Delay1ms( 1 );
 679   2          
 680   2              // 1st
 681   2              SPI_SI_BUF[0] = PMC_UNPROTECT;
 682   2              SPI_SI_BUF[1] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
 683   2              SPI_SI_BUF[2] = ( wAddr >> 8 ) & 0x0ff;
 684   2              SPI_SI_BUF[3] = wAddr & 0x0ff;
 685   2              // 2nd
 686   2              SPI_SI_BUF[4]   = RDSR;
 687   2      
 688   2              SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 689   2              SPI_CTRL1       = (EN_2ND_CMD|RDSR_IN_2ND|EN_AUTO_CHECK);
 690   2              SET_WBF_SIZE(4, 1, 0);
 691   2              SET_RBF_SIZE(0, 1, 0);
 692   2      
 693   2              /*
 694   2              SPI_SI_BUF[0] = PMC_UNPROTECT;
 695   2              SPI_SI_BUF[1] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
 696   2              SPI_SI_BUF[2] = ( wAddr >> 8 ) & 0x0ff;
 697   2              SPI_SI_BUF[3] = wAddr & 0x0ff;
 698   2              SPI_CTRL = 0xBB;
 699   2              */
 700   2          }
 701   1          
 702   1          SPI_TRIGGER     = 0x01; //start flash programming
 703   1          drvFlashWaitSPINotBusy();
 704   1          
 705   1      }
 706          ///////////////////////////////////////////////////////////////////////////////
 707          // <DRV><Description>: Only used in PMC type flash. To disable un-protect of specific sector.
 708          ///////////////////////////////////////////////////////////////////////////////
 709          void FlashPMCUnprotectDisable( void )
 710          {
 711   1          // 1st
 712   1          SPI_SI_BUF[0] = PMC_PROTECT;
 713   1          // 2nd
 714   1          SPI_SI_BUF[1] = RDSR;
 715   1          
 716   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
 717   1          SPI_CTRL1       = (EN_2ND_CMD|RDSR_IN_2ND|EN_AUTO_CHECK);
 718   1          SET_WBF_SIZE(1, 1, 0);
 719   1          SET_RBF_SIZE(0, 1, 0);
 720   1          SPI_TRIGGER     = 0x01; //start flash programming
 721   1          drvFlashWaitSPINotBusy();
 722   1          /*
 723   1          SPI_SI_BUF[0] = PMC_PROTECT;
 724   1          SPI_CTRL = 0xF8;
 725   1          */
 726   1      }
 727          
 728          
 729          void FlashDisableStausProtect_MXIC2026( void )
 730          {
 731   1          if( g_ucFlashID == FLASH_MXIC && (g_ucFlashDeviceID == MX_2026 || g_ucFlashDeviceID == MX_4026) )
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 13  

 732   1          {
 733   2              hw_ClrFlashWP();
 734   2              Delay1ms( 1 );
 735   2              
 736   2              FlashWriteSR( 0x7F );
 737   2              if( bFlashWriteFactory )
 738   2                  FlashWriteSR( UNPROTECT_MXIC2026_3A_3F );   //130710 for new request
 739   2              else
 740   2                  FlashWriteSR( FLASH_MXIC2026_USER_AREA );   //130710 for new request
 741   2          }
 742   1      }
 743          //130710 for new request
 744          #define FlashEnableWP_PMC     FlashPMCUnprotectDisable
 745          
 746          void FlashEnableWP_EON(BYTE SRValue)
 747          {
 748   1          if(( SRValue & 0x94 ) != 0x94 )
 749   1          {
 750   2              //FLASH_printData("  EnableWP_EON_SR[%x] W_94",SSR);
 751   2              hw_ClrFlashWP();
 752   2              Delay1ms( 1 );
 753   2              FlashWriteSR( 0x94 );
 754   2          }
 755   1      }
 756          
 757          void FlashEnableWP_AMIC(BYTE SRValue)
 758          {
 759   1          if(( SRValue & 0xFC ) != 0xE8 )
 760   1          {
 761   2              //FLASH_printData("  EnableWP_AMIC_SR[%x] E8_0",SSR);
 762   2              hw_ClrFlashWP();
 763   2              Delay1ms( 1 );
 764   2              FlashWriteSR( 0xE8 );
 765   2              //FLASH_printData("  EnableWP_AMIC_SR[%x] E8_1",SSR);
 766   2          }
 767   1      }
 768          
 769          void FlashEnableWP_WINBOND(BYTE SRValue)
 770          {
 771   1          if(g_ucFlashDeviceID == W25X21CL || g_ucFlashDeviceID == W25X41CL)       
 772   1          {
 773   2              if((SRValue&FLASH_WINBOND_X21_X41_USER_AREA) != FLASH_WINBOND_X21_X41_USER_AREA)
 774   2              {
 775   3                  hw_ClrFlashWP();
 776   3                  Delay1ms( 1 );
 777   3                  FlashWriteSR( FLASH_WINBOND_X21_X41_USER_AREA );
 778   3              }
 779   2          }
 780   1          else if(g_ucFlashDeviceID == W25X40BV)
 781   1          {
 782   2              if((SRValue&0xAC) != 0xAC)
 783   2              {
 784   3                  hw_ClrFlashWP();
 785   3                  Delay1ms( 1 );
 786   3                  FlashWriteSR( 0xAC ); // protect lower 256K(0~0x3FFFF)
 787   3              }
 788   2          }
 789   1          else if(g_ucFlashDeviceID == W25X20BV)   
 790   1          {
 791   2              if((SRValue&0xA8) != 0xA8)      
 792   2              {
 793   3                  hw_ClrFlashWP();
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 14  

 794   3                  Delay1ms( 1 );
 795   3                  FlashWriteSR( 0xA8 ); // protect lower 128K(0~0x1FFFF)
 796   3              }
 797   2          }
 798   1          else if(g_ucFlashDeviceID == W25X10BV)   
 799   1          {
 800   2              if((SRValue&0xA4) != 0xA4)
 801   2              {
 802   3                  hw_ClrFlashWP();
 803   3                  Delay1ms( 1 );
 804   3                  FlashWriteSR( 0xA4 ); // protect lower 64K(0~0x0FFFF)
 805   3              }
 806   2          }
 807   1          else
 808   1          {
 809   2              if((SRValue&0x8C) != 0x8C)
 810   2              {
 811   3                  hw_ClrFlashWP();
 812   3                  Delay1ms( 1 );
 813   3                  FlashWriteSR( 0x8C ); // protect all
 814   3              }
 815   2          }
 816   1      }
 817          
 818          #define FLASH_SR_PROTECT_WHOLE_AREA     ((g_FlashSize == FLASH_SIZE_2M)?(0x8C):(0x9C))
 819          void FlashEnableWP_OTHERS(BYTE SRValue)
 820          {
 821   1          if(( SRValue & FLASH_SR_PROTECT_WHOLE_AREA ) != FLASH_SR_PROTECT_WHOLE_AREA )
 822   1          {
 823   2              //FLASH_printData("  EnableWP__SR[%x] W_8C",SSR);
 824   2              hw_ClrFlashWP();
 825   2              Delay1ms( 1 );
 826   2              FlashWriteSR( FLASH_SR_PROTECT_WHOLE_AREA );
 827   2          }
 828   1      }
 829          
 830          #if !Enable_GDFlash_Save
              void FlashEnableWP_GigaDevice_GD25M21B_GD25M41B(BYTE SRValue)
              {
                  // all block set to protect
                  if((SRValue&0xFC) != 0xFC)
                  {
                      hw_ClrFlashWP();
                      Delay1ms( 1 );
                      FlashWriteSR( 0xFC );
                  }
              
                  // setor lock
                  // 1st
                  SPI_SI_BUF[0] = GIGADEVICE_PROTECT;
                  // 2nd
                  SPI_SI_BUF[1] = RDSR;
                  
                  SPI_CTRL0       = SPI_CTRL_VALUE;
                  SPI_CTRL1       = (EN_2ND_CMD|RDSR_IN_2ND|EN_AUTO_CHECK);
                  SET_WBF_SIZE(1, 1, 0);
                  SET_RBF_SIZE(0, 1, 0);
                  SPI_TRIGGER     = 0x01; //start flash programming
                  drvFlashWaitSPINotBusy();
              }
              #endif
 855          
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 15  

 856          #define FlashDisableWP_PMC                      FlashPMCUnprotectEnable
 857          #define FlashDisableWP_MXIC_MX2026      FlashDisableStausProtect_MXIC2026
 858          void FlashDisableWP_EON(BYTE SRValue)
 859          {
 860   1          hw_ClrFlashWP();
 861   1          Delay1ms( 1 );
 862   1          if( bFlashWriteFactory )
 863   1          {
 864   2              //FLASH_printData("  _EON_SR[%x] W_00",SSR);
 865   2              FlashWriteSR( 0x00 );
 866   2          }
 867   1          else
 868   1          {
 869   2              if(( SRValue & 0x94 ) != 0x94 )
 870   2              {
 871   3                  //FLASH_printData("  _EON_SR[%x] W_94",SSR);
 872   3                  FlashWriteSR( 0x94 );
 873   3              }
 874   2          }
 875   1      }
 876          void FlashDisableWP_WINBOND_W25X21CL(void)
 877          {
 878   1          // X21CL: // 0xC0: protect range 0~0x39FFF; 0xE0: 0~0x3BFFF
 879   1          // X41CL: // 0xC0: protect range 0~0x79FFF; 0xE0: 0~0x7BFFF
 880   1      
 881   1          hw_ClrFlashWP();
 882   1          Delay1ms( 1 );
 883   1          if( bFlashWriteFactory )
 884   1          {
 885   2              FlashWriteSR( UNPROTECT_WINBOND_X21_3A_3F );
 886   2          }
 887   1          else
 888   1          {
 889   2              FlashWriteSR( FLASH_WINBOND_X21_X41_USER_AREA );
 890   2          }
 891   1      }
 892          
 893          void FlashDisableWP_OTHERS(BYTE SRValue)
 894          {
 895   1          hw_ClrFlashWP();
 896   1          Delay1ms( 1 );
 897   1          if( SRValue != 0x00 )
 898   1          {
 899   2              FlashWriteSR( 0x00 );
 900   2          }
 901   1      }
 902          
 903          
 904          #if !Enable_GDFlash_Save
              // use sector unlock to disable write protection
              void FlashDisableWP_GigaDevice_GD25M21B_GD25M41B(WORD wAddr)
              {
                  // 1st
                  SPI_SI_BUF[0]   = WREN;
                  // 2nd
                  SPI_SI_BUF[1]   = GIGADEVICE_UNPROTECT;
                  SPI_SI_BUF[2]   = TOTAL_BANK_NUM - 1;
                  SPI_SI_BUF[3]   = ( wAddr >> 8 ) & 0x0f0;
                  SPI_SI_BUF[4]   = 0x00;
                  // 3rd
                  SPI_SI_BUF[5]   = RDSR;
              
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 16  

                  SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
                  SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
                  SET_WBF_SIZE(1, 4, 1);
                  SET_RBF_SIZE(0, 0, 1);
              
                  SPI_TRIGGER     = 0x01; //start flash programming
                  drvFlashWaitSPINotBusy();
              }
              #endif
 927          
 928          ///////////////////////////////////////////////////////////////////////////////
 929          // <DRV><Description>: Enable flash write protect
 930          ///////////////////////////////////////////////////////////////////////////////
 931          void FlashEnableWP( void )      //130710 for new request
 932          {
 933   1          BYTE SSR;
 934   1      
 935   1          SSR = FlashReadSR();
 936   1      
 937   1          if( g_ucFlashID == FLASH_PMC )
 938   1              {
 939   2                      FlashEnableWP_PMC();//FlashPMCUnprotectDisable();
 940   2              }
 941   1          else if( g_ucFlashID == FLASH_EON )
 942   1              {
 943   2                      FlashEnableWP_EON(SSR);            
 944   2              }
 945   1          else if( g_ucFlashID == FLASH_AMIC )
 946   1              {
 947   2                      FlashEnableWP_AMIC(SSR);
 948   2              }
 949   1          else if( g_ucFlashID == FLASH_MXIC && (g_ucFlashDeviceID == MX_2026 || g_ucFlashDeviceID == MX_4026) )
 950   1          {
 951   2              //SRAM type auto protect when write finish
 952   2          }
 953   1          else if( g_ucFlashID == FLASH_WINBOND )
 954   1              {
 955   2                      FlashEnableWP_WINBOND(SSR);
 956   2              }
 957   1         #if !Enable_GDFlash_Save     
                  else if( g_ucFlashID == FLASH_GIGADEVICE && (g_ucFlashDeviceID == GD25M21B || g_ucFlashDeviceID == GD2
             -5M41B) )
                  {
                      FlashEnableWP_GigaDevice_GD25M21B_GD25M41B(SSR);
                  }
                 #endif       
 963   1          else
 964   1              {
 965   2                      FlashEnableWP_OTHERS(SSR);
 966   2              }
 967   1          //FlashWriteDisable();
 968   1          hw_SetFlashWP();
 969   1      
 970   1      }
 971          ///////////////////////////////////////////////////////////////////////////////
 972          // <DRV><Description>: Disable flash write protect
 973          ///////////////////////////////////////////////////////////////////////////////
 974          void FlashDisableWP( WORD wAddr )       //130710 for new request
 975          {
 976   1          BYTE SSR;
 977   1              
 978   1          if( wAddr < FDATA_START_ADDR )
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 17  

 979   1              return;
 980   1      
 981   1          SSR = FlashReadSR();
 982   1      
 983   1          if( g_ucFlashID == FLASH_PMC )
 984   1              {
 985   2                      FlashDisableWP_PMC(wAddr);//FlashPMCUnprotectEnable( wAddr );
 986   2              }
 987   1          else if( g_ucFlashID == FLASH_EON )
 988   1                      {
 989   2                              FlashDisableWP_EON(SSR);
 990   2                      }
 991   1          else if( g_ucFlashID == FLASH_AMIC )
 992   1          {
 993   2              ;
 994   2          }
 995   1          else if( g_ucFlashID == FLASH_MXIC && (g_ucFlashDeviceID == MX_2026 || g_ucFlashDeviceID == MX_4026) )
 996   1              {
 997   2                      FlashDisableWP_MXIC_MX2026();//FlashDisableStausProtect_MXIC2026();
 998   2              }
 999   1          else if( g_ucFlashID == FLASH_WINBOND && (g_ucFlashDeviceID == W25X21CL || g_ucFlashDeviceID == W25X41
             -CL)) // just 21CL needs to change SR
1000   1              {
1001   2                      FlashDisableWP_WINBOND_W25X21CL();
1002   2              }
1003   1         #if !Enable_GDFlash_Save     
                  else if( g_ucFlashID == FLASH_GIGADEVICE && (g_ucFlashDeviceID == GD25M21B || g_ucFlashDeviceID == GD2
             -5M41B) )
                  {
                      FlashDisableWP_GigaDevice_GD25M21B_GD25M41B(wAddr);
                  }
                 #endif       
1009   1          else
1010   1              {
1011   2                      FlashDisableWP_OTHERS(SSR);
1012   2              }
1013   1      
1014   1      }
1015          
1016          ///////////////////////////////////////////////////////////////////////////////
1017          // <DRV><Description>: Flash erase function
1018          // <Parameter>:  -  <Flow>  -  <Description>
1019          //-----------------------------------------------------------------------------
1020          //  bDoWP   -   In  -   Doing FlashDisableWP at start and FlashEnableWP at end
1021          //  wAddr   -   In  -   Erase 4K BYTE sector address
1022          ////////擦除相应的地区///////////////////////////////////////////////////////////////////////
1023          void FlashSectorErase( Bool bDoWP, WORD wAddr )
1024          {
1025   1          bit bcachestatus;
1026   1      
1027   1          if( wAddr < FDATA_START_ADDR )
1028   1              return;
1029   1      
1030   1          bcachestatus = CACHE_STATUS();//CacheStatus();
1031   1          
1032   1          if( bcachestatus )
1033   1              CACHE_DISABLE();//DisableCache();
1034   1      
1035   1          if( bDoWP )
1036   1              FlashDisableWP( wAddr );
1037   1      
1038   1          // 1st
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 18  

1039   1          SPI_SI_BUF[0]   = WREN;
1040   1          // 2nd
1041   1          if( g_ucFlashID == FLASH_SST )
1042   1              SPI_SI_BUF[1] = SST_ERASE_SECTOR;
1043   1          else if( g_ucFlashID == FLASH_PMC )
1044   1              SPI_SI_BUF[1] = PMC_ERASE_SECTOR;
1045   1          else if( g_ucFlashID == FLASH_MXIC )
1046   1              SPI_SI_BUF[1] = MXIC_ERASE_SECTOR;
1047   1          else if( g_ucFlashID == FLASH_EON )
1048   1              SPI_SI_BUF[1] = EON_ERASE_SECTOR;
1049   1          else if( g_ucFlashID == FLASH_AMIC )
1050   1              SPI_SI_BUF[1] = AMIC_ERASE_SECTOR;
1051   1          else if( g_ucFlashID == FLASH_WINBOND )
1052   1              SPI_SI_BUF[1] = WINBOND_ERASE_SECTOR;
1053   1          else
1054   1              SPI_SI_BUF[1] = SST_ERASE_SECTOR;
1055   1      
1056   1          SPI_SI_BUF[2] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
1057   1          SPI_SI_BUF[3] = ( wAddr >> 8 ) & 0x0ff;
1058   1          SPI_SI_BUF[4] = wAddr & 0x0ff;
1059   1          // 3rd
1060   1          SPI_SI_BUF[5]   = RDSR;
1061   1      
1062   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
1063   1          SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
1064   1          SET_WBF_SIZE(1, 4, 1);
1065   1          SET_RBF_SIZE(0, 0, 1);
1066   1          SPI_TRIGGER     = 0x01; //start flash programming
1067   1          drvFlashWaitSPINotBusy();
1068   1      
1069   1          /*
1070   1          FlashWriteEnable();
1071   1          if( g_ucFlashID == FLASH_SST )
1072   1              SPI_SI_BUF[0] = SST_ERASE_SECTOR;
1073   1          else if( g_ucFlashID == FLASH_PMC )
1074   1              SPI_SI_BUF[0] = PMC_ERASE_SECTOR;
1075   1          else if( g_ucFlashID == FLASH_MXIC )
1076   1              SPI_SI_BUF[0] = MXIC_ERASE_SECTOR;
1077   1          else if( g_ucFlashID == FLASH_EON )
1078   1              SPI_SI_BUF[0] = EON_ERASE_SECTOR;
1079   1          else if( g_ucFlashID == FLASH_AMIC )
1080   1              SPI_SI_BUF[0] = AMIC_ERASE_SECTOR;
1081   1          else
1082   1              SPI_SI_BUF[0] = SST_ERASE_SECTOR;
1083   1      
1084   1          SPI_SI_BUF[1] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
1085   1          SPI_SI_BUF[2] = ( wAddr >> 8 ) & 0x0ff;
1086   1          SPI_SI_BUF[3] = wAddr & 0x0ff;
1087   1      
1088   1          SPI_CTRL = 0xFB; //0xFC;
1089   1          */
1090   1      
1091   1          if( bDoWP )
1092   1              FlashEnableWP();
1093   1      
1094   1          if( bcachestatus )
1095   1              CACHE_ENABLE();//EnableCache();
1096   1      
1097   1      }
1098          
1099          ///////////////////////////////////////////////////////////////////////////////
1100          // <DRV><Description>: Write one byte to flash
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 19  

1101          // <Parameter>: -  <Flow>   -   <Description>
1102          //-----------------------------------------------------------------------------
1103          //  bDoWP   -   In  -   Doing FlashDisableWP at start and FlashEnableWP at end
1104          //  wAddr   -   In  -   Flash Address to be write, high byte address will be (TOTAL_BANK_NUM-1)
1105          //                      wAddr < FDATA_FACTORY_ADDR will be limit, so address < 0x3B000 will be limit
1106          //  value   -   In  -   The value write to flash
1107          ////把标志位写入地址///////////////////////////////////////////////////////////////////////////
1108          void FlashWriteByte( Bool bDoWP, WORD wAddr, BYTE value )
1109          {
1110   1          bit bcachestatus;
1111   1      
1112   1          if( wAddr < FDATA_START_ADDR )
1113   1              return;
1114   1      
1115   1          bcachestatus = CACHE_STATUS();//CacheStatus();
1116   1          
1117   1          if( bcachestatus )
1118   1              CACHE_DISABLE();//DisableCache();
1119   1      
1120   1          if( bDoWP )
1121   1              FlashDisableWP( wAddr );
1122   1          else
1123   1              FlashDisableStausProtect_MXIC2026();
1124   1      
1125   1          // 1st
1126   1          SPI_SI_BUF[0]   = WREN;
1127   1          // 2nd
1128   1          SPI_SI_BUF[1] = BYTE_WRITE;
1129   1          SPI_SI_BUF[2] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
1130   1          SPI_SI_BUF[3] = ( wAddr >> 8 ) & 0x0ff;
1131   1          SPI_SI_BUF[4] = wAddr & 0x0ff;
1132   1          SPI_SI_BUF[5] = value;
1133   1          // 3rd
1134   1          SPI_SI_BUF[6]   = RDSR;
1135   1      
1136   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
1137   1          SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
1138   1          SET_WBF_SIZE(1, 5, 1);
1139   1          SET_RBF_SIZE(0, 0, 1);
1140   1          SPI_TRIGGER     = 0x01; //start flash programming
1141   1          drvFlashWaitSPINotBusy();
1142   1          
1143   1          /*
1144   1          FlashWriteEnable();
1145   1          //CleanSPI_SI_BUF();
1146   1          //MCU_CACHE_CTL = 0x00;
1147   1          SPI_SI_BUF[0] = BYTE_WRITE;
1148   1          SPI_SI_BUF[1] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
1149   1          SPI_SI_BUF[2] = ( wAddr >> 8 ) & 0x0ff;
1150   1          SPI_SI_BUF[3] = wAddr & 0x0ff;
1151   1          SPI_SI_BUF[4] = value;
1152   1          SPI_CTRL = 0xFC;
1153   1          //MCU_CACHE_CTL = 0x20;
1154   1          //retry=10;
1155   1          //while((SPI_CTRL&BIT7)&&retry--)
1156   1          //  ForceDelay1ms(1);
1157   1          */
1158   1      
1159   1          if( bDoWP )
1160   1              FlashEnableWP();
1161   1          //FLASH_printData("value=%x\n",value);
1162   1          //FLASH_printData("S4=%x",SPI_SI_BUF[4]);
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 20  

1163   1      
1164   1          if( bcachestatus )
1165   1              CACHE_ENABLE();//EnableCache();
1166   1      }
1167          
1168          #if HDCPKEY_IN_Flash
1169          void FlashHDCPWriteByte( WORD wAddr, BYTE value )
1170          {
1171   1          bit bcachestatus;
1172   1      
1173   1          if( wAddr < FDATA_START_ADDR )
1174   1              return;
1175   1      
1176   1          bcachestatus = CACHE_STATUS();//CacheStatus();
1177   1          
1178   1          if( bcachestatus )
1179   1              CACHE_DISABLE();//DisableCache();
1180   1      
1181   1          FlashDisableStausProtect_MXIC2026();//For MXIC 2026
1182   1      
1183   1          // 1st
1184   1          SPI_SI_BUF[0]   = WREN;
1185   1          // 2nd
1186   1          SPI_SI_BUF[1] = BYTE_WRITE;
1187   1          SPI_SI_BUF[2] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
1188   1          SPI_SI_BUF[3] = ( wAddr >> 8 ) & 0x0ff;
1189   1          SPI_SI_BUF[4] = wAddr & 0x0ff;
1190   1          SPI_SI_BUF[5] = value;
1191   1          // 3rd
1192   1          SPI_SI_BUF[6]   = RDSR;
1193   1      
1194   1          SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
1195   1          SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
1196   1          SET_WBF_SIZE(1, 5, 1);
1197   1          SET_RBF_SIZE(0, 0, 1);
1198   1          SPI_TRIGGER     = 0x01; //start flash programming
1199   1          drvFlashWaitSPINotBusy();
1200   1          
1201   1          /*
1202   1          FlashWriteEnable();
1203   1          SPI_SI_BUF[0] = BYTE_WRITE;
1204   1          SPI_SI_BUF[1] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
1205   1          SPI_SI_BUF[2] = ( wAddr >> 8 ) & 0x0ff;
1206   1          SPI_SI_BUF[3] = wAddr & 0x0ff;
1207   1          SPI_SI_BUF[4] = value;
1208   1          SPI_CTRL = 0xFC;
1209   1          */
1210   1      
1211   1          if( bcachestatus )
1212   1              CACHE_ENABLE();//EnableCache();
1213   1      }
1214          #endif
1215          ///////////////////////////////////////////////////////////////////////////////
1216          // <DRV><Description>: Read one byte from flash.
1217          // <Returns> : Data value in the address
1218          // <Parameter>:  -  <Flow>  -  <Description>
1219          //-----------------------------------------------------------------------------
1220          //  wAddr   -   In  -   Only in the same bank ot MsFlash.c
1221          ///////////////////////////////////////////////////////////////////////////////
1222          //这段代码是一个简单的函数，用于从Flash中读取一个字节的数据。代码中定义了
             -一个指向Flash地址0x0000的指针：xfr_FlashCode。
1223          //FlashReadByte函数接受一个16位的地址参数wAddr，并返回该地址上Flash中存储的字节
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 21  

             -据。
1224          //s具体而言，函数通过将地址wAddr作为索引来访问xfr_FlashCode指针所指向的内存位
             -，并返回该位置上的数据。
1225          #define xfr_FlashCode ((BYTE code*)0x0000)
1226          BYTE FlashReadByte( WORD wAddr )
1227          {
1228   1          return xfr_FlashCode[wAddr];
1229   1      }
1230          
1231          #if  ENABLE_USE_ISPTOOL_Write_HDCP
              BYTE FlashReadHDCPByte(DWORD address)
              {
              
                  SPI_SI_BUF[0]   = (SPI_MODE == SPI_MODE_FR) ? H_READ:READ;
                  SPI_SI_BUF[1]   = (address>>16)&0xff;
                  SPI_SI_BUF[2]   = (address>>8)&0xff;
                  SPI_SI_BUF[3]   = address&0xff;
                  //2nd
                  SPI_SI_BUF[4]   = RDSR;
                  if(SPI_MODE == SPI_MODE_FR)
                      SPI_SI_BUF[5]   = RDSR;
                  SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
                  SPI_CTRL1       = (EN_2ND_CMD|RDSR_IN_2ND|EN_AUTO_CHECK);
                  SET_WBF_SIZE( (SPI_MODE == SPI_MODE_FR) ? 5:4, 1, 0);
                  SET_WBF_SIZE( 5, 1, 0);
                  SET_RBF_SIZE(1, 1, 0);
                  SPI_TRIGGER     = 0x01; //start flash programming
                  
                  drvFlashWaitSPINotBusy();
                  
                  return SPI_SO_BUF[0];
              }
              #endif
1255          
1256          //////////////////////////////////////////////////////////////////////////////
1257          // <DRV><Description>: Write a table to flash
1258          // <Parameter>:     -   <Flow>  -   <Description>
1259          // ---------------------------------------------------------------------------
1260          //  bDoWP   -   In  -   Doing FlashDisableWP at start and FlashEnableWP at end
1261          //  wAddr   -   In  -   Flash Address to be write, high byte address will be (TOTAL_BANK_NUM-1)
1262          //                      wAddr < FDATA_FACTORY_ADDR will be limit, so address < 0x3B000 will be limit
1263          //  buffer  -   In  -   Data pointer of the table
1264          //  count   -   In  -   Number of data
1265          //////////////////////////////////////////////////////////////////////////////
1266          //把一组数据写入相应的地址
1267          void Flash_WriteTbl( Bool bDoWP, WORD wAddr, BYTE *buffer, WORD count )
1268          {
1269   1          WORD i = 0;
1270   1          bit bcachestatus;
1271   1      
1272   1          if( wAddr < FDATA_START_ADDR )
1273   1              return;
1274   1      
1275   1          bcachestatus = CACHE_STATUS();//CacheStatus();
1276   1          
1277   1          if( bcachestatus )
1278   1              CACHE_DISABLE();//DisableCache();
1279   1      
1280   1          if( bDoWP )
1281   1              FlashDisableWP( wAddr ); // 2005/5/11 W 10:19:39 by keng
1282   1          //MCU_CACHE_CTL = 0x00;
1283   1          while( count > 0 )
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 22  

1284   1          {
1285   2              FlashDisableStausProtect_MXIC2026();
1286   2      
1287   2              // 1st
1288   2              SPI_SI_BUF[0]   = WREN;
1289   2              // 2nd
1290   2              SPI_SI_BUF[1] = BYTE_WRITE;
1291   2              SPI_SI_BUF[2] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
1292   2              SPI_SI_BUF[3] = ( wAddr >> 8 ) & 0x0ff;
1293   2              SPI_SI_BUF[4] = wAddr & 0x0ff;
1294   2              SPI_SI_BUF[5] = *( buffer + ( i++ ) );
1295   2              // 3rd
1296   2              SPI_SI_BUF[6]   = RDSR;
1297   2      
1298   2              SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
1299   2              SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
1300   2              SET_WBF_SIZE(1, 5, 1);
1301   2              SET_RBF_SIZE(0, 0, 1);
1302   2              SPI_TRIGGER     = 0x01; //start flash programming
1303   2              drvFlashWaitSPINotBusy();
1304   2              
1305   2              /*
1306   2              FlashWriteEnable();
1307   2              SPI_SI_BUF[0] = BYTE_WRITE;
1308   2              SPI_SI_BUF[1] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
1309   2              SPI_SI_BUF[2] = ( wAddr >> 8 ) & 0x0ff;
1310   2              SPI_SI_BUF[3] = wAddr & 0x0ff;
1311   2              SPI_SI_BUF[4] = *( buffer + ( i++ ) );
1312   2              SPI_CTRL = 0xFC;
1313   2              */
1314   2              
1315   2              wAddr += 1;
1316   2              count -= 1;
1317   2      
1318   2          }
1319   1          //MCU_CACHE_CTL = 0x20;
1320   1      
1321   1      
1322   1          if( bDoWP )
1323   1              FlashEnableWP();// 2005/5/11 W 10:19:43 by keng
1324   1      
1325   1          if( bcachestatus )
1326   1              CACHE_ENABLE();//EnableCache();
1327   1      }
1328          void Flash_MoveTbl( Bool bDoWP, WORD wSrcAddr, WORD wDestAddr, WORD count )
1329          {
1330   1          BYTE ucTemp;
1331   1          bit bcachestatus;
1332   1      
1333   1          if( wDestAddr < FDATA_START_ADDR )
1334   1              return;
1335   1      
1336   1          bcachestatus = CACHE_STATUS();//CacheStatus();
1337   1          
1338   1          if( bcachestatus )
1339   1              CACHE_DISABLE();//DisableCache();
1340   1      
1341   1          if( bDoWP )
1342   1              FlashDisableWP( wDestAddr ); // 2005/5/11 W 10:19:39 by keng
1343   1          while( count > 0 )
1344   1          {
1345   2              ucTemp = FlashReadByte( wSrcAddr );
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 23  

1346   2              FlashDisableStausProtect_MXIC2026();
1347   2      
1348   2              // 1st
1349   2              SPI_SI_BUF[0]   = WREN;
1350   2              // 2nd
1351   2              SPI_SI_BUF[1] = BYTE_WRITE;
1352   2              SPI_SI_BUF[2] = TOTAL_BANK_NUM - 1; //(wAddr>>16)&0x0ff;
1353   2              SPI_SI_BUF[3] = ( wDestAddr >> 8 ) & 0x0ff;
1354   2              SPI_SI_BUF[4] = wDestAddr & 0x0ff;
1355   2              SPI_SI_BUF[5] = ucTemp;
1356   2              // 3rd
1357   2              SPI_SI_BUF[6]   = RDSR;
1358   2      
1359   2              SPI_CTRL0       = SPI_CTRL_VALUE; //ctrl en FSP/reset
1360   2              SPI_CTRL1       = (EN_2ND_CMD|EN_3RD_CMD|RDSR_IN_3RD|EN_AUTO_CHECK);
1361   2              SET_WBF_SIZE(1, 5, 1);
1362   2              SET_RBF_SIZE(0, 0, 1);
1363   2              SPI_TRIGGER     = 0x01; //start flash programming
1364   2              drvFlashWaitSPINotBusy();
1365   2      
1366   2              /*
1367   2              FlashWriteEnable();
1368   2              SPI_SI_BUF[0] = BYTE_WRITE;
1369   2              SPI_SI_BUF[1] = TOTAL_BANK_NUM - 1; //(wDestAddr>>16)&0x0ff; // bank 3
1370   2              SPI_SI_BUF[2] = ( wDestAddr >> 8 ) & 0x0ff;
1371   2              SPI_SI_BUF[3] = wDestAddr & 0x0ff;
1372   2              SPI_SI_BUF[4] = ucTemp;
1373   2              SPI_CTRL = 0xFC;
1374   2              */
1375   2              
1376   2              wSrcAddr += 1;
1377   2              wDestAddr += 1;
1378   2              count -= 1;
1379   2          }
1380   1          if( bDoWP )
1381   1              FlashEnableWP();// 2005/5/11 W 10:19:43 by keng
1382   1      
1383   1          if( bcachestatus )
1384   1              CACHE_ENABLE();//EnableCache();
1385   1      
1386   1      }
1387          //////////////////////////////////////////////////////////////////////////////
1388          // <DRV><Description>: Read a table from flash
1389          // <Parameter>:     -   <Flow>  -   <Description>
1390          // ---------------------------------------------------------------------------
1391          //  wAddr   -   In  -   Flash Address
1392          //  buffer  -   Out -   Data point of the table
1393          //  count   -   In  -   Number of BYTE data
1394          //////////////////////////////////////////////////////////////////////////////
1395          /*
1396           *****************************************
1397           * @Description ：读Flash数据的函数
1398           * @Parameter1 ：wAddr -> 要读的地址
1399           * @Parameter2 ：buffer -> 读到哪个buf
1400           * @Parameter3 ：count -> 读的个数
1401           *****************************************
1402           */
1403          
1404          void Flash_ReadTbl( WORD wAddr, BYTE *buffer, WORD count )
1405          {
1406   1          WORD i;
1407   1          for( i = 0; i < count; i++ )
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 24  

1408   1              *( buffer + i ) = xfr_FlashCode[wAddr+i];
1409   1      }
1410          
1411          
1412          //////////////////////////////////////////////////////////////////////////////
1413          // <API><Description>: Search specific FLASH_BUFFTER_TYPE form FDATA_BUF_ADDR(x)
1414          // <Returns> : Specific buffer address when found; 0 when not found
1415          // <Parameter>:     -   <Flow>  -   <Description>
1416          // ---------------------------------------------------------------------------
1417          //  ucType  -   In  -   buffer type, such as FBufType_MonitorSetting, FBufType_TimingMode ..
1418          //////////////////////////////////////////////////////////////////////////////
1419          //根据你所传进来的Type在四个动态block中查找，查找到后返回地址
1420          WORD Flash_SearchBufferAddr( FLASH_BUFFTER_TYPE ucType )
1421          {
1422   1          BYTE ucTemp;
1423   1      
1424   1          for( ucTemp = 0; ucTemp < FDATA_DYNAMIC_SECTOR_NUM; ucTemp++ )//4
1425   1          {
1426   2              if( FlashReadByte( FDATA_BUF_ADDR( ucTemp ) ) == ucType )
1427   2                  return FDATA_BUF_ADDR( ucTemp );
1428   2          }
1429   1          return 0;
1430   1      }
1431          //////////////////////////////////////////////////////////////////////////////
1432          // <API><Description>: Compare the FlashReadByte(wAddr + i*wRange)==ucIdent
1433          //                                 FlashReadByte(wAddr + i*wRange + wRange - 1) == ucChecksum
1434          //                     return i if equal ,else return IDENT_NOT_FOUND
1435          // Search index from wStartIdx to wEndIdx to replace i. Can from 0 search to 255(include)
1436          // Also can from 255 to 0(include)
1437          // <Returns> : Specific buffer address when found; IDENT_NOT_FOUND when not found
1438          // <Parameter>:     -   <Flow>  -   <Description>
1439          // ---------------------------------------------------------------------------
1440          //  wAddr       -   In  -   Flash start Address
1441          //  wStartIdx   -   In  -   wAddr + wStartIdx*wRange
1442          //  wEndIdx     -   In  -   wAddr + wEndIdx*wRange
1443          //  wRange      -   In  -   Each search range
1444          //  ucIdent     -   In  -   Data of want to compare
1445          //  ucChecksum  -   In  -   Data of want to compare
1446          //////////////////////////////////////////////////////////////////////////////
1447          //waddr:起始地址
1448          //wstartidx,wendidx:第几组开始到第几组结束，每组有多少个成员看结构体而定
1449          //wrange:一组的大小
1450          //ucident,ucchecksum:从某组第一位开始看是不是0xff,到一组结束最后一位是不是0xff,不
             -是则继续下一组继续以此类推
1451          //一个bank 64k（0000H-FFFFH）,一个block为4k,一个指针访问的区间为一个Bank的大小
1452          //
1453          WORD Flash_SearchIdentChecksum( WORD wAddr, WORD wStartIdx, WORD wEndIdx, WORD wRange, BYTE ucIdent, BYTE 
             -ucChecksum )
1454          {
1455   1          WORD i;
1456   1      
1457   1          if( wStartIdx < wEndIdx )
1458   1          {
1459   2              i = wStartIdx;
1460   2              while( i >= wStartIdx && i <= wEndIdx )
1461   2              {                       //判断一组数据的头和尾的标志位是否正确
1462   3                  if( FlashReadByte( wAddr + i * wRange ) == ucIdent && FlashReadByte( wAddr + i * wRange + wRan
             -ge - 1 ) == ucChecksum )
1463   3                      return i;
1464   3                  i++;
1465   3              }
1466   2          }
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 25  

1467   1          else
1468   1          {
1469   2              i = wStartIdx;
1470   2              while( i >= wEndIdx && i <= wStartIdx )
1471   2              {
1472   3                  if( FlashReadByte( wAddr + i * wRange ) == ucIdent && FlashReadByte( wAddr + i * wRange + wRan
             -ge - 1 ) == ucChecksum )
1473   3                      return i;
1474   3                  i--;
1475   3              }
1476   2      
1477   2          }
1478   1          //FLASH_printMsg("------- IDENT_CHECKSUM_NOT_FOUND -------");
1479   1          return IDENT_NOT_FOUND;
1480   1      }
1481          
1482          //////////////////////////////////////////////////////////////////////////////
1483          //  <API><Description>: Get each buffer address and assign to variable
1484          //  FLASH_MonitorSettingAddr
1485          //  FLASH_MonitorSetting2Addr
1486          //  FLASH_TimingModeAddr
1487          //  FLASH_FactorySettingAddr
1488          //  FLASH_FreeBufferAddr
1489          //////////////////////////////////////////////////////////////////////////////
1490          //得到HDCP_EDID/Factory/MonitorSetting/MonitorSetting2/ModeSetting存放在Flash中的Block起始地址.
1491          //其中HDCP_EDID固定Block起始地址为0x7F000，Factory 固定Block起始地址为0x7E000
1492          void Flash_GetBufferAddr(void)
1493                  {
1494   1                      WORD wAddr;
1495   1                      FLASH_HDCP_EDIDAddr = FDATA_HDCPKEY_START_ADDR;//0xf000
1496   1                      FLASH_FactorySettingAddr = FDATA_FACTORY_ADDR;//0xe000
1497   1                      FLASH_MonitorSettingAddr = 0;
1498   1                      FLASH_MonitorSetting2Addr = 0;
1499   1                      FLASH_TimingModeAddr = 0;
1500   1                      FLASH_FreeBufferAddr = 0;
1501   1              
1502   1                      FLASH_printData("_FGBA_ FLASH_FactorySettingAddr %x ",(WORD)(FLASH_FactorySettingAddr));
1503   1              
1504   1                      wAddr = Flash_SearchBufferAddr(FBufType_MonitorSetting);//0x88//地址搜索函数搜索地址
1505   1                      if(wAddr)
1506   1                      {       FLASH_MonitorSettingAddr = wAddr;
1507   2              
1508   2                              FLASH_printData("_FGBA_ FLASH_MonitorSettingAddr %x ",(WORD)(FLASH_MonitorSettingAddr));
1509   2              
1510   2                      }
1511   1              
1512   1                      wAddr = Flash_SearchBufferAddr(FBufType_MonitorSetting2);//0x44
1513   1                      if(wAddr)
1514   1                      {       FLASH_MonitorSetting2Addr = wAddr;
1515   2              
1516   2                              FLASH_printData("_FGBA_ FLASH_MonitorSetting2Addr %x ",(WORD)(FLASH_MonitorSetting2Addr));
1517   2              
1518   2                      }
1519   1              
1520   1                      wAddr = Flash_SearchBufferAddr(FBufType_TimingMode);//0x22
1521   1                      if(wAddr)
1522   1                      {       FLASH_TimingModeAddr = wAddr;
1523   2              
1524   2                              FLASH_printData("_FGBA_ FLASH_TimingModeAddr %x ",(WORD)(FLASH_TimingModeAddr));
1525   2              
1526   2                      }
1527   1              
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 26  

1528   1                      wAddr = Flash_SearchBufferAddr(FBufType_EmptyBuffer);//0xff
1529   1                      if(wAddr)
1530   1                      {       FLASH_FreeBufferAddr = wAddr;
1531   2              
1532   2                              FLASH_printData("FLASH_FreeBufferAddr %x ",(WORD)(FLASH_FreeBufferAddr));
1533   2              
1534   2                      }
1535   1                      // 091022 coding, free buffer type should be 0xff or 0x00
1536   1                              else
1537   1                              {
1538   2                                      if((wAddr = Flash_SearchBufferAddr(FBufType_FullBuffer)) >= FDATA_DYNAMIC_ADDR)//0x00,0xa000
1539   2                                              FLASH_FreeBufferAddr = wAddr;
1540   2                              }
1541   1              
1542   1                      return;
1543   1              }
1544          
1545          
1546          //////////////////////////////////////////////////////////////////////////////
1547          // <API><Description>: After execute Flash_GetBufferAddr, makesure each address reasonable
1548          //////////////////////////////////////////////////////////////////////////////
1549          //检查HDCP_EDID/Factory/MonitorSetting/MonitorSetting2/ModeSetting中是否有未分配到Block，没有
             -则重新分，确保合法
1550          void Flash_AllocateBufferAddr(void)
1551                  {       BYTE ucTemp;
1552   1              
1553   1                      if(FLASH_MonitorSettingAddr==0)
1554   1                      {
1555   2                              for(ucTemp=0;ucTemp<FDATA_DYNAMIC_SECTOR_NUM;ucTemp++)//4
1556   2                              {
1557   3                              #if 0
                                              FLASH_printData("Flash_Allocate 01 %x ",(WORD)(FLASH_TimingModeAddr>>8));
                                              FLASH_printData("Flash_Allocate 02 %x ",(WORD)(FLASH_FreeBufferAddr>>8));
                                              FLASH_printData("Flash_Allocate 03 %x ",(WORD)(FDATA_BUF_ADDR(ucTemp)>>8));
                                      #endif
1562   3                                      if(FDATA_BUF_ADDR(ucTemp)!=FLASH_TimingModeAddr
1563   3                                              && FDATA_BUF_ADDR(ucTemp)!=FLASH_FreeBufferAddr
1564   3                                              && FDATA_BUF_ADDR(ucTemp)!= FLASH_MonitorSetting2Addr)
1565   3                                      {       FLASH_MonitorSettingAddr = FDATA_BUF_ADDR(ucTemp);
1566   4                                              break;
1567   4                                      }
1568   3                              }
1569   2              
1570   2                              FLASH_printData("_FABA_ FLASH_MonitorSettingAddr %x ",(WORD)(FLASH_MonitorSettingAddr));
1571   2              
1572   2                      }
1573   1                      if(FLASH_MonitorSetting2Addr==0)
1574   1                      {
1575   2                              for(ucTemp=0;ucTemp<FDATA_DYNAMIC_SECTOR_NUM;ucTemp++)
1576   2                              {
1577   3                                      if(FDATA_BUF_ADDR(ucTemp)!=FLASH_MonitorSettingAddr
1578   3                                              && FDATA_BUF_ADDR(ucTemp)!=FLASH_TimingModeAddr
1579   3                                              && FDATA_BUF_ADDR(ucTemp)!=FLASH_FreeBufferAddr)
1580   3                                      {       FLASH_MonitorSetting2Addr = FDATA_BUF_ADDR(ucTemp);
1581   4                                              break;
1582   4                                      }
1583   3                              }
1584   2              
1585   2                              FLASH_printData("_FABA_ FLASH_MonitorSetting2Addr %x ",(WORD)(FLASH_MonitorSetting2Addr));
1586   2              
1587   2                      }
1588   1                      if(FLASH_TimingModeAddr==0)
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 27  

1589   1                      {
1590   2                              for(ucTemp=0;ucTemp<FDATA_DYNAMIC_SECTOR_NUM;ucTemp++)
1591   2                              {
1592   3                                      if(FDATA_BUF_ADDR(ucTemp)!=FLASH_MonitorSettingAddr
1593   3                                              && FDATA_BUF_ADDR(ucTemp)!=FLASH_FreeBufferAddr
1594   3                                              && FDATA_BUF_ADDR(ucTemp)!= FLASH_MonitorSetting2Addr)
1595   3                                      {       FLASH_TimingModeAddr = FDATA_BUF_ADDR(ucTemp);
1596   4                                              break;
1597   4                                      }
1598   3                              }
1599   2              
1600   2                              FLASH_printData("_FABA_ FLASH_TimingModeAddr %x ",(WORD)(FLASH_TimingModeAddr));
1601   2              
1602   2                      }
1603   1                      if(FLASH_FreeBufferAddr==0)
1604   1                      {
1605   2                              for(ucTemp=0;ucTemp<FDATA_DYNAMIC_SECTOR_NUM;ucTemp++)
1606   2                              {
1607   3                                      if(FDATA_BUF_ADDR(ucTemp)!=FLASH_MonitorSettingAddr
1608   3                                              && FDATA_BUF_ADDR(ucTemp)!=FLASH_TimingModeAddr
1609   3                                              && FDATA_BUF_ADDR(ucTemp)!= FLASH_MonitorSetting2Addr)
1610   3                                      {       FLASH_FreeBufferAddr = FDATA_BUF_ADDR(ucTemp);
1611   4                                              break;
1612   4                                      }
1613   3                              }
1614   2              
1615   2                              FLASH_printData("_FABA_ FLASH_FreeBufferAddr %x ",(WORD)(FLASH_FreeBufferAddr));
1616   2              
1617   2                      }
1618   1              
1619   1                      if(FLASH_MonitorSettingAddr==0 || FLASH_MonitorSetting2Addr==0 || FLASH_TimingModeAddr==0 || FLASH_FreeB
             -ufferAddr==0)
1620   1                      {
1621   2                                      FLASH_MonitorSettingAddr = FDATA_BUF_ADDR(0);
1622   2                                      FLASH_MonitorSetting2Addr = FDATA_BUF_ADDR(1);
1623   2                                      FLASH_TimingModeAddr = FDATA_BUF_ADDR(2);
1624   2                                      FLASH_FreeBufferAddr = FDATA_BUF_ADDR(3);
1625   2              
1626   2                              FLASH_printMsg("_FABA_ Addr NEW");
1627   2                              FLASH_printData("_FABA_ FLASH_MonitorSettingAddr %x ",(WORD)(FLASH_MonitorSettingAddr));
1628   2                              FLASH_printData("_FABA_ FLASH_MonitorSetting2Addr %x ",(WORD)(FLASH_MonitorSetting2Addr));
1629   2                              FLASH_printData("_FABA_ FLASH_TimingModeAddr %x ",(WORD)(FLASH_TimingModeAddr));
1630   2                              FLASH_printData("_FABA_ FLASH_FactorySettingAddr %x ",(WORD)(FLASH_FactorySettingAddr));
1631   2                              FLASH_printData("_FABA_ FLASH_FreeBufferAddr %x ",(WORD)(FLASH_FreeBufferAddr));
1632   2                              #if 1//((CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF)&& ENABLE_CABLE_5V_EDID)
1633   2                              FLASH_printData( "_FABA_ FLASH_HDCP_EDIDAddr %x ", ( WORD )( FLASH_HDCP_EDIDAddr) );
1634   2                              #endif
1635   2      
1636   2                      }
1637   1              
1638   1              }
1639          
1640          //////////////////////////////////////////////////////////////////////////////
1641          // <API><Description>: Check each buffer type correct or not,
1642          //                                Erase the sector when type wrong
1643          //////////////////////////////////////////////////////////////////////////////
1644          //若各个地址对应的Block没有或不等于起始Flag，则对相应的Block进行擦除动作，并
             -写入相应的起始Flag
1645          void Flash_CheckBufferType(void)
1646          {
1647   1      
1648   1          if( FBufType_HDCP_EDID!= FlashReadByte( FLASH_HDCP_EDIDAddr) )
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 28  

1649   1          {
1650   2              bFlashWriteFactory= TRUE;
1651   2              FlashSectorErase( TRUE, FLASH_HDCP_EDIDAddr );
1652   2              FlashWriteByte( TRUE, FLASH_HDCP_EDIDAddr, FBufType_HDCP_EDID);
1653   2              bFlashWriteFactory = FALSE;
1654   2              FLASH_printMsg( "Flash_CheckBufferType SetHDCPType" );
1655   2          }   
1656   1              if(FBufType_FactorySetting !=FlashReadByte(FLASH_FactorySettingAddr))
1657   1              {       bFlashWriteFactory = TRUE;
1658   2              #if 0
                       if(FlashReadByte(HDCPKEYSET_START)==0xFF&&FlashReadByte(HDCPKEYSET_START+1)==0xFF
                              &&FlashReadByte(HDCPKEYSET_START+2)==0xFF&&FlashReadByte(HDCPKEYSET_START+3)==0xFF
                              &&FlashReadByte(HDCPKEYSET_START+4)==0xFF)                      //charles test 1125
                      #endif
1663   2                      FlashSectorErase(TRUE, FLASH_FactorySettingAddr);
1664   2                      FlashWriteByte(TRUE,FLASH_FactorySettingAddr, FBufType_FactorySetting);
1665   2                      bFlashWriteFactory = FALSE;
1666   2                      FLASH_printMsg("Flash_CheckBufferType SetFactoryType");
1667   2              }
1668   1              if(FBufType_MonitorSetting!=FlashReadByte(FLASH_MonitorSettingAddr))
1669   1              {       FlashSectorErase(TRUE, FLASH_MonitorSettingAddr);
1670   2                      FlashWriteByte(TRUE,FLASH_MonitorSettingAddr, FBufType_MonitorSetting);
1671   2                      FLASH_printMsg("Flash_CheckBufferType SetMonitorType");
1672   2              }
1673   1              if(FBufType_MonitorSetting2!=FlashReadByte(FLASH_MonitorSetting2Addr))
1674   1              {       FlashSectorErase(TRUE, FLASH_MonitorSetting2Addr);
1675   2                      FlashWriteByte(TRUE,FLASH_MonitorSetting2Addr, FBufType_MonitorSetting2);
1676   2                      FLASH_printMsg("Flash_CheckBufferType SetMonitorSetting2Type");
1677   2              }
1678   1              if(FBufType_TimingMode!=FlashReadByte(FLASH_TimingModeAddr))
1679   1              {       FlashSectorErase(TRUE, FLASH_TimingModeAddr);
1680   2                      FlashWriteByte(TRUE,FLASH_TimingModeAddr, FBufType_TimingMode);
1681   2                      FLASH_printMsg("Flash_CheckBufferType SetTimingModeAddrType");
1682   2              }
1683   1      
1684   1      }
1685          
1686          
1687          //////////////////////////////////////////////////////////////////////////////
1688          // <API><Description>: Clear all timing mode save in flash
1689          //////////////////////////////////////////////////////////////////////////////
1690          void Flash_ClearModeSet(void)
1691          {
1692   1              FLASH_printMsg("_FCMS_ Flash_ClearModeSet");
1693   1      
1694   1              FlashSectorErase(TRUE, FLASH_TimingModeAddr);
1695   1              FlashWriteByte(TRUE, FLASH_TimingModeAddr,FBufType_TimingMode);
1696   1      }
1697          
1698          //////////////////////////////////////////////////////////////////////////////
1699          // <API><Description>:  Write Factory setting, HDCP Key, DDCA, DDCD key to free buffer,
1700          //                  Exchange buffer address FLASH_FreeBufferAddr and FLASH_FactorySettingAddr
1701          //ture获得“空的”数据的状态位的位置,flase获取有效数据的状态位的位置
1702          //////////////////////////////////////////////////////////////////////////////、
1703          /*
1704           **********************************************************************************************
1705           * @Description ：算ucKeyIndex，可以类似理解为偏移量的倍数，有效数据是第几组，
             -偏移多少个空间size
1706           * @Parameter1 ：ucType -> key类型
1707           * @Parameter2 ：bWrite -> 传入false时，空间满了不会返回最后一组数据，直接返回0；
1708           *                                                 空间未满的话返回有效数据的空间偏移倍数
1709           ***********************************************************************************************
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 29  

1710           */
1711          
1712          BYTE Flash_GetKeyIndex(FLASH_KEY_TYPE ucType, Bool bWrite)
1713          {
1714   1          BYTE ucIndex, ucStatus, ucSize=0;
1715   1          WORD wAddr;
1716   1      
1717   1          if(ucType == FLASH_KEY_FACTORY)
1718   1          {
1719   2              ucSize = FACTORY_SECTOR_SIZE/FACTORY_SIZE;
1720   2              wAddr  = FACTORY_STATUS_ADDR;
1721   2          }
1722   1      
1723   1      #if 0    
                  else if(ucType == FLASH_KEY_GAMMA)
                  {
                      ucSize = GAMMA_SECTOR_SIZE/GAMMA_SIZE;
                      wAddr  = GAMMA_STATUS_ADDR;
                  }
              #endif    
1730   1      #if 1//((CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF) && ENABLE_CABLE_5V_EDID)
1731   1          else if(ucType == FLASH_KEY_HDCP)
1732   1          {
1733   2              ucSize = HDCPKEY_SECTOR_SIZE/HDCPKEY_SIZE;
1734   2              wAddr  = HDCPKEY_STATUS_ADDR;
1735   2          }
1736   1          
1737   1          else if(ucType == FLASH_KEY_DDCA)
1738   1          {
1739   2              ucSize = DDCAKEY_SECTOR_SIZE/DDCAKEY_SIZE;
1740   2              wAddr  = DDCAKEY_STATUS_ADDR;
1741   2          }
1742   1          else if(ucType == FLASH_KEY_DDCD)
1743   1          {
1744   2              ucSize = DDCDKEY_SECTOR_SIZE/DDCDKEY_SIZE;
1745   2              wAddr  = DDCDKEY_STATUS_ADDR;
1746   2          }
1747   1         else if(ucType == FLASH_KEY_DDCH)
1748   1          {
1749   2              ucSize = DDCHKEY_SECTOR_SIZE/DDCHKEY_SIZE;
1750   2              wAddr  = DDCHKEY_STATUS_ADDR;
1751   2          }
1752   1      #else
                  else if(ucType == FLASH_KEY_DDCDP)
                  {
                      ucSize = DDCDPKEY_SECTOR_SIZE/DDCDPKEY_SIZE;
                      wAddr  = DDCDPKEY_STATUS_ADDR;
                  }
              #endif
1759   1          for(ucIndex=0;ucIndex<ucSize;ucIndex++)
1760   1          {
1761   2              ucStatus = FlashReadByte(wAddr+ucIndex);
1762   2              if(bWrite)
1763   2              {
1764   3                  if( ucStatus == FLASH_KEY_EMPTY || ucStatus == FLASH_KEY_WRITE)
1765   3                      break;
1766   3              }
1767   2              else
1768   2              {
1769   3                  if( ucStatus == FLASH_KEY_VALID)
1770   3                      break;
1771   3              }
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 30  

1772   2          }
1773   1      
1774   1          if( ucIndex >= ucSize )
1775   1          {
1776   2              if(bWrite)
1777   2                  ucIndex = ucSize - 1;
1778   2              else
1779   2                  ucIndex = 0;
1780   2          }
1781   1      
1782   1          return ucIndex;
1783   1      }
1784          //////////////////////////////////////////////////////////////////////////////
1785          // <API><Description>:  Write Factory setting, HDCP Key, DDCA, DDCD key to free buffer,
1786          //                  Exchange buffer address FLASH_FreeBufferAddr and FLASH_FactorySettingAddr
1787          ////////////////////////////////////////////////////////////////////////////////
1788          //      将工厂设置、HDCP 密钥、DDCA、DDCD 密钥写入空闲缓冲区、
1789          // 交换缓冲区地址 FLASH_FreeBufferAddr 和 FLASH_FactorySettingAddr
1790          void Flash_BackupFactorySetToBuffer(BYTE ucBufferType)
1791          {
1792   1              BYTE xdata ucKeyIndex;
1793   1              WORD wAddr;
1794   1      
1795   1              FLASH_printMsg( "  Flash_BackupFactorySetToBuffer " );
1796   1      
1797   1              FlashDisableWP( FLASH_FreeBufferAddr );
1798   1      #if 1//((CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF) && ENABLE_CABLE_5V_EDID)
1799   1               if( ucBufferType == FBufType_HDCP_EDID )
1800   1           {
1801   2               ucKeyIndex = Flash_GetKeyIndex(FLASH_KEY_HDCP, FALSE);
1802   2               if(FlashReadByte(HDCPKEY_STATUS_ADDR+ucKeyIndex) == FLASH_KEY_VALID
1803   2               && FlashReadByte(HDCPKEY_BUF_STATUS_ADDR) == FLASH_KEY_EMPTY)
1804   2               {
1805   3                  Flash_MoveTbl( FALSE, HDCPKEYSET_START + ucKeyIndex * HDCPKEY_SIZE, HDCPKEYSET_BUF_START, HDCP
             -KEY_SIZE );
1806   3                      FlashWriteByte(FALSE, HDCPKEY_BUF_STATUS_ADDR, FLASH_KEY_VALID);
1807   3                      FLASH_printMsg("  _HDCP_ ");
1808   3               }
1809   2               
1810   2               ucKeyIndex = Flash_GetKeyIndex(FLASH_KEY_DDCA, FALSE);
1811   2               if(FlashReadByte(DDCAKEY_STATUS_ADDR+ucKeyIndex) == FLASH_KEY_VALID
1812   2               && FlashReadByte(DDCAKEY_BUF_STATUS_ADDR) == FLASH_KEY_EMPTY)
1813   2               {
1814   3                   Flash_MoveTbl( FALSE, DDCAKEYSET_START + ucKeyIndex * DDCAKEY_SIZE, DDCAKEYSET_BUF_START, DDC
             -AKEY_SIZE );
1815   3                   FlashWriteByte(FALSE, DDCAKEY_BUF_STATUS_ADDR, FLASH_KEY_VALID);
1816   3                   FLASH_printMsg("  _DDCA_ ");
1817   3               }
1818   2               
1819   2               ucKeyIndex = Flash_GetKeyIndex(FLASH_KEY_DDCD, FALSE);
1820   2               if(FlashReadByte(DDCDKEY_STATUS_ADDR+ucKeyIndex) == FLASH_KEY_VALID
1821   2               && FlashReadByte(DDCDKEY_BUF_STATUS_ADDR) == FLASH_KEY_EMPTY)
1822   2               {
1823   3                   Flash_MoveTbl( FALSE, DDCDKEYSET_START + ucKeyIndex * DDCDKEY_SIZE, DDCDKEYSET_BUF_START, DDC
             -DKEY_SIZE );
1824   3                   FlashWriteByte(FALSE, DDCDKEY_BUF_STATUS_ADDR, FLASH_KEY_VALID);
1825   3                   FLASH_printMsg("  _DDCD_ ");
1826   3               }
1827   2      
1828   2                 ucKeyIndex = Flash_GetKeyIndex(FLASH_KEY_DDCH, FALSE);
1829   2               if(FlashReadByte(DDCHKEY_STATUS_ADDR+ucKeyIndex) == FLASH_KEY_VALID
1830   2               && FlashReadByte(DDCHKEY_BUF_STATUS_ADDR) == FLASH_KEY_EMPTY)
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 31  

1831   2               {
1832   3                   Flash_MoveTbl( FALSE, DDCHKEYSET_START + ucKeyIndex * DDCHKEY_SIZE, DDCHKEYSET_BUF_START, DDC
             -HKEY_SIZE );
1833   3                   FlashWriteByte(FALSE, DDCHKEY_BUF_STATUS_ADDR, FLASH_KEY_VALID);
1834   3                   FLASH_printMsg("  _DDCH_ ");
1835   3               }
1836   2               
1837   2               FlashWriteByte( FALSE, FLASH_FreeBufferAddr, ucBufferType );
1838   2               FlashEnableWP();
1839   2               FlashWriteByte( TRUE, FLASH_HDCP_EDIDAddr, 0x00 );
1840   2               wAddr = FLASH_FreeBufferAddr;
1841   2               FLASH_FreeBufferAddr = FLASH_HDCP_EDIDAddr;
1842   2               FLASH_HDCP_EDIDAddr = wAddr;
1843   2           
1844   2           }
1845   1      #endif
1846   1               if( ucBufferType == FBufType_FactorySetting )
1847   1           {  
1848   2              ucKeyIndex = Flash_GetKeyIndex(FLASH_KEY_FACTORY, FALSE);//返回有效数据那一组
1849   2              if(FlashReadByte(FACTORY_STATUS_ADDR+ucKeyIndex) == FLASH_KEY_VALID
1850   2                      && FlashReadByte(FACTORY_BUF_STATUS_ADDR) == FLASH_KEY_EMPTY)
1851   2              {
1852   3                      Flash_MoveTbl(FALSE, FACTORY_START+(WORD)ucKeyIndex*FACTORY_SIZE, FACTORY_BUF_START, FACTORY_SIZE);
             -//有效数据放入freebuffer
1853   3                      FlashWriteByte(FALSE, FACTORY_BUF_STATUS_ADDR, FLASH_KEY_VALID);//写入数据标识
1854   3                      FLASH_printMsg( "  _FACT_ " );
1855   3              }
1856   2               
1857   2           #if 0
                      ucKeyIndex = Flash_GetKeyIndex(FLASH_KEY_GAMMA, FALSE);
                      if(FlashReadByte(GAMMA_STATUS_ADDR+ucKeyIndex) == FLASH_KEY_VALID
                              && FlashReadByte(GAMMA_BUF_STATUS_ADDR) == FLASH_KEY_EMPTY)
                      {
                              Flash_MoveTbl(FALSE, GAMMA_START+(WORD)ucKeyIndex*GAMMA_SIZE, GAMMA_BUF_START, GAMMA_SIZE);
                              FlashWriteByte(FALSE, GAMMA_BUF_STATUS_ADDR, FLASH_KEY_VALID);
                              FLASH_printMsg("  _GAMMA_ ");
                      }
                      
                      ucKeyIndex = Flash_GetKeyIndex(FLASH_KEY_HDCP, FALSE);
                      if(FlashReadByte(HDCPKEY_STATUS_ADDR+ucKeyIndex) == FLASH_KEY_VALID
                              && FlashReadByte(HDCPKEY_BUF_STATUS_ADDR) == FLASH_KEY_EMPTY)
                      {
                              Flash_MoveTbl(FALSE, HDCPKEYSET_START+(WORD)ucKeyIndex*HDCPKEY_SIZE, HDCPKEYSET_BUF_START, HDCPKEY_
             -SIZE);
                              FlashWriteByte(FALSE, HDCPKEY_BUF_STATUS_ADDR, FLASH_KEY_VALID);
                              FLASH_printMsg("  _HDCP_ ");
                      }
                      
                      ucKeyIndex = Flash_GetKeyIndex(FLASH_KEY_DDCA, FALSE);
                      if(FlashReadByte(DDCAKEY_STATUS_ADDR+ucKeyIndex) == FLASH_KEY_VALID
                              && FlashReadByte(DDCAKEY_BUF_STATUS_ADDR) == FLASH_KEY_EMPTY)
                      {
                              Flash_MoveTbl(FALSE, DDCAKEYSET_START+(WORD)ucKeyIndex*DDCAKEY_SIZE, DDCAKEYSET_BUF_START, DDCAKEY_
             -SIZE);
                              FlashWriteByte(FALSE, DDCAKEY_BUF_STATUS_ADDR, FLASH_KEY_VALID);
                              FLASH_printMsg("  _DDCA_ ");
                      }
                      
                      ucKeyIndex = Flash_GetKeyIndex(FLASH_KEY_DDCD, FALSE);
                      if(FlashReadByte(DDCDKEY_STATUS_ADDR+ucKeyIndex) == FLASH_KEY_VALID
                              && FlashReadByte(DDCDKEY_BUF_STATUS_ADDR) == FLASH_KEY_EMPTY)
                      {
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 32  

                              Flash_MoveTbl(FALSE, DDCDKEYSET_START+(WORD)ucKeyIndex*DDCDKEY_SIZE, DDCDKEYSET_BUF_START, DDCDKEY_
             -SIZE);
                              FlashWriteByte(FALSE, DDCDKEY_BUF_STATUS_ADDR, FLASH_KEY_VALID);
                              FLASH_printMsg("  _DDCD_ ");
                      }
                      
                      if( FlashReadByte( DDCHKEY_STATUS_ADDR ) == FLASH_KEY_VALID )
                      {
                              Flash_MoveTbl( FALSE, DDCHKEYSET_START, DDCHKEYSET_BUF_START, DDCHKEY_SIZE );
                              FlashWriteByte( FALSE, DDCHKEY_BUF_STATUS_ADDR, FLASH_KEY_VALID );
                              FLASH_printMsg( "  _DDCH_ " );
                      }
                   #endif
1901   2           #if 0//((CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF) && ENABLE_CABLE_5V_EDID)
              
                      ucKeyIndex = Flash_GetKeyIndex(FLASH_KEY_DDCDP, FALSE);
                      if(FlashReadByte(DDCDPKEY_STATUS_ADDR+ucKeyIndex) == FLASH_KEY_VALID
                              && FlashReadByte(DDCDPKEY_BUF_STATUS_ADDR) == FLASH_KEY_EMPTY)
                      {
                              Flash_MoveTbl(FALSE, DDCDPKEYSET_START+(WORD)ucKeyIndex*DDCDPKEY_SIZE, DDCDPKEYSET_BUF_START, DDCDP
             -KEY_SIZE);
                              FlashWriteByte(FALSE, DDCDPKEY_BUF_STATUS_ADDR, FLASH_KEY_VALID);
                              FLASH_printMsg("  _DDCDP_ ");
                      }
                   #endif
1912   2              FlashWriteByte( FALSE, FLASH_FreeBufferAddr, FBufType_FactorySetting );//标识空间的类型
1913   2              FlashEnableWP();//使能写引脚
1914   2              FlashWriteByte( TRUE, FLASH_FactorySettingAddr, 0x00 );//旧地址的最后一组数据失效
1915   2              wAddr = FLASH_FreeBufferAddr;//地址交换
1916   2              FLASH_FreeBufferAddr = FLASH_FactorySettingAddr;
1917   2              FLASH_FactorySettingAddr = wAddr;
1918   2           }
1919   1      }
1920          
1921          
1922          //////////////////////////////////////////////////////////////////////////////
1923          // <API><Description>:  Write HDCP ,DDCA or DDCD key to flash,
1924          //                                      Need set correct type of key.
1925          //                  wIndex from 0 to (key size / ucBufSize) or (key size / ucBufSize+1)
1926          //                  The last write wLen = (key size % ucBufSize)
1927          //                  Will backup to free buffer if write to index = (MAX_HDCPKEYSET_NUM-1)
1928          // <Parameter>:         -       <Flow>  -       <Description>
1929          // ---------------------------------------------------------------------------
1930          //  ucType          -    In             -       FLASH_KEY_HDCP, FLASH_KEY_DDCA or FLASH_KEY_DDCD
1931          //  wIndex                      -    In         -       From 0 ~ x
1932          //  ucBufSize       -    In             -       Size of buf
1933          //  *buf                        -    In         -       point to the data of each set
1934          //  wLen                        -    In         -       Length of this time write buffer, wBufSize>=wLen
1935          //////////////////////////////////////////////////////////////////////////////
1936          void Flash_Write_Factory_KeySet(FLASH_KEY_TYPE ucType, WORD wIndex, WORD wBufSize, BYTE* buf, WORD wLen)
1937          {
1938   1              BYTE xdata ucKeyIndex;
1939   1              WORD xdata wKEY_SIZE;
1940   1              WORD xdata wKEYSET_START;
1941   1              WORD xdata wKEYSET_BUF_START;
1942   1              WORD xdata wKEYSET_STATUS_ADDR;
1943   1              WORD xdata wKEYSET_BUF_STATUS_ADDR;
1944   1      
1945   1              ucKeyIndex = Flash_GetKeyIndex(ucType, TRUE);//获取“空的”数据的状态位的数据
1946   1              
1947   1              if(ucType == FLASH_KEY_FACTORY)
1948   1              {
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 33  

1949   2                      wKEY_SIZE                               = FACTORY_SIZE;//factory类型的大小
1950   2                      wKEYSET_START                   = FACTORY_START + (WORD)ucKeyIndex*FACTORY_SIZE;//存放的位置
1951   2                      wKEYSET_BUF_START               = FACTORY_BUF_START;//freebuffer中存放数据的位置
1952   2                      wKEYSET_STATUS_ADDR     = FACTORY_STATUS_ADDR + ucKeyIndex;//存放数据状态位的位置
1953   2                      wKEYSET_BUF_STATUS_ADDR = FACTORY_BUF_STATUS_ADDR;//freebuffer中存放数据状态位的位置
1954   2              }
1955   1      #if 0    
                      else if(ucType == FLASH_KEY_GAMMA)
                      {
                              wKEY_SIZE                               = GAMMA_SIZE;
                              wKEYSET_START                   = GAMMA_START + (WORD)ucKeyIndex*GAMMA_SIZE;
                              wKEYSET_BUF_START               = GAMMA_BUF_START;
                              wKEYSET_STATUS_ADDR     = GAMMA_STATUS_ADDR + ucKeyIndex;
                              wKEYSET_BUF_STATUS_ADDR = GAMMA_BUF_STATUS_ADDR;
                      }
              #endif  
1965   1      
1966   1      #if 1//((CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF) && ENABLE_CABLE_5V_EDID)
1967   1              else if(ucType == FLASH_KEY_HDCP)
1968   1              {
1969   2                      wKEY_SIZE                               = HDCPKEY_SIZE;
1970   2                      wKEYSET_START                   = HDCPKEYSET_START + (WORD)ucKeyIndex*HDCPKEY_SIZE;
1971   2                      wKEYSET_BUF_START               = HDCPKEYSET_BUF_START;
1972   2                      wKEYSET_STATUS_ADDR     = HDCPKEY_STATUS_ADDR + ucKeyIndex;
1973   2                      wKEYSET_BUF_STATUS_ADDR = HDCPKEY_BUF_STATUS_ADDR;
1974   2              }
1975   1              else if(ucType == FLASH_KEY_DDCA)
1976   1              {
1977   2                      wKEY_SIZE                               = DDCAKEY_SIZE;
1978   2                      wKEYSET_START                   = DDCAKEYSET_START + (WORD)ucKeyIndex*DDCAKEY_SIZE;
1979   2                      wKEYSET_BUF_START               = DDCAKEYSET_BUF_START;
1980   2                      wKEYSET_STATUS_ADDR     = DDCAKEY_STATUS_ADDR + ucKeyIndex;;
1981   2                      wKEYSET_BUF_STATUS_ADDR = DDCAKEY_BUF_STATUS_ADDR;
1982   2              }
1983   1              else if(ucType == FLASH_KEY_DDCD)
1984   1              {
1985   2                      wKEY_SIZE                               = DDCDKEY_SIZE;
1986   2                      wKEYSET_START                   = DDCDKEYSET_START + (WORD)ucKeyIndex*DDCDKEY_SIZE;
1987   2                      wKEYSET_BUF_START               = DDCDKEYSET_BUF_START;
1988   2                      wKEYSET_STATUS_ADDR     = DDCDKEY_STATUS_ADDR + ucKeyIndex;;
1989   2                      wKEYSET_BUF_STATUS_ADDR = DDCDKEY_BUF_STATUS_ADDR;
1990   2              }
1991   1          else if(ucType == FLASH_KEY_DDCH)
1992   1          {
1993   2              wKEY_SIZE               = DDCHKEY_SIZE;
1994   2              wKEYSET_START           = DDCHKEYSET_START + (WORD)ucKeyIndex*DDCHKEY_SIZE;
1995   2              wKEYSET_BUF_START       = DDCHKEYSET_BUF_START;
1996   2              wKEYSET_STATUS_ADDR     = DDCHKEY_STATUS_ADDR + ucKeyIndex;;
1997   2              wKEYSET_BUF_STATUS_ADDR = DDCHKEY_BUF_STATUS_ADDR;
1998   2          }
1999   1      
2000   1      #else
                      else if(ucType == FLASH_KEY_DDCDP)
                      {
                              wKEY_SIZE                               = DDCDPKEY_SIZE;
                              wKEYSET_START                   = DDCDPKEYSET_START + (WORD)ucKeyIndex*DDCDPKEY_SIZE;
                              wKEYSET_BUF_START               = DDCDPKEYSET_BUF_START;
                              wKEYSET_STATUS_ADDR     = DDCDPKEY_STATUS_ADDR + ucKeyIndex;;
                              wKEYSET_BUF_STATUS_ADDR = DDCDPKEY_BUF_STATUS_ADDR;
                      }
              #endif
2010   1              else
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 34  

2011   1                      return;
2012   1      
2013   1              bFlashWriteFactory = TRUE;
2014   1              //存放数据状态位的位置是空的或可写的
2015   1              if( FlashReadByte( wKEYSET_STATUS_ADDR ) == FLASH_KEY_EMPTY || FlashReadByte( wKEYSET_STATUS_ADDR ) == FL
             -ASH_KEY_WRITE )
2016   1              {
2017   2                      if( wIndex == 0x00 )
2018   2                      {
2019   3                              // FLASH_printData("  _FWFK_StatusAddr [%x] ",wKEYSET_STATUS_ADDR);
2020   3                                                                      //存放数据状态位的位置
2021   3                               FlashWriteByte(TRUE, wKEYSET_STATUS_ADDR, FLASH_KEY_WRITE);//修改buffer状态位
2022   3                  g_wKEYSET_START         = wKEYSET_START;//存放的位置
2023   3                      }
2024   2                      Flash_WriteTbl( TRUE, wKEYSET_START + wIndex * wBufSize, buf, wLen );//将数据存进buffer
2025   2                      if(( wIndex * wBufSize + wLen ) >= wKEY_SIZE ) // 检查是否写完数据
2026   2                      {
2027   3                              FlashWriteByte( TRUE, wKEYSET_STATUS_ADDR, FLASH_KEY_VALID );//给当前这组数据赋有效数据的
             -识
2028   3                              if(ucKeyIndex>0)//如果不止一组数据把上一组数据状态位改为0x00，使它失效
2029   3                                      FlashWriteByte(TRUE, wKEYSET_STATUS_ADDR-1, FLASH_KEY_INVALID);//上组数据失效
2030   3                      }
2031   2              }
2032   1              else
2033   1              {
2034   2                      if( wIndex == 0x00 )
2035   2                      {
2036   3                              FlashSectorErase(TRUE, FLASH_FreeBufferAddr);//数据存满，擦除
2037   3                              FlashWriteByte(TRUE, wKEYSET_BUF_STATUS_ADDR, FLASH_KEY_WRITE);//修改buffer状态位
2038   3                  g_wKEYSET_START         = 0xF000;
2039   3                      }
2040   2                                                              //freebuffer中存放数据的位置
2041   2                      Flash_WriteTbl( TRUE, wKEYSET_BUF_START + wIndex * wBufSize, buf, wLen );//将数据写进buffer
2042   2                      if(( wIndex * wBufSize + wLen ) >= wKEY_SIZE ) // check write end//检测写进去的的数据大小和f
             -actory类型的数据大小是否一致
2043   2                      {
2044   3                                                                      //freebuffer中存放数据状态位的位置
2045   3                              FlashWriteByte( TRUE, wKEYSET_BUF_STATUS_ADDR, FLASH_KEY_VALID );//将buffer的数据的标志位改为
             -0x22（有效）
2046   3                              //FLASH_printData("  _FWFK_buffer write End [%x] ",ucType);
2047   3                              #if 1//((CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF) && ENABLE_CABLE_5V_EDID)
2048   3                      if( ucType >= FLASH_KEY_HDCP && ucType <= FLASH_KEY_DDCH )
2049   3                                      Flash_BackupFactorySetToBuffer( FBufType_HDCP_EDID );
2050   3                              else
2051   3                              #endif
2052   3                                      Flash_BackupFactorySetToBuffer(FBufType_FactorySetting);//将factory的数据搬到buffer，并交换
             -址
2053   3                                      FlashSectorErase( TRUE, FLASH_FreeBufferAddr );
2054   3                              #if 1//((CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF) && ENABLE_CABLE_5V_EDID)
2055   3                              if( ucType >= FLASH_KEY_HDCP && ucType <= FLASH_KEY_DDCH )
2056   3                                      Flash_BackupFactorySetToBuffer( FBufType_HDCP_EDID );
2057   3                              else
2058   3                              #endif
2059   3                                      Flash_BackupFactorySetToBuffer(FBufType_FactorySetting);
2060   3                                      FlashSectorErase( TRUE, FLASH_FreeBufferAddr );    //charles test//擦除buffer
2061   3                      }
2062   2      
2063   2              }
2064   1              bFlashWriteFactory = FALSE;
2065   1      }
2066          
2067          
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 35  

2068          //////////////////////////////////////////////////////////////////////////////
2069          // <API><Description>:  Read HDCP ,DDCA or DDCD key each wLen from flash,
2070          //                                      Need set correct ucType.
2071          //                  wIndex from 0 to (key size / wBufSize) or (key size / wBufSize+1)
2072          //                  The last read wLen = (key size % wBufSize)
2073          // <Returns> : return TRUE when found key ident and CheckSum
2074          // <Parameter>:         -       <Flow>  -       <Description>
2075          // ---------------------------------------------------------------------------
2076          //  ucType          -    In             -       FLASH_KEY_HDCP, FLASH_KEY_DDCA or FLASH_KEY_DDCD
2077          //  wIndex                      -    In         -       From 0 ~ x
2078          //  wBufSize        -    In             -       Size of buf
2079          //  *buf                        -    In         -       point to the data of each set
2080          //  wLen                        -    In         -       Length of this time write buffer, wBufSize>=wLen
2081          //////////////////////////////////////////////////////////////////////////////
2082          /*
2083           *******************************************************************************
2084           * @Description ：从flash读取工厂设置的HDCP 、DDCA或者DDCD key
2085           * @Parameter1 ：ucType -> key类型
2086           * @Parameter2 ：bReadVaild -> 控制位，可以控制当数据无效时是否去读flash
2087           * @Parameter3 ：wIndex -> 偏移倍数
2088           * @Parameter4 ：wBufSize -> buf的大小
2089           * @Parameter5 ：*buf -> 存放数据的buf，指向数据所有设置
2090           * @Parameter6 ：wLen -> 要往buf写多长
2091           ********************************************************************************
2092           */
2093          
2094          Bool Flash_Read_Factory_KeySet(FLASH_KEY_TYPE ucType, Bool bReadVaild, WORD wIndex, WORD wBufSize, BYTE* b
             -uf, WORD wLen)                //110311 Modify
2095          {
2096   1              BYTE xdata ucKeyIndex;
2097   1              WORD xdata wKEY_SIZE;
2098   1              WORD xdata wKEYSET_START;
2099   1              WORD xdata wKEYSET_STATUS_ADDR;
2100   1      
2101   1              if(bReadVaild)
2102   1                      ucKeyIndex = Flash_GetKeyIndex(ucType, FALSE);//有效数据的状态位的位置
2103   1              else
2104   1                      ucKeyIndex = Flash_GetKeyIndex(ucType, TRUE);
2105   1      
2106   1              if( ucType == FLASH_KEY_FACTORY )
2107   1              {
2108   2                      wKEY_SIZE                       = FACTORY_SIZE;//factory类型数据的大小
2109   2                      wKEYSET_START           = FACTORY_START + (WORD)ucKeyIndex*FACTORY_SIZE;//存放的数据位置
2110   2                      wKEYSET_STATUS_ADDR = FACTORY_STATUS_ADDR + ucKeyIndex;//存放数据状态位的位置
2111   2              }
2112   1      #if 0    
                      else if( ucType == FLASH_KEY_GAMMA )
                      {
                              wKEY_SIZE                       = GAMMA_SIZE;
                              wKEYSET_START           = GAMMA_START + (WORD)ucKeyIndex*GAMMA_SIZE;
                              wKEYSET_STATUS_ADDR = GAMMA_STATUS_ADDR + ucKeyIndex;
                      }
              #endif    
2120   1      #if 1//((CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF) && ENABLE_CABLE_5V_EDID)
2121   1      
2122   1              else if(ucType == FLASH_KEY_HDCP)
2123   1              {
2124   2                      wKEY_SIZE                       = HDCPKEY_SIZE;
2125   2                      wKEYSET_START           = HDCPKEYSET_START + (WORD)ucKeyIndex*HDCPKEY_SIZE;
2126   2                      wKEYSET_STATUS_ADDR = HDCPKEY_STATUS_ADDR + ucKeyIndex;
2127   2              }
2128   1              else if( ucType == FLASH_KEY_DDCA )
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 36  

2129   1              {
2130   2                      wKEY_SIZE                       = DDCAKEY_SIZE;
2131   2                      wKEYSET_START           = DDCAKEYSET_START + (WORD)ucKeyIndex*DDCAKEY_SIZE;;
2132   2                      wKEYSET_STATUS_ADDR = DDCAKEY_STATUS_ADDR + ucKeyIndex;
2133   2              }
2134   1              else if( ucType == FLASH_KEY_DDCD )
2135   1              {
2136   2                      wKEY_SIZE               = DDCDKEY_SIZE;
2137   2                      wKEYSET_START           = DDCDKEYSET_START + (WORD)ucKeyIndex*DDCDKEY_SIZE;;
2138   2                      wKEYSET_STATUS_ADDR = DDCDKEY_STATUS_ADDR + ucKeyIndex;
2139   2              }
2140   1              else if( ucType == FLASH_KEY_DDCH )
2141   1              {
2142   2                      wKEY_SIZE               = DDCHKEY_SIZE;
2143   2                      wKEYSET_START           = DDCHKEYSET_START + (WORD)ucKeyIndex*DDCHKEY_SIZE;;
2144   2                      wKEYSET_STATUS_ADDR = DDCHKEY_STATUS_ADDR + ucKeyIndex;
2145   2              }
2146   1      #else
                      else if( ucType == FLASH_KEY_DDCDP )
                      {
                              wKEY_SIZE               = DDCDPKEY_SIZE;
                              wKEYSET_START           = DDCDPKEYSET_START + (WORD)ucKeyIndex*DDCDPKEY_SIZE;;
                              wKEYSET_STATUS_ADDR = DDCDPKEY_STATUS_ADDR + ucKeyIndex;
                      }
              #endif
2154   1              else
2155   1                      return FALSE;
2156   1              //状态位是否为0xaa或0x22，是则将该状态位对应区域的数据读取出来
2157   1              if( FlashReadByte( wKEYSET_STATUS_ADDR ) == FLASH_KEY_WRITE || FlashReadByte( wKEYSET_STATUS_ADDR ) == FL
             -ASH_KEY_VALID )
2158   1              {
2159   2                      //FLASH_printData("  Flash_ReadDDCAKeySet Succ [%x]",wKEYSET_START+i*wKEY_SIZE+1+wIndex*wBufSize);
2160   2                      if(bReadVaild && FlashReadByte(wKEYSET_STATUS_ADDR) != FLASH_KEY_VALID)
2161   2                              return FALSE;
2162   2                      else
2163   2                              Flash_ReadTbl(wKEYSET_START+wIndex*wBufSize, buf, wLen);
2164   2                      
2165   2                      return TRUE;
2166   2              }
2167   1              else
2168   1              {
2169   2                      // FLASH_printData("  Flash_ReadKeySet Fail ucType[%x h]",ucType);
2170   2                      return FALSE;
2171   2              }
2172   1      }
2173          
2174          
2175          
2176          
2177          //////////////////////////////////////////////////////////////////////////////
2178          // <API><Description>:  Write Factory setting to flash,
2179          //                                      It will exchange buffer when not found empty space
2180          //////////////////////////////////////////////////////////////////////////////
2181          void Flash_WriteFactorySet(BYTE* pbuf,BYTE ucLen)
2182          {
2183   1          Flash_Write_Factory_KeySet(FLASH_KEY_FACTORY, 0, FACTORY_SIZE, pbuf, ucLen);
2184   1      }
2185          //////////////////////////////////////////////////////////////////////////////
2186          // <API><Description>:  Read latest factory setting struct from flash.
2187          // <Returns> : return TRUE when found factory setting
2188          //////////////////////////////////////////////////////////////////////////////
2189          //调Flash_Read_Factory_KeySet函数读数据，读到数据返回ture，没读到false；读到的数据
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 37  

             -到pbuf，读ucLen个数据
2190          Bool Flash_ReadFactorySet(BYTE* pbuf,BYTE ucLen)
2191          {
2192   1          return Flash_Read_Factory_KeySet(FLASH_KEY_FACTORY, TRUE, 0, FACTORY_SIZE, pbuf, ucLen);    //110311 Modi
             -fy
2193   1      }
2194          //////////////////////////////////////////////////////////////////////////////
2195          // <API><Description>:  Write Monitor setting struct to flash,
2196          //                                      It will exchange buffer when buffer full
2197          //////////////////////////////////////////////////////////////////////////////
2198          //查找Ident和CheckSum 位置为FLASH_EMPTYDATA (0xFF)的地址，得到一个没有被写过的地址In
             -dex,
2199          //如果能找到这样一个Index,调用Flash_WriteTbl把MonitorSetting写入相应的地址，并把上
             -组保存在Flash中
2200          //的Ident值写成FLASH_IDENTDATA_CLEAR (0x00)。
2201          //注意事项：第一步如果不能找到这样一个Index,说明MonitorSetting区域已经写满了，
             -不能再写入。
2202          //调用FlashSectorErase 擦除FreeBuffer区，把MonitorSetting 一组值保存在FreeBuffer。(擦除Fre
             -eBuffer区这一步很重要)
2203          //交换FreeBuffer和MonitorSetting区：把FreeBuffer区第一个Byte值写成FBufType_MonitorSetting (0x
             -88)，把MonitorSettin区0x88写成0x00，
2204          //把FreeBufferAddr赋值给MonitorSettingAddr，把原来的MonitorSettingAddr赋值给FreeBufferAddr，
             -现两个区块交换.
2205          void Flash_WriteMonitorSet(BYTE* buf,BYTE len)
2206          {
2207   1              WORD wAddr;
2208   1              WORD i;
2209   1      
2210   1          i = Flash_SearchIdentChecksum(MONITORSET_START, 0, MAX_MONITORSET_NUM-1, MONITORSET_SIZE, FLASH_EMPTYD
             -ATA, FLASH_EMPTYDATA);
2211   1          if(i != IDENT_NOT_FOUND)// Found the empty index
2212   1          {
2213   2              //MonitorSetting.Ident= FLASH_IDENTDATA;
2214   2              //MonitorSetting.CheckSum       = FLASH_CHECKSUM;
2215   2              wAddr = MONITORSET_START + i*MONITORSET_SIZE;
2216   2                      Flash_WriteTbl(TRUE, wAddr, (BYTE*)buf, len);
2217   2                      FLASH_printData("_FWMS_0 wAddr %x",wAddr);
2218   2              if(i>0)
2219   2              {
2220   3                  wAddr = MONITORSET_START + (i-1)*MONITORSET_SIZE;//并把上一组保存在Flash中的Ident值
             -写成FLASH_IDENTDATA_CLEAR (0x00)。
2221   3                  FlashWriteByte(TRUE, wAddr,FLASH_IDENTDATA_CLEAR);
2222   3              }
2223   2          }
2224   1          else
2225   1          {
2226   2                      FlashSectorErase(TRUE, FLASH_FreeBufferAddr);//擦除FreeBuffer区
2227   2                      Flash_WriteTbl(TRUE, MONITORSET_BUF_START, (BYTE*)buf, len);//把MonitorSetting 一组值保存在FreeBu
             -ffer
2228   2                      FLASH_printData("_FWMS_1 wAddr %x",MONITORSET_BUF_START);
2229   2                      FLASH_printData("FLASH_FreeBufferAddr11 wAddr %x",FLASH_FreeBufferAddr);
2230   2                      FlashWriteByte(TRUE, FLASH_FreeBufferAddr,FBufType_MonitorSetting);//把FreeBuffer区第一个Byte值写
             -成FBufType_MonitorSetting (0x88)
2231   2                      FlashWriteByte(TRUE, FLASH_MonitorSettingAddr,0x00);
2232   2                      wAddr = FLASH_FreeBufferAddr;
2233   2                      FLASH_FreeBufferAddr = FLASH_MonitorSettingAddr;
2234   2                      FLASH_MonitorSettingAddr = wAddr;
2235   2          }
2236   1      }
2237          //////////////////////////////////////////////////////////////////////////////
2238          // <API><Description>:  Read latest Monitor setting struct from flash.
2239          //                                      1.Got monitor setting index by check flash identity
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 38  

2240          //                                      2.If not found read CheckSum to got correct one
2241          //                                      3.read the Monitor setting struct
2242          // <Returns> : return TRUE when found MonitorSetting
2243          //////////////////////////////////////////////////////////////////////////////
2244          //从闪存读取最新的监控设置结构。
2245          //1.通过检查闪存身份获取监控设置索引
2246          //2.如果未找到，读取 CheckSum 以获取正确的索引
2247          //3.读取监控设置结构
2248          Bool Flash_ReadMonitorSet(BYTE* buf,BYTE len)
2249          {
2250   1          WORD i;
2251   1      
2252   1          i = Flash_SearchIdentChecksum(MONITORSET_START, (MAX_MONITORSET_NUM-1), 0, MONITORSET_SIZE, FLASH_IDEN
             -TDATA, FLASH_CHECKSUM);
2253   1          if(i != IDENT_NOT_FOUND)    //找到则将其读出来
2254   1          {
2255   2              Flash_ReadTbl(MONITORSET_START + i*MONITORSET_SIZE, buf, len);
2256   2              FLASH_printData("_FRMS_ wAddr %x",MONITORSET_START + i*MONITORSET_SIZE);
2257   2              return TRUE;
2258   2          }
2259   1          else//第一次找不到，第二次查找
2260   1          {
2261   2              i = Flash_SearchIdentChecksum(MONITORSET_START, (MAX_MONITORSET_NUM-1), 0, MONITORSET_SIZE, FLASH_
             -IDENTDATA_CLEAR, FLASH_CHECKSUM);
2262   2              if(i != IDENT_NOT_FOUND)
2263   2              {
2264   3                      Flash_ReadTbl(MONITORSET_START + i*MONITORSET_SIZE, buf, len);
2265   3               //   FLASH_printMsg("_FRMS_ Only Checksum Correct! ");
2266   3              //      FLASH_printData("_FRMS_ wAddr %x",MONITORSET_START + i*MONITORSET_SIZE);
2267   3                  return TRUE;
2268   3              }
2269   2              else
2270   2                  return FALSE;
2271   2          }
2272   1      }
2273          
2274          
2275          //////////////////////////////////////////////////////////////////////////////
2276          // <API><Description>:  Flash_WriteMonitorSet2 isues to save MonitorSetting2
2277          //                                      It will exchange buffer when buffer full
2278          //////////////////////////////////////////////////////////////////////////////
2279          
2280          void Flash_WriteMonitorSet2(BYTE* buf,BYTE len)
2281          {
2282   1              WORD wAddr;
2283   1              WORD i;
2284   1      
2285   1          i = Flash_SearchIdentChecksum(MONITORSET2_START, 0, MAX_MONITORSET2_NUM-1, MONITORSET2_SIZE, FLASH_EMP
             -TYDATA, FLASH_EMPTYDATA);
2286   1          if(i != IDENT_NOT_FOUND)
2287   1          {
2288   2                      wAddr = MONITORSET2_START + i*MONITORSET2_SIZE;
2289   2                      Flash_WriteTbl(TRUE, wAddr, (BYTE*)buf, len);
2290   2                      //FLASH_printData("_FWMS2_ wAddr %x",wAddr);
2291   2          }
2292   1          else
2293   1          {
2294   2                      FlashSectorErase(TRUE, FLASH_FreeBufferAddr);
2295   2                      Flash_WriteTbl(TRUE, MONITORSET2_BUF_START, (BYTE*)buf, len);
2296   2                      //FLASH_printData("_FWMS2_ wAddr %x",MONITORSET2_BUF_START);
2297   2                      FlashWriteByte(TRUE, FLASH_FreeBufferAddr,FBufType_MonitorSetting2);
2298   2                      FlashWriteByte(TRUE, FLASH_MonitorSetting2Addr,0x00);
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 39  

2299   2                      wAddr = FLASH_FreeBufferAddr;
2300   2                      FLASH_FreeBufferAddr = FLASH_MonitorSetting2Addr;
2301   2                      FLASH_MonitorSetting2Addr = wAddr;
2302   2          }
2303   1      }
2304          /*
2305           ********************************************************************
2306           * @Description ：读保存在Flash背光数据的函数
2307           * @Parameter1 ：存数据的buf
2308           * @Parameter2 ：要读的长度
2309           ********************************************************************
2310           */
2311          
2312          //////////////////////////////////////////////////////////////////////////////
2313          // <API><Description>:  Read MonitorSetting2 struct from flash.
2314          //                                      1.Got monitor setting index by check flash identity
2315          // <Returns> : return TRUE when found MonitorSetting2
2316          //////////////////////////////////////////////////////////////////////////////
2317          Bool Flash_ReadMonitorSet2(BYTE* buf,BYTE len)
2318          {
2319   1          Bool bFound=FALSE;
2320   1              WORD i;
2321   1      
2322   1          i = Flash_SearchIdentChecksum(MONITORSET2_START, (MAX_MONITORSET2_NUM-1), 0, MONITORSET2_SIZE, FLASH_I
             -DENTDATA, FLASH_CHECKSUM);
2323   1          if(i != IDENT_NOT_FOUND)
2324   1          {
2325   2              Flash_ReadTbl(MONITORSET2_START + i*MONITORSET2_SIZE, buf, len);
2326   2              //FLASH_printData("_FRMS2_ wAddr %x",MONITORSET2_START + i*MONITORSET2_SIZE);
2327   2              return TRUE;
2328   2          }
2329   1          else
2330   1          {
2331   2              FLASH_printMsg("  Flash_ReadMonitorSet2 Fail");
2332   2              return FALSE;
2333   2          }
2334   1      }
2335          
2336          
2337          //////////////////////////////////////////////////////////////////////////////
2338          // <API><Description>:  Check exit timing mode number and compare to MAX_MODESET_NUM.
2339          // <Returns> : return TRUE when saved timing mode size equal to MAX_MODESET_NUM
2340          //////////////////////////////////////////////////////////////////////////////
2341          Bool Flash_CheckModeFull(void)
2342          {
2343   1          BYTE i,wExitModeCount=0;
2344   1          //check buffer full
2345   1              for(i=0;i < MAX_MODESET_NUM; i++)
2346   1              {
2347   2                      if(FlashReadByte(MODESET_START+i*MODESET_SIZE)==FLASH_IDENTDATA && FlashReadByte(MODESET_START+i*MODESET
             -_SIZE+MODESET_SIZE-1)==FLASH_CHECKSUM)
2348   2                  wExitModeCount++;
2349   2          }
2350   1          if(wExitModeCount == MAX_MODESET_NUM)
2351   1              return TRUE;
2352   1          else
2353   1              return FALSE;
2354   1      }
2355          //////////////////////////////////////////////////////////////////////////////
2356          // <API><Description>:  Clear all user mode ident.
2357          //
2358          //////////////////////////////////////////////////////////////////////////////
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 40  

2359          void Flash_ClearUserModeSpace(void)
2360          {
2361   1          BYTE i,ucIdent=0;
2362   1          //check buffer full
2363   1              for(i=0;i < MAX_MODESET_NUM; i++)
2364   1              {
2365   2                  ucIdent = FlashReadByte(MODESET_START+i*MODESET_SIZE);
2366   2                      if(ucIdent == FLASH_IDENTDATA)
2367   2              {
2368   3                              if((FlashReadByte(MODESET_START+i*MODESET_SIZE+1)&0x80)==0x80)
2369   3                      FlashWriteByte(TRUE, MODESET_START+i*MODESET_SIZE, 0x00); // Clear Identdata.
2370   3              }
2371   2          }
2372   1              FLASH_printMsg("Flash_ClearUserModeSpace");
2373   1      }
2374          
2375          //////////////////////////////////////////////////////////////////////////////
2376          // <API><Description>:  Write timing mode with index to flash
2377          //                                      1.Search the timing mode from timing buffer
2378          //                                      2.Clear the timing ident
2379          //                                      3.Find empty timing mode bufer
2380          //                                      4.Exchange buffer if FLASH_TimingModeAddr buffer full
2381          //                                      5.Write timing struct to empty buffer
2382          // <Parameter>:         -       <Flow>  -       <Description>
2383          // ---------------------------------------------------------------------------
2384          //  index                       -    In         -       timing index, UserMode need |_BIT7 in index
2385          //  *buf                        -    In         -       point to the address of timing struct
2386          //////////////////////////////////////////////////////////////////////////////
2387          void Flash_WriteModeSet(BYTE index,BYTE *buf)
2388          {
2389   1              WORD i=0, j=0;
2390   1              WORD wAddr;
2391   1              xdata ModeSettingType modeSetting;
2392   1      
2393   1              //FLASH_printData("_FWMS_ Target index 0x%x",index);
2394   1          // find orginal mode index in flash
2395   1              for(i=0;i < MAX_MODESET_NUM; i++)//从第0组开始查找整个ModeSetting区的各组Mode数据
2396   1              {       //读取各组有效的Mode数据,查找是否已有保存此Mode
2397   2                      if(FlashReadByte(MODESET_START+i*MODESET_SIZE)==FLASH_IDENTDATA && FlashReadByte(MODESET_START+i*MODESET
             -_SIZE+MODESET_SIZE-1)==FLASH_CHECKSUM)
2398   2                      {
2399   3                              if(FlashReadByte(MODESET_START+i*MODESET_SIZE+1)==index)//若存在此Mode
2400   3                              {
2401   4                                      FlashWriteByte(TRUE, MODESET_START+i*MODESET_SIZE, 0x00); // Clear Identdata.//把已存在的相同Mo
             -de的Ident写成0x00
2402   4                                      FLASH_printData("_FWMS_ Clear index %x",i);
2403   4                              }
2404   3                      }
2405   2              }
2406   1      
2407   1          // find empty position
2408   1          //把最新的一组Mode数据写入找到的空余空间位置
2409   1          i = Flash_SearchIdentChecksum(MODESET_START, 0, (MAX_MODESET_NUM-1), MODESET_SIZE, FLASH_EMPTYDATA, FL
             -ASH_EMPTYDATA);
2410   1          if(i != IDENT_NOT_FOUND)//若有保存空间
2411   1          {
2412   2              FLASH_printData("_FWMS_ write to empty Addr %x",MODESET_START+i*MODESET_SIZE);
2413   2              Flash_WriteTbl(TRUE, MODESET_START+i*MODESET_SIZE, buf, MODESET_SIZE);
2414   2          }
2415   1          else
2416   1          {   
2417   2              if(Flash_CheckModeFull())//检查Mode有效数据是否存满
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 41  

2418   2                  Flash_ClearUserModeSpace();//若存满，则释放UserMode空间(将UserMode Ident写成0x00)
2419   2      
2420   2              FlashSectorErase(TRUE, FLASH_FreeBufferAddr);//擦除FreeBuffer空间
2421   2                      for(i=0;i < MAX_MODESET_NUM; i++)//从第0组开始查找整个ModeSetting区的各组Mode数据
2422   2                      {       
2423   3                      //依次把Ident为0x55和CheckSum为0xAA的有效数据保存到FreeBuffer空间
2424   3                              if(FlashReadByte(MODESET_START+i*MODESET_SIZE)==FLASH_IDENTDATA  && FlashReadByte(MODESET_START+i*MODES
             -ET_SIZE+MODESET_SIZE-1)==FLASH_CHECKSUM)
2425   3                              {
2426   4                                      Flash_ReadTbl(MODESET_START+i*MODESET_SIZE, (BYTE*)&modeSetting, MODESET_SIZE);
2427   4                                      Flash_WriteTbl(TRUE, MODESET_BUF_START+j*MODESET_SIZE, (BYTE*)&modeSetting, MODESET_SIZE);
2428   4                                      j++;
2429   4                              }
2430   3                      }
2431   2              if(j < (MAX_MODESET_NUM-1))// 将要保存的mode数据存在FreeBuffer区的有效mode数据后
2432   2              {
2433   3                  FLASH_printData("_FWMS_ write to empty Addr %x",MODESET_BUF_START+j*MODESET_SIZE);
2434   3                  Flash_WriteTbl(TRUE, MODESET_BUF_START+j*MODESET_SIZE, buf, MODESET_SIZE);
2435   3              }
2436   2      
2437   2              //      Exchange Buffer
2438   2                      FlashWriteByte(TRUE, FLASH_FreeBufferAddr,FBufType_TimingMode);//保存完后，把FreeBuffer空间设
             -成ModeSetting空间,交换地址
2439   2                      FlashWriteByte(TRUE, FLASH_TimingModeAddr,0x00);
2440   2                      wAddr = FLASH_FreeBufferAddr;
2441   2                      FLASH_FreeBufferAddr = FLASH_TimingModeAddr;
2442   2                      FLASH_TimingModeAddr = wAddr;
2443   2                      //i=j;//Write empty one index
2444   2      
2445   2                      FLASH_printData("_FWMS_ Buffer exchange TimingAddr %x ",(WORD)(FLASH_TimingModeAddr>>8));
2446   2                      FLASH_printData("_FWMS_ Buffer exchange FreeAddr %x ",(WORD)(FLASH_FreeBufferAddr>>8));
2447   2          }
2448   1      }
2449          
2450          
2451          //////////////////////////////////////////////////////////////////////////////
2452          // <API><Description>:  Read timing mode with index from flash
2453          //                                      1.Search the timing mode from timing buffer by compare FLASH_IDENTDATA&TimingIndex
2454          //                                      2.No update & return when not found
2455          //                                      3.Read timing mode from buffer
2456          //                                      4.upper level function check timing mode FLASH_IDENTDATA to makesure
2457          // <Returns> : return TRUE when found the timing mode index
2458          // <Parameter>:         -       <Flow>  -       <Description>
2459          // ---------------------------------------------------------------------------
2460          //  index                       -    In         -       timing index, UserMode need |_BIT7 in index
2461          //  *buf                        -    In         -       point to the address of timing mode struct
2462          //////////////////////////////////////////////////////////////////////////////
2463          Bool Flash_ReadModeSet(BYTE index,BYTE *buf)
2464          {
2465   1          WORD i;
2466   1      
2467   1          for(i=0;i < MAX_MODESET_NUM; i++)//从第0组开始查找整个ModeSetting区的各组Mode数据
2468   1          {
2469   2              if(FlashReadByte(MODESET_START+i*MODESET_SIZE)==FLASH_IDENTDATA
2470   2                  && FlashReadByte(MODESET_START+i*MODESET_SIZE+MODESET_SIZE-1)==FLASH_CHECKSUM
2471   2                  && FlashReadByte(MODESET_START+i*MODESET_SIZE+1)==index)
2472   2              {
2473   3                  break;
2474   3              }
2475   2          }
2476   1      
2477   1          if(i >= MAX_MODESET_NUM)//未找到 185次
C51 COMPILER V9.01   MSFLASH                                                               08/17/2023 10:55:22 PAGE 42  

2478   1          {
2479   2              FLASH_printMsg("_FRMS_ RModeSet Not Found");
2480   2              return FALSE;
2481   2          }
2482   1      
2483   1              FLASH_printData("_FRMS_ RModeSet=%x",i);
2484   1              FLASH_printData("_FRMS_ ModeR=%x",(MODESET_START+i*MODESET_SIZE)&0xFFFF);
2485   1              Flash_ReadTbl(MODESET_START+i*MODESET_SIZE, buf, MODESET_SIZE);//将对应的mode读取出来
2486   1          return TRUE;
2487   1      }
2488          
2489          #endif//USEFLASH
2490          
2491          
2492          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8030    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     19      41
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----     132
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       5
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
