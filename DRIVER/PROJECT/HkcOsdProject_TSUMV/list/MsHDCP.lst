C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MSHDCP
OBJECT MODULE PLACED IN .\obj\MsHDCP.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\MsHDCP.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC;
                    -..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL\
                    -SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\I
                    -NC) DEFINE(ModelName=MODEL_T24_TCL) DEBUG OBJECTEXTEND PRINT(.\list\MsHDCP.lst) OBJECT(.\obj\MsHDCP.obj)

line level    source

   1          #define _MSHDCP_C_
   2           #include "board.h"
*** MESSAGE C320 IN LINE 337 OF ..\..\CONFIG\BOARD.H: "Please remember to disable the debug function!" 
   3          #if ENABLE_HDCP
   4              #include "types.h"
   5              #include "ms_reg.h"
   6                  #include "ms_rwreg.h"
   7          #include "Common.h"
   8          #include "misc.h"
   9              #include "global.h"
  10              #include "userpref.h"
  11              #include "debug.h"
  12              #include "msflash.h"
  13          #include "NvRam.h"
  14          // Internal
  15              #include "msHDCP.h"
  16          #if ENABLE_MHL
              //extern xdata MHLInfo_S gMHLInfo;
              #include "DRVMHL.h"
              #endif
  20          #if CHIP_ID >= CHIP_TSUMC
              #include "msEread.h"
              #endif
  23          #include "GPIO_DEF.h"
  24          #define HDCP_DEBUG 0
  25          #if ENABLE_DEBUG && HDCP_DEBUG
              #define HDCP_printData(str, value)   printData(str, value)
              #define HDCP_printMsg(str)           printMsg(str)
              #else
  29          #define HDCP_printData(str, value)
  30          #define HDCP_printMsg(str)
  31          #endif
  32          
  33          
  34              #if (!Init_HDCPKey)
  35          #message "Please remember to disable the default HDCP key!"
*** MESSAGE C320 IN LINE 35 OF ..\..\KERNEL\SCALER\MsHDCP.c: "Please remember to disable the default HDCP key!"
  36          #else
              #message "Please remember to Õ‚…’KEY!"
              #endif
  39              #if (!Init_HDCPKey)
  40                  BYTE code BKSV[5] = 
  41                  {
  42                      0x89, 0x38, 0xae, 0x0d, 0xed
  43                  };
  44                  //////////////////////////////////////////////////////////////
  45                  // HDCP production key
  46                  //////////////////////////////////////////////////////////////
  47          BYTE code HDCPkey[] =
  48          {
  49              0x00,0xE6,0xD2,0xD0,0xA4,0x0A,0xF9,0xAB,0x2F,0x9A,0x2D,0x3A,
  50              0xB5,0xFF,0x9D,0x37,0xB3,0x63,0x23,0x6E,0xA3,0x4E,0x58,0xEF,
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 2   

  51              0xD2,0x78,0x6D,0x3B,0xDE,0xFD,0x7E,0x4D,0xAA,0xB6,0x0C,0x59,
  52              0x4F,0x74,0x3C,0xF8,0xDA,0x65,0x6E,0x2F,0xB4,0xAB,0xAD,0x7F,
  53              0x89,0xA1,0x92,0x25,0x1A,0xCD,0x50,0x93,0x50,0x00,0x63,0x88,
  54              0x7B,0xD0,0xD8,0x4D,0x46,0x95,0xA8,0xFC,0x9B,0x0D,0xD1,0x08,
  55              0x06,0xB2,0x67,0xBE,0xA2,0x90,0xA7,0x84,0x2A,0x4B,0x28,0xC8,
  56              0xDD,0x8F,0xC9,0x48,0xA3,0x0A,0x7D,0xCA,0xDA,0xBC,0xCE,0xFA,
  57              0x9B,0x9F,0x61,0x90,0x9E,0x46,0x24,0x2B,0xA6,0x7B,0xB1,0x6F,
  58              0xC4,0x4C,0x63,0xAF,0x44,0xE1,0x3A,0xDD,0x0D,0xED,0xF4,0x45,
  59              0x36,0x47,0x0B,0x48,0x0A,0xB1,0xE6,0xE9,0xB6,0xED,0x78,0x37,
  60              0xDC,0xB0,0x07,0x72,0x83,0xDC,0x73,0x26,0x31,0x49,0x03,0x52,
  61              0x7C,0xE6,0xC6,0xE8,0x3C,0xD1,0x62,0xFE,0xF0,0x01,0x73,0x23,
  62              0x90,0x70,0xA9,0x52,0x8C,0x75,0x1C,0xE5,0x63,0x7C,0xA9,0x98,
  63              0x5F,0xD9,0x7C,0x62,0x25,0x6C,0x61,0x6C,0xB5,0xF9,0xDB,0xD8,
  64              0x91,0x2F,0x25,0xF6,0x3E,0x37,0xBE,0xE2,0x92,0x08,0x07,0x3C,
  65              0xE6,0xC9,0xE3,0xB0,0x4D,0xF6,0xAD,0x54,0x3C,0xED,0x92,0x5A,
  66              0x97,0x93,0xC0,0x48,0xEA,0x23,0x6C,0xDD,0x9A,0x00,0xBA,0xF1,
  67              0xB4,0xE7,0x7E,0x84,0x9A,0xB5,0xD5,0xF4,0xB0,0x42,0x49,0x5E,
  68              0x15,0x5A,0x43,0x2D,0xA9,0xB0,0x0A,0x1C,0x75,0xDE,0x2E,0x08,
  69              0xF7,0xDF,0x38,0x03,0xEB,0x6A,0x75,0xEB,0xDA,0x1C,0xA0,0xC9,
  70              0x2F,0x2A,0x69,0x3F,0x13,0xFB,0xA4,0x23,0x0A,0xE5,0x0A,0xA5,
  71              0xEF, 0xCC, 0x8D, 0xB6, 0x5E, 0x6C, 0xB6, 0xE8, 0x84, 0xEF, 0x03, 0xDC,
  72              0xC5, 0x8A, 0xA3, 0x4B, 0xEF, 0x44, 0x12, 0x7F
  73          };
  74          #endif
  75          // 2005/6/3 0:11AM by Emily 
  76          //*********************************************************
  77          // HDCP BKSV key
  78          //*********************************************************
  79          void msInitHDCPProductionKey(void)
  80          {
  81   1              BYTE ucValue;
  82   1              WORD wCount;
  83   1      
  84   1              // prevent complier warning
  85   1      #if (CHIP_ID==CHIP_TSUMC)||(CHIP_ID==CHIP_TSUMD)||(CHIP_ID==CHIP_TSUMF)
                      Bool bHDCPKeyInEfuse = FALSE;
                      WORD wChecksum = 0, wEfuseChecksum = 0;
                  
                      msEread_SetComboInitialValue();
                      bHDCPKeyInEfuse = msEread_IsHDCPKeyInEfuse();
                  if(bHDCPKeyInEfuse)
                      HDCP_printMsg("HDCP key in Efuse\n");
              #endif
  94   1      
  95   1      #if (CHIP_ID == CHIP_TSUM9 ) // cannot load key from efuse
                  Bool bHDCPKeyInEfuse = FALSE; 
                  WORD wChecksum = 0, wEfuseChecksum = 0;
              #endif
  99   1      
 100   1      #if (CHIP_ID==CHIP_TSUMC)||(CHIP_ID==CHIP_TSUMD)||(CHIP_ID==CHIP_TSUM9)||(CHIP_ID==CHIP_TSUMF)
                      DVI_RELATED_CLOCK_CTRL_0(0xFFFF, 0xFFFF);
                      DVI_RELATED_CLOCK_CTRL_1(0x3FFF, 0x3FFF);
              #else
 104   1              DVI_RELATED_CLOCK_CTRL(0, 0x601); //msWrite2ByteMask( REG_290C, 0, 0x601 ); // HDCP related power 
             -power down
 105   1      #endif
 106   1          
 107   1      #if (CHIP_ID==CHIP_TSUMC)||(CHIP_ID==CHIP_TSUMD) ||(CHIP_ID==CHIP_TSUM9)||(CHIP_ID==CHIP_TSUMF) //&& ENABL
             -E_XIU_WRITE_KEY
              
                  //Bksv need to write in 74REG for HDMI/DVI
                  HDCP_CPU_WRITE_BKSV_START();
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 3   

              
                  for( wCount = 0; wCount < 5; wCount++ )
                  {
              #if !Init_HDCPKey
                      ucValue = BKSV[wCount];
                      if(bHDCPKeyInEfuse)
                      {
                          ucValue = msEread_GetHDCPKeyFromEfuse(wCount);
                          wChecksum += ucValue;
                          //printData("Efuse = 0x%x\n", ucValue);
                      }
              #else
              #if HDCPKEY_IN_Flash
                      //Flash_Read_Factory_KeySet( FLASH_KEY_HDCP, TRUE, wCount, 1, &ucValue, 1 );
                                      #if ENABLE_USE_ISPTOOL_Write_HDCP
                                      ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+ BKSVDataAddr + wCount );    //120105 Modify
                                      //printData("TmpValue=[0-5]===%x", TmpValue);
                                      #else
                                      ucValue = FlashReadByte( HDCPKEYSET_START+ BKSVDataAddr+wCount);
                                      #endif
              
              #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR1 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
              #endif
              #endif
              
                      HDCP_CPU_WRITE_BKSV(wCount, ucValue); // write data and trigger latch data
                      while(HDCP_CPU_WR_BUSY()); // wait ready
                  }
              
                  // First 5 bytes is BKSV only use for DP port.
                  HDCP_CPU_WRITE_ENABLE(0xC0, 0xC0); //[7]Enable CPU write, [6]Access SRAM
                  HDCP_XIU_WRITE_KEY_ENABLE(); //Access Key SRAM through XIU.
                  for( wCount = 0; wCount < 5; wCount++ )
                  {
                  #if !Init_HDCPKey
                      ucValue = BKSV[wCount];
                      if(bHDCPKeyInEfuse)
                      {
                          ucValue = msEread_GetHDCPKeyFromEfuse(wCount);
                      }
                  #else
                      #if HDCPKEY_IN_Flash
                      //Flash_Read_Factory_KeySet( FLASH_KEY_HDCP, TRUE, wCount, 1, &ucValue, 1 );
                                      #if ENABLE_USE_ISPTOOL_Write_HDCP
                                      ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+ BKSVDataAddr + wCount );    //120105 Modify
                                      //printData("TmpValue=[0-5]===%x", TmpValue);
                                      #else
                                      ucValue = FlashReadByte( HDCPKEYSET_START+ BKSVDataAddr+wCount);
                                      #endif
                      #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR1 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
                      #endif
                  #endif
              
                      HDCP_XIU_WRITE_KEY(ucValue);
              #if ((CHIP_ID==CHIP_TSUMC)||(CHIP_ID==CHIP_TSUMD) ||(CHIP_ID==CHIP_TSUM9)||(CHIP_ID==CHIP_TSUMF)) //130912
             - nick add follow trunk//&& ENABLE_XIU_WRITE_KEY       
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 4   

                      msWriteByte( REG_06A0 + wCount, ucValue );           //Off-Line Key
                      msWriteByte( REG_07A0 + wCount, ucValue );           //Off-LineKey 
              #endif          
                  }
              
                  for( wCount = 0; wCount < 284; wCount++ )
                  {
                  #if !Init_HDCPKey
                      ucValue = HDCPkey[wCount] ;
                      if(bHDCPKeyInEfuse)
                      {
                          ucValue = msEread_GetHDCPKeyFromEfuse(wCount+5);
                          wChecksum += ucValue;
                          //printData("Efuse = 0x%x\n", ucValue);
                      }
                  #else
                      #if HDCPKEY_IN_Flash
                                #if ENABLE_USE_ISPTOOL_Write_HDCP
                              ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+HDCPKetAddr + wCount );      //120105 Modify
                                      //printData("TmpValue=[284]===%x", TmpValue);
                              #else
                              ucValue=FlashReadByte( HDCPKEYSET_START+HDCPKetAddr+wCount);
                      #endif
                      //Flash_Read_Factory_KeySet( FLASH_KEY_HDCP, TRUE, wCount + HDCPKetAddr, 1, &ucValue, 1 );
                      #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR2 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
                      #endif
                  #endif
              
                      HDCP_XIU_WRITE_KEY(ucValue); // write data and trigger latch data
                  }
                  HDCP_XIU_WRITE_KEY_DISABLE();
              
                  if(bHDCPKeyInEfuse)
                  {
                      if(msEread_CompareHDCPChecksumInEfuse(wChecksum))
                          HDCP_printMsg("Efuse Checksum match ^^ \n");
                      else
                      {
                          HDCP_printMsg("Efuse Checksum wrong @@ \n");
                          HDCP_printData("Calculate checksum = 0x%x\n", wChecksum);
                          HDCP_printData("Efuse checksum = 0x%x\n", wEfuseChecksum);
                      }
                  }
              
              
              #else   //2 u
 221   1          HDCP_CPU_WRITE_BKSV_START();  
 222   1              for( wCount = 0; wCount < 5; wCount++ )
 223   1              {
 224   2      #if !Init_HDCPKey
 225   2              ucValue = BKSV[wCount];
 226   2      #else
                      #if HDCPKEY_IN_Flash
                                      #if ENABLE_USE_ISPTOOL_Write_HDCP
                                      ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+ BKSVDataAddr + wCount );    //120105 Modify
                                      //printData("TmpValue=[0-5]===%x", TmpValue);
                                      #else
                                      ucValue = FlashReadByte( HDCPKEYSET_START+ BKSVDataAddr+wCount);
                                      #endif
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 5   

                      #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR1 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
                      #endif
                  #endif
 240   2      
 241   2              HDCP_CPU_WRITE_BKSV(wCount, ucValue); // write data and trigger latch data
 242   2              while(HDCP_CPU_WR_BUSY()); // wait ready
 243   2          }
 244   1      
 245   1          HDCP_CPU_WRITE_ENABLE(0xC0, 0xC0); //[15]: CPU write enable, [14]: 0: 74 RAM, 1 :HDCP RAM
 246   1          HDCP_CPU_RW_ADDRESS(0); //address
 247   1          HDCP_LOAD_ADDR_GEN_PULSE(); // trigger latch address
 248   1          
 249   1              for( wCount = 0; wCount < 284; wCount++ )
 250   1              {
 251   2      #if !Init_HDCPKey
 252   2              ucValue = HDCPkey[wCount] ;
 253   2      #else
                      #if HDCPKEY_IN_Flash
                                #if ENABLE_USE_ISPTOOL_Write_HDCP
                              ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+HDCPKetAddr + wCount );      //120105 Modify
                                      //printData("TmpValue=[284]===%x", TmpValue);
                              #else
                              ucValue=FlashReadByte( HDCPKEYSET_START+HDCPKetAddr+wCount);
                                #endif
                      #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR2 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
              #endif
                  #endif
 267   2              
 268   2              HDCP_CPU_WRITE_DATA(ucValue); // write data and trigger latch data
 269   2              while(HDCP_CPU_WR_BUSY()); // wait ready
 270   2          }
 271   1      
 272   1      #endif //CHIP_ID==CHIP_TSUMC && ENABLE_XIU_WRITE_KEY
 273   1      
 274   1      //========================//
 275   1          //Bcaps=0x00 or 0x80
 276   1      #if ENABLE_HDMI
                  HDCP_CPU_WRITE_BCAPS(0x80); // HDCP data
              #else
 279   1          HDCP_CPU_WRITE_BCAPS(0); // HDCP data
 280   1      #endif
 281   1      
 282   1          HDCP_CPU_WRITE_ENABLE(0, 0xC0); //msWriteByteMask( REG_28F3, 0x00, 0xC0 ); //[15]: CPU write disable, 
             -[14]: 0: 74 RAM, 1 :HDCP RAM
 283   1          HDCP_MISC_SETTING(0x721); //msWrite2Byte( REG_28C0, 0x0721 ); // [10:8]: 3'b111 determine Encrp_En dur
             -ing Vblank in DVI mode; [5]:HDCP enable; [0]: EESS mode deglitch Vsync mode
 284   1          HDCP_ENABLE_DDC(); // [10]: HDCP enable DDC
 285   1      
 286   1      #if CHIP_ID==CHIP_TSUMU && (ENABLE_DUAL_LINK||(HDMI_PORT&(TMDS_PORT_B|TMDS_PORT_C)))
                      //Bksv
                      for(wCount=0; wCount<5; wCount++)
                      {
              #if !Init_HDCPKey
                      ucValue = BKSV[wCount];
                      #else
                      #if HDCPKEY_IN_Flash
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 6   

                                      #if ENABLE_USE_ISPTOOL_Write_HDCP
                                      ucValue = FlashReadHDCPByte( IspWriteHDCPkey_Addre+ BKSVDataAddr + wCount );    //120105 Modify
                                      //printData("TmpValue=[0-5]===%x", TmpValue);
                                      #else
                                      ucValue = FlashReadByte( HDCPKEYSET_START+ BKSVDataAddr+wCount);
                                      #endif
                      //Flash_Read_Factory_KeySet( FLASH_KEY_HDCP, TRUE, wCount, 1, &ucValue, 1 );
                      #else
                      Set_HdcpNVRamFlag();
                      NVRam_ReadByte( RM_HDCP_KEY_BASEADDR1 + wCount, &ucValue );
                      Clr_HdcpNVRamFlag();
                      #endif
                      #endif
                      
                      //msWriteByte(REG_3BFA+wCount, ucValue);
                      //while( msReadByte( REG_3BF2 ) & 0x80 );     // wait ready
                      HDCP1_CPU_WRITE_BKSV(wCount, ucValue);
                      while(HDCP1_CPU_WR_BUSY()); // wait ready
                  }
              
                  //Bcaps=0x00 or 0x80
                #if ENABLE_HDMI
                  HDCP1_CPU_WRITE_BCAPS(0x80); //msWriteByte( REG_3BFF, 0x80 );  //HDCP data
                #else
                  HDCP1_CPU_WRITE_BCAPS(0); //msWriteByte( REG_3BFF, 0x00 );  //HDCP data
                #endif // #if ENABLE_HDMI
              
                  HDCP1_MISC_SETTING(0x721); //msWrite2Byte( REG_3BC0, 0x0721 ); // [10:8]: 3'b111 determine Encrp_En du
             -ring Vblank in DVI mode; [5]:HDCP enable; [0]: EESS mode deglitch Vsync mode
                  HDCP1_ENABLE_DDC(); //msWriteByteMask( REG_3BEF, 0x04, 0x04 ); // [10]: HDCP enable DDC
                  
              #endif //
 325   1      
 326   1      HDCP_FORCE_ACK();
 327   1          
 328   1      }
 329          ///////////////////////////////////////////////////////////////////////////////
 330          // <Function>: msPullLowHPD1
 331          //
 332          // <Description>: Pull low DVI Hot-Plug-Detection pin
 333          //
 334          // <Parameter>: None
 335          //
 336          //
 337          ///////////////////////////////////////////////////////////////////////////////
 338          #if 0
              void msPullLowHPD1( void )
              {
                  if(CURRENT_INPUT_IS_HDMI())//( SrcInputType == Input_HDMI ) //130529 Modify
                  {
                      if(CURRENT_INPUT_IS_HDMI0())
                      {
                          if(!IS_MHL_PORT0_CABLE_CONNECT())
                              hw_Clr_HdcpHpd();
                      }
              
                      if(CURRENT_INPUT_IS_HDMI1())
                      {
                          if(!IS_MHL_PORT1_CABLE_CONNECT())
                              hw_Clr_HdcpHpd2();
                      }
              
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 7   

                      if(CURRENT_INPUT_IS_HDMI2())
                      {
                          if(!IS_MHL_PORT2_CABLE_CONNECT())
                              hw_Clr_HdcpHpd3();
                      }
                  }
              }
              #endif
 363          void msPullLowHPD1( void )  // 2017/02/22
 364          {
 365   1          if(CURRENT_INPUT_IS_TMDS())
 366   1          {
 367   2              if(CURRENT_INPUT_IS_HDMI0())//||CURRENT_INPUT_IS_DVI0())
 368   2              {
 369   3                  if(!IS_MHL_PORT0_CABLE_CONNECT())
 370   3                      {
 371   4                      hw_Clr_HdcpHpd();
 372   4                      #if ENABLE_DEBUG
 373   4                              printMsg("aaaaaaaaaaaaaaaaaaaaaaa");
 374   4                      #endif
 375   4                      }
 376   3              }
 377   2      
 378   2              if(CURRENT_INPUT_IS_HDMI1())//||CURRENT_INPUT_IS_DVI1())
 379   2              {
 380   3                  if(!IS_MHL_PORT1_CABLE_CONNECT())
 381   3                      {
 382   4                      hw_Clr_HdcpHpd2();
 383   4                              #if ENABLE_DEBUG
 384   4                              printMsg("bbbbbbbbbbbbbbbbb");
 385   4                      #endif
 386   4                      }
 387   3              }
 388   2      
 389   2              if(CURRENT_INPUT_IS_HDMI2())//||CURRENT_INPUT_IS_DVI2())
 390   2              {
 391   3                  if(!IS_MHL_PORT2_CABLE_CONNECT())
 392   3                      hw_Clr_HdcpHpd3();
 393   3                      #if ENABLE_DEBUG
 394   3                              printMsg("cccccccccccccccccc");
 395   3                      #endif  
 396   3              }
 397   2          }
 398   1      }
 399          ///////////////////////////////////////////////////////////////////////////////
 400          // <Function>: msPullLowHPD1
 401          //
 402          // <Description>: Pull high DVI Hot-Plug-Detection pin
 403          //
 404          // <Parameter>: None
 405          //
 406          //
 407          ///////////////////////////////////////////////////////////////////////////////
 408          #if 0
              void msPullHighHPD1( void )
              {
                  if(CURRENT_INPUT_IS_HDMI())//( SrcInputType == Input_HDMI ) //130529 Modify
                  {
                      if(CURRENT_INPUT_IS_HDMI0())
                      {
                          if(!IS_MHL_PORT0_CABLE_CONNECT())
                              hw_Set_HdcpHpd();
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 8   

                      }
              
                      if(CURRENT_INPUT_IS_HDMI1())
                      {
                          if(!IS_MHL_PORT1_CABLE_CONNECT())
                              hw_Set_HdcpHpd2();
                      }
              
                      if(CURRENT_INPUT_IS_HDMI2())
                      {
                          if(!IS_MHL_PORT2_CABLE_CONNECT())
                              hw_Set_HdcpHpd3();
                      }
                  }
              }
              #endif
 433          void msPullHighHPD1( void )
 434          {
 435   1          if(CURRENT_INPUT_IS_TMDS())
 436   1          {
 437   2              if(CURRENT_INPUT_IS_HDMI0())//||CURRENT_INPUT_IS_DVI0())
 438   2              {
 439   3                  //if(!IS_MHL_PORT0_CABLE_CONNECT())
 440   3                      hw_Set_HdcpHpd();
 441   3              }
 442   2      
 443   2              if(CURRENT_INPUT_IS_HDMI1())//||CURRENT_INPUT_IS_DVI1())
 444   2              {
 445   3                  //if(!IS_MHL_PORT1_CABLE_CONNECT())
 446   3                      hw_Set_HdcpHpd2();
 447   3              }
 448   2      
 449   2              if(CURRENT_INPUT_IS_HDMI2())//||CURRENT_INPUT_IS_DVI2())
 450   2              {
 451   3                  //if(!IS_MHL_PORT2_CABLE_CONNECT())
 452   3                      hw_Set_HdcpHpd3();
 453   3              }
 454   2          }
 455   1      }
 456          #if 0
              void msTMDSClkOn( Bool u8On)
              {
              #if (MainBoardType == MainBoard_5115_M0E || MainBoardType == MainBoard_7115_M0A)
                  if(CURRENT_INPUT_IS_DVI0())
                  {
                      msWriteByteMask( REG_PM_B2, u8On ? 0 : BIT0, BIT0 ); //seurat DVI RCK port A power down
                      #if ENABLE_DUAL_LINK
                      msWriteByteMask( REG_03B3, u8On ? 0 : BIT0, BIT0 ); //seurat DVI RCK port C power down
                      #endif
                  }
                  else if(CURRENT_INPUT_IS_HDMI0())
                  {
                    #if ENABLE_MHL&&(CHIP_ID == CHIP_TSUM2)
                       mhal_mhl_RxRtermControl((u8On)?(RX_HDMI_RTERM):(RX_RTERM_OFF));
                    #else
                       msWriteByteMask( REG_PM_B2, u8On ? 0 : BIT1, BIT1 ); //seurat DVI RCK port B power down
                    #endif 
                  }
              #else
              
                      if(CURRENT_INPUT_IS_HDMI0() || CURRENT_INPUT_IS_DVI0())
                              DVI_A_RCK_CTRL(u8On);
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 9   

                      else if(CURRENT_INPUT_IS_HDMI1() || CURRENT_INPUT_IS_DVI1())
                              DVI_B_RCK_CTRL(u8On);
                      else if(CURRENT_INPUT_IS_HDMI2() || CURRENT_INPUT_IS_DVI2())
                              DVI_C_RCK_CTRL(u8On);
              
              #endif
              }
              #endif
 487          
 488          void msDVIClkOn( Bool u8On )
 489          {
 490   1      #if DVI_PORT==TMDS_PORT_A
 491   1          #if ENABLE_MHL&&(CHIP_ID == CHIP_TSUM2)
                  //mapi_mhl_SetClk(u8On);
                  mhal_mhl_RxRtermControl((u8On)?(RX_HDMI_RTERM):(RX_RTERM_OFF));
                  #else
 495   1          DVI_A_RCK_CTRL(u8On); //msWriteByteMask( REG_PM_B2, (u8On ? 0 : BIT0), BIT0 ); // DVI RCK port A power
             - down
 496   1          #endif
 497   1      #elif DVI_PORT==TMDS_PORT_B
                  DVI_B_RCK_CTRL(u8On); //msWriteByteMask( REG_PM_B2, (u8On ? 0 : BIT1), BIT1 ); // DVI RCK port B power
             - down
              #else
                  DVI_C_RCK_CTRL(u8On); //msWriteByteMask( REG_PM_B3, (u8On ? 0 : BIT0), BIT0 ); // DVI RCK port C power
             - down
              #endif
 502   1      }
 503          
 504          #if ENABLE_HDMI
              void msHDMIClkOn( Bool u8On)
              {
              #if 0//(MainBoardType==MainBoard_JRY_WQ570_EV1)
                  if(CURRENT_INPUT_IS_DVI0())
                      {
                       DVI_A_RCK_CTRL(u8On);
                      #if ENABLE_DUAL_LINK     
                      DVI_C_RCK_CTRL(u8On);
                      #endif
                      }
                  else if(CURRENT_INPUT_IS_HDMI0())
                      {
                      DVI_B_RCK_CTRL(u8On);
                      }
              #else
                if(Input_TMDS_Nums>=2)
               {
                   if(CURRENT_INPUT_IS_HDMI0() || CURRENT_INPUT_IS_DVI0())
                       DVI_A_RCK_CTRL(u8On);
                   else if(CURRENT_INPUT_IS_HDMI1() || CURRENT_INPUT_IS_DVI1())
                       DVI_B_RCK_CTRL(u8On);
                   else if(CURRENT_INPUT_IS_HDMI2() || CURRENT_INPUT_IS_DVI2())
                       DVI_C_RCK_CTRL(u8On); 
               }
               else
               {
              #if HDMI_PORT==TMDS_PORT_C//TMDS_PORT_C
                   DVI_C_RCK_CTRL(u8On);
              #elif HDMI_PORT==TMDS_PORT_B //TMDS_PORT_B
                   DVI_B_RCK_CTRL(u8On);
              #else //TMDS_PORT_A
                   DVI_A_RCK_CTRL(u8On);
              #endif
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 10  

               }
              
                      
              #endif
              }
              #endif
 544          
 545          ///////////////////////////////////////////////////////////////////////////////
 546          // <Function>: msPullLowHPD2
 547          //
 548          // <Description>: Cut off DVI receiver clock current
 549          //
 550          // <Parameter>: None
 551          //
 552          ///////////////////////////////////////////////////////////////////////////////
 553          void msPullLowHPD2( void )
 554          {
 555   1      
 556   1          HDCP_PORT_DISABLE(); //disable HDCP port
 557   1          HDCP_CLEAR_STATUS(); //Clear HDCP status
 558   1          
 559   1          if(CURRENT_INPUT_IS_DVI())
 560   1              msDVIClkOn(FALSE);
 561   1      #if ENABLE_HDMI
                  else
                      #if HDMI_PRETEST
                      msHDMIClkOn(TRUE);
                      #else
                      msHDMIClkOn(FALSE);
                      #endif
              #endif
 569   1              
 570   1      }
 571          ///////////////////////////////////////////////////////////////////////////////
 572          // <Function>: msPullHighHPD2
 573          //
 574          // <Description>: Connect DVI receiver clock current
 575          //
 576          // <Parameter>: None
 577          //
 578          ///////////////////////////////////////////////////////////////////////////////
 579          void msPullHighHPD2( void )
 580          {
 581   1      #if 0
                  msTMDSClkOn(TRUE);
              #endif
 584   1          if(CURRENT_INPUT_IS_DVI())
 585   1              msDVIClkOn(TRUE);
 586   1      #if ENABLE_HDMI
                  else
                      msHDMIClkOn(TRUE);
              #endif
 590   1          HDCP_PORT_ENABLE(); //msWriteByteMask(SC0_BD,0,BIT7); //enable HDCP port
 591   1      }
 592          void mstar_HDCPReset(void)
 593          {
 594   1              DVI_RESET(TRUE);
 595   1              HDCP_RESET(TRUE);
 596   1              ForceDelay1ms(2);
 597   1              HDCP_RESET(FALSE);
 598   1              DVI_RESET(FALSE);
 599   1      }
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 11  

 600          
 601          void msDisableHDCP( void )
 602          {
 603   1          msPullLowHPD1();
 604   1          ForceDelay1ms( 100 );//2 jemery 180930 follow demo  
 605   1          msPullLowHPD2();
 606   1          mstar_HDCPReset();
 607   1      }
 608          void msEnableHDCP( void )
 609          {
 610   1          if( !PowerSavingFlag )
 611   1          {
 612   2              msDisableHDCP();
 613   2              ForceDelay1ms(300);
 614   2          }
 615   1          msPullHighHPD2();
 616   1          ForceDelay1ms( 100 );//2 jemery 180930 follow demo  
 617   1          msPullHighHPD1();
 618   1      }
 619          
 620          
 621          #if ENABLE_DUAL_LINK
              WORD Mode_GetStandardModePxlRate()
              {
                  return (WORD)((DWORD)StandardModeHTotal * HFreq( SrcHPeriod ) / 10000);
              }
              
              Bool IsSrcUseDualLinkDviPort(void)
              {
                      if(SrcInputType == Input_Digital) // DVI Dual-link - PortC+A
                      return 1;
                      return 0;
              }
              
              // DVI dual-link configuration
              void msDVIDualLinkMode(Bool bEnable)
              {
                      msWriteBit(REG_1E3E, bEnable, _BIT7);
                      if(bEnable) // dual-link, portC+A
                      {
                              msWriteByteMask( REG_2800, 0, BIT7|BIT6 ); // [7]: ABSWAP, [6]: ignore_dual_en
                              msWriteByteMask( REG_2801, 0, BIT6|BIT5 ); // [6]: DVI_linkb_en, [5]: DVI_dual_manual_en
                              msWriteByteMask( REG_2860, BIT5|BIT4, BIT6|BIT5|BIT4 ); // [6]: DVI_dual_b_ov_en, [5]: DVI_dual_c_ov_en,
             - [4]: DVI_dual_ov_en
                              //msWriteByteMask(REG_2E02, 0x10, 0xF0); // Set scaler IPMUX to dual-link
                              //msWriteBit(SC23_06, TRUE, _BIT2); // dual-in enable
                              //msWriteBit(SC23_07, TRUE, _BIT2); // odd/even pixel swap
              
                              msWriteByteMask(SC0_A6, _BIT1, _BIT1);
                      }
                      else // single-link, port C
                      {
                              msWriteByteMask( REG_2800, BIT6, BIT7|BIT6 ); // [7]: ABSWAP, [6]: ignore_dual_en
                              msWriteByteMask( REG_2801, BIT6|BIT5, BIT6|BIT5 ); // [6]: DVI_linkb_en, [5]: DVI_dual_manual_en
                              //msWriteByteMask( REG_2860, BIT5|BIT4, BIT6|BIT5|BIT4 ); // [6]: DVI_dual_b_ov_en, [5]: DVI_dual_c_ov_e
             -n, [4]: DVI_dual_ov_en
                              //msWriteByteMask(REG_2E02, 0xA0, 0xF0); // Set scaler IPMUX to single-link
                              //msWriteBit(SC23_06, FALSE, _BIT2); // dual-in disable
                              //msWriteBit(SC23_07, FALSE, _BIT2);
              
                              msWriteByteMask(SC0_A6, 0, _BIT1);
                      }
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 12  

              }
              
              Bool msGetDVIDualLinkStatus(void)
              {
                      #if DL_PXL_RAT_DET
                      WORD rate;
              
                      rate = Mode_GetStandardModePxlRate();
              
                      //printData("DVI Pixel Rate : %d", rate);
              
                      if( rate > 165 )
                      return TRUE;
                      else
                      return FALSE;
                      #else
                      BYTE ucDualLinkStatus = 0, ucStableCnt,ucIntCount = 0;
                      WORD wHDE, wVDE;
              
                      for(ucStableCnt = 0; ucStableCnt < 5; ucStableCnt++)
                      {
                              msWriteByte(REG_29E3, 0x44); // clear DE changed IRQ status
                              msWriteByte(REG_29E3, 0);
              
                              ForceDelay1ms(10);
                              ucDualLinkStatus |= msReadByte(REG_29E0); // Check DE changed IRQ status
              
                              if((ucDualLinkStatus&_BIT6)) // Check primary-link DE changed status
                              ucIntCount++;
                      }
              
                      if(ucIntCount != 0) // If primary-link DE changed, that means signal is coupled from another port.
                      {
                              //printMsg("\r\n DVI_SINGLE_LINK()");
                              return FALSE;
                      }
                      else // primary-link DE is unchanged, check whether DE is stable or unstable
                      {
                              for(ucStableCnt = 0; ucStableCnt < 20; ucStableCnt++)
                              {
                                      ForceDelay1ms(20);
                                      ucDualLinkStatus = msReadByte(REG_3B62); // DVI1 DE is stable
                                      if((ucDualLinkStatus&_BIT6) != 0)
                                      break;
                              }
                              if((ucDualLinkStatus&_BIT6) != 0)
                              {
                                      wHDE = msRead2Byte(SC0_84) - msRead2Byte(SC0_80);
                                      wVDE = msRead2Byte(SC0_82) - msRead2Byte(SC0_7E);
                                      // software patch for MSPG4233 dual-link port
                                      //printMsg("\r\n HDE-VDE = %d", (signed)wHDE - wVDE);
                                      if(wHDE <= wVDE)
                                      {
                                              //printMsg("\r\n DVI_DUAL_LINK");
                                              return TRUE;
                                      }
                                      else
                                      {
                                              //printMsg("\r\n II -DVI_SINGLE_LINK()");
                                              return FALSE; // single-link
                                      }
                              }
C51 COMPILER V9.01   MSHDCP                                                                08/17/2023 10:55:01 PAGE 13  

                              else
                              {
                                      //printMsg("\r\n II -DVI_SINGLE_LINK()");
                                      return FALSE;
                              }
                      }
                      #endif
              }
              #endif // #if ENABLE_DUAL_LINK
 731          
 732          
 733          
 734          
 735          
 736          
 737          
 738          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    586    ----
   CONSTANT SIZE    =    350    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
