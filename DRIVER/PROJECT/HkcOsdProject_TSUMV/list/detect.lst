C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DETECT
OBJECT MODULE PLACED IN .\obj\detect.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\detect.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC;
                    -..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL\
                    -SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\I
                    -NC) DEFINE(ModelName=MODEL_T24_TCL) DEBUG OBJECTEXTEND PRINT(.\list\detect.lst) OBJECT(.\obj\detect.obj)

line level    source

   1          #include <math.h>
   2          #include "types.h"
   3          #include "board.h"
*** MESSAGE C320 IN LINE 337 OF ..\..\CONFIG\BOARD.H: "Please remember to disable the debug function!" 
   4          #include "global.h"
   5          #include "ms_reg.h"
   6          #include "ms_rwreg.h"
   7          #include "power.h"
   8          #include "debug.h"
   9          #include "misc.h"
  10          #include "menu.h"
  11          #include "UserPref.h"
  12          #include "msOSD.h"
  13          #include "msosdfunction.h"
  14          #include "mStar.h"
  15          #include "Panel.h"
  16          #include "adjust.h"
  17          #include "GPIO_DEF.h"
  18          #include "drvosd.h"
  19          #include "drvadc.h"
  20          #include "autofunc.h"
  21          #include "MenuFunc.h"   //2012.08.14 Stone.yu
  22          #if ENABLE_HDCP
  23              #include "MsHDCP.h"
  24          #endif
  25          #if MWEFunction
  26              #include "MsACE.h"
  27              #include "msdlc.h"
  28          #endif
  29          
  30          #if ENABLE_HDMI
              #include "MsHDMI.h"
              #endif
  33          
  34          #ifdef ReduceDDC
              #include "ddc.h"
              #endif
  37          
  38          #if MS_DAC
              #include "drvDAC.h"
              #endif
  41          
  42          
  43          
  44          #ifdef TSUMXXT//#if( ChipID == ChipTSUMT )              //110311 Modify
              #include "msADC.h"
              #endif
  47          
  48          #if MS_PM
  49          #include "Ms_PM.h"
  50          #endif
  51          /////////////////////////////////////
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 2   

  52          #include "drvmStar.h"
  53          ////////////////////////////////////
  54          
  55          ////////////////////////////////////////////////////////////////////////
  56          #define SyncValidCount_VGA    10
  57          
  58          #define SyncLossCount_VGA     20
  59          
  60          
  61          #define SyncValidCount_DVI  20// 80 
  62          
  63          #define SyncLossCount_DVI   90//60//  
  64          #define SyncValidCount_HDMI  60//  100
  65          
  66          #define SyncLossCount_HDMI     ((150))// 230// 
  67          
  68          #define SyncLossCount_ANDROID   1000//
  69          
  70          #if ENABLE_HDMI2ND_INPUT
              #define SyncValidCount_HDMI2  60//  
              #define SyncLossCount_HDMI2  ((150))// 230// 
              #endif
  74          
  75          #if ENABLE_DP_INPUT
              #define SyncValidCount_DP 60// 
              #define SyncLossCount_DP   230//
              #endif
  79          
  80           #if ENABLE_MHL
              #define SyncValidCount_MHL  50//25//50//70 // 120718 coding test        //130703 nick
              #define SyncLossCount_MHL  (350)//250//250                                      //130703 nick
              //#define MaxLossCount_MHL   (SyncLossCount_MHL*20) // unit: ms
              #define ExtenCount_MHL   150 // unit: 20mS, 150x20 = 3000
              #define SyncLossExtenCount_MHL      (SyncLossCount_MHL-ExtenCount_MHL)
              #endif
  87          
  88          
  89          #if ENABLE_DEBUG&&DEBUG_DETECT
                  #define DETECT_printData(str, value)   printData(str, value)
                  #define DETECT_printMsg(str)           printMsg(str)
              #else
  93              #define DETECT_printData(str, value)
  94              #define DETECT_printMsg(str)
  95          #endif
  96          
  97          #if ENABLE_DEBUG&&0
                  #define NOSYNC_printData(str, value)   printData(str, value)
                  #define NOSYNC_printMsg(str)           printMsg(str)
              #else
 101              #define NOSYNC_printData(str, value)   
 102              #define NOSYNC_printMsg(str)           
 103          #endif
 104          
 105          ////////////////////////////////////////////////////////////////////////
 106          // 120425 coding add 1A2H model for sync valid/loss conter
 107          #if INPUT_TYPE == INPUT_1A1H || INPUT_TYPE == INPUT_1A2H || INPUT_TYPE == INPUT_2H
                  #if ENABLE_MHL
                          #define SyncValidCount_Digital  ((GET_MHL_CABLE_PLUGGED())?(SyncValidCount_MHL):(SyncValidCoun
             -t_HDMI))
                          #define SyncLossCount_Digital  ((GET_MHL_CABLE_PLUGGED())?(SyncLossCount_MHL):(SyncLossCount_H
             -DMI))
                  #else
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 3   

                          #define SyncValidCount_Digital  SyncValidCount_HDMI
                          #define SyncLossCount_Digital  SyncLossCount_HDMI
                  #endif    
              #elif INPUT_TYPE == INPUT_1A2D || INPUT_TYPE == INPUT_2A2D||INPUT_TYPE == INPUT_1A1D1H  //131113 fay
              #if ENABLE_MHL
              #define SyncValidCount_Digital  ((SrcInputType>Input_Digital)?((GET_MHL_CABLE_PLUGGED())?(SyncValidCount_M
             -HL):(SyncValidCount_HDMI)):(SyncValidCount_DVI))
              #define SyncLossCount_Digital  ((SrcInputType>Input_Digital)?((GET_MHL_CABLE_PLUGGED())?(SyncLossCount_MHL
             -):(SyncLossCount_HDMI)):(SyncLossCount_DVI))
              #else
              #define SyncValidCount_Digital  ((SrcInputType>Input_Digital)?(SyncValidCount_HDMI):(SyncValidCount_DVI))
              #define SyncLossCount_Digital  ((SrcInputType>Input_Digital)?(SyncLossCount_HDMI):(SyncLossCount_DVI))
              #endif
              #elif INPUT_TYPE == INPUT_1A1D1H1DP|| INPUT_TYPE == INPUT_1D1H1DP
              #if ENABLE_MHL
              #define SyncValidCount_TMDS  ((SrcInputType>Input_Digital)?((GET_MHL_CABLE_PLUGGED())?(SyncValidCount_MHL)
             -:(SyncValidCount_HDMI)):(SyncValidCount_DVI))
              #define SyncLossCount_TMDS  ((SrcInputType>Input_Digital)?((GET_MHL_CABLE_PLUGGED())?(SyncLossCount_MHL):(
             -SyncLossCount_HDMI)):(SyncLossCount_DVI))
              #else
              #define SyncValidCount_TMDS  ((SrcInputType>Input_Digital)?(SyncValidCount_HDMI):(SyncValidCount_DVI))
              #define SyncLossCount_TMDS  ((SrcInputType>Input_Digital)?(SyncLossCount_HDMI):(SyncLossCount_DVI))
              #endif
              #define SyncValidCount_Digital  ((CURRENT_INPUT_IS_DISPLAYPORT())?(SyncValidCount_DP):(SyncValidCount_TMDS
             -))
              #define SyncLossCount_Digital  ((CURRENT_INPUT_IS_DISPLAYPORT())?(SyncLossCount_DP):(SyncLossCount_TMDS))
              #elif INPUT_TYPE == INPUT_1A1D1DP       //130924 xiandi
              #define SyncValidCount_Digital  ((CURRENT_INPUT_IS_DISPLAYPORT())?(SyncValidCount_DP):(SyncValidCount_DVI)
             -)
              #define SyncLossCount_Digital  ((CURRENT_INPUT_IS_DISPLAYPORT())?(SyncLossCount_DP):(SyncLossCount_DVI))
              #elif INPUT_TYPE == INPUT_1A1DP ////20151126 Alpha
              #define SyncValidCount_Digital  (SyncValidCount_DP)
              #define SyncLossCount_Digital  (SyncLossCount_DP)
              #elif INPUT_TYPE == INPUT_1A2H1DP
              
              #define SyncValidCount_TMDS  ((SrcInputType>Input_Digital)?(SyncValidCount_HDMI):(SyncValidCount_HDMI2))
              #define SyncLossCount_TMDS  ((SrcInputType>Input_Digital)?(SyncLossCount_HDMI):(SyncLossCount_HDMI2))
              
              #define SyncValidCount_Digital  ((CURRENT_INPUT_IS_DISPLAYPORT())?(SyncValidCount_DP):(SyncValidCount_TMDS
             -))
              #define SyncLossCount_Digital  ((CURRENT_INPUT_IS_DISPLAYPORT())?(SyncLossCount_DP):(SyncLossCount_TMDS))
              
              #elif INPUT_TYPE == INPUT_1A1H1DP       //131203 xiandi
              #if ENABLE_MHL
              #define SyncValidCount_Digital  ((CURRENT_INPUT_IS_DISPLAYPORT())?(SyncValidCount_DP):((GET_MHL_CABLE_PLUG
             -GED())?(SyncValidCount_MHL):(SyncValidCount_HDMI)))
              #define SyncLossCount_Digital  ((CURRENT_INPUT_IS_DISPLAYPORT())?(SyncLossCount_DP):((GET_MHL_CABLE_PLUGGE
             -D())?(SyncLossCount_MHL):(SyncLossCount_HDMI)))
              #else
              #define SyncValidCount_Digital  ((CURRENT_INPUT_IS_DISPLAYPORT())?(SyncValidCount_DP):(SyncValidCount_HDMI
             -))
              #define SyncLossCount_Digital  ((CURRENT_INPUT_IS_DISPLAYPORT())?(SyncLossCount_DP):(SyncLossCount_HDMI))
              #endif
              #else
 156          #define SyncValidCount_Digital  SyncValidCount_DVI
 157          #define SyncLossCount_Digital  SyncLossCount_DVI
 158          #endif
 159          
 160          #define ValidTimingStableCount  ((CURRENT_INPUT_IS_VGA())?(SyncValidCount_VGA):(SyncValidCount_Digital))
 161          #define SyncLossStableCount     ((CURRENT_INPUT_IS_VGA())?(SyncLossCount_VGA):(SyncLossCount_Digital))
 162          
 163          
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 4   

 164          
 165          extern InputModeType code StandardMode[];
 166          #if ENABLE_MHL
              extern WORD xdata InputTimingStableCounter;
              #else
 169          extern BYTE xdata InputTimingStableCounter;
 170          #endif
 171          #if ENABLE_FREESYNC
              Bool xdata bHDMIFreesyncChk = FALSE;
              #endif
 174          
 175          Bool mStar_FindMode(void);
 176          BYTE mStar_GetInputStatus(void);
 177          Bool IsCableNotConnected(void);
 178          Bool mStar_SyncLossStateDetect(void);
 179          Bool mStar_ValidTimingDetect(void);
 180          #if ENABLE_MHL
              Bool CurrentInputMHLCablePlugged(void);
              #endif
 183          
 184          #if ENABLE_MHL || ENABLE_DP_INPUT
              #if MS_PM
              extern XDATA ePMStatus ucWakeupStatus;
              #endif
              #endif
 189          void SpeedupOrExtendSwitchPort(void);   //130625 nick
 190          
 191          #if ENABLE_HDMI
              // 120530 coding addition for speed up switch port       
              #define HDMI_STAY_1S_COUNT      50
              #define JUST_HDMI_PLUG   0x5D
              #define JUST_VGA_PLUG   0x35
              #define BOTH_VGA_HDMI_PLUG   0x26
              #define NONE_PLUG    0xFF
              Bool HDMICableNotConnect(void)
              {
                  bit bresult = FALSE;
              #if 0
                  if(CURRENT_INPUT_IS_HYBRID_MHL_HDMI() && !GET_MHL_CABLE_PLUGGED())
                  {
                      if( !HYBRID_MHL_HDMI_CABLE_CONNECT())
                      {
                          Delay1ms(2);
                          if( !HYBRID_MHL_HDMI_CABLE_CONNECT())
                              bresult = TRUE;
                      }
                  }
                  else if(CURRENT_INPUT_IS_PURE_HDMI())
                  {
                      BYTE tempValue = CABLE_DET_SAR;
                      if(abs(tempValue-JUST_HDMI_PLUG) > 10 && abs(tempValue -BOTH_VGA_HDMI_PLUG) > 10)       //130624 jun
                      {
                          bresult = TRUE;
                      }
                  }
              #else
              #message "please coding HDMICableNotConnect for speedup switch port"    
              #endif
                  return bresult;
              
              }
              #define HDMI_SPEEDUP_SWITCH_PORT()    ((InputTimingStableCounter >= HDMI_STAY_1S_COUNT) && DVI_CLOCK_IS_MI
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 5   

             -SSING() && HDMICableNotConnect())
              #endif
 227          
 228          #if ENABLE_MHL
              #define MHL_EXTEND_SYNCLOSS_COUNT()   (SyncLossState() \
                                                                                      && InputTimingStableCounter >= Syn
             -cLossStableCount \
                                                                                      && !MHLExtenCountFlag\
                                                                                      && CURRENT_INPUT_MHL_CABLE_PLUGGED
             -() \
                                                                                      && GET_MHL_CBUS_CONNECT())
              #endif
 235          //*******************************************************************
 236          // Function Name: mStar_MonitorInputTiming
 237          //
 238          // Decscription: Detect input timing
 239          //
 240          // callee: mStar_SyncLossStateDetect(), mStar_ValidTimingDetect(), mStar_AutoDVI() in detect.c
 241          //         mStar_SetInputPort(), mStar_SetAnalogInputPort() in mstar.c
 242          //
 243          // caller: main() in main.c
 244          //*******************************************************************
 245          void mStar_MonitorInputTiming(void)
 246          {
 247   1          if (!PowerOnFlag || DisplayLogoFlag)
 248   1          {
 249   2              return ;
 250   2          }
 251   1             
 252   1          // detect whether input signal is changing             (3)
 253   1          if (!InputTimingChangeFlag)//æœ‰/æ— ä¿¡å·(1)InputTimingChangeFlagä¸º1ï¼Œä¸è¿›å…¥,è·³else(2)InputTimi
             -ngChangeFlagä¸º0ï¼Œè¿›å…¥
 254   1          {                                                   
 255   2              if (SyncLossState())//  (2)SyncLossæ²¡æœ‰æ”¹å˜ï¼Œæ¡ä»¶æˆç«‹è¿›å…¥
 256   2              
 257   2              {        //FreeRunModeFlagä»£è¡¨ç€å±å¹•æ²¡ä¿¡å·ï¼Œç»™å±å¹•çš„ä¸€ç§çŠ¶æ€ï¼Œé˜²æ­¢çœ‹å‡ºå±å¹•èŠ±
 258   3              
 259   3                  if (!FreeRunModeFlag)//ï¼ˆ2ï¼‰FreeRunModeFlagä¸º1ï¼Œåˆ¤æ–­æ¡ä»¶ä¸º0ï¼Œä¸æˆç«‹
 260   3                  {
 261   4                      Set_InputTimingChangeFlag();
 262   4                  }
 263   3                  else if (mStar_SyncLossStateDetect())//ï¼ˆ2ï¼‰æ— ä¿¡å·è¿›å…¥ï¼Œæœ‰ä¿¡å·å‡ºæ¥ï¼Œè¿”å›žtrueï¼
             -Œæ¡ä»¶æˆç«‹
 264   3                  // detect mode while no Sync/suspend/standby/disconnect
 265   3                  {
 266   4                      DETECT_printMsg("no sync -> have sync");
 267   4                      Set_InputTimingChangeFlag();                                    //ï¼ˆ2ï¼‰çŠ¶æ€å‘ç”Ÿæ”¹å˜ï¼Œä¹Ÿå°±æ˜¯ä¿¡å·å‘ç”Ÿæ”¹å˜
             -ï¼Œè°ƒå‡ºif
 268   4                  }
 269   3          #if Dual
 270   3                  else if((InputTimingStableCounter > 0) && (SwitchPortCntr > Input_Nums) && // 100125 coding
 271   3                             (UserPrefInputSelectType == INPUT_PRIORITY_AUTO) 
 272   3                              )
 273   3                  {
 274   4                      //130625 nick
 275   4                  SpeedupOrExtendSwitchPort();
 276   4                  
 277   4                      #if 0//ENABLE_HDMI
                                  if(HDMI_SPEEDUP_SWITCH_PORT())
                                  {
                                      InputTimingStableCounter = SyncLossStableCount;
                                  #if 0//ENABLE_DEBUG
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 6   

                                      printData("PowerSaving Speedup:%d", SrcInputType);
                                  #endif
                                  }
                              #endif
 286   4      
 287   4                      #if 0//ENABLE_MHL
                                  if(MHL_EXTEND_SYNCLOSS_COUNT())
                                  {
                                      InputTimingStableCounter = SyncLossExtenCount_MHL;                   
                                      MHLExtenCountFlag = 1;
                                  #if DEBUG_PRINTDATA
                                      printData("PowerSaving MHL ex3S:%d", SrcInputType);
                                  #endif
                                  }
                              #endif
 297   4                     
 298   4                      if((InputTimingStableCounter % SyncLossStableCount) == 0)
 299   4                      {
 300   5                          InputTimingStableCounter = 1; // 071224
 301   5      
 302   5                          SrcInputType = (SrcInputType + 1) % Input_Nums;
 303   5      
 304   5                              /*if(SrcInputType>Input_HDMI3)
 305   5                              {SrcInputType = Input_HDMI3;
 306   5                              printData(" PS_SwitchTo:%d", SrcInputType);
 307   5                              #message"rember to del it"
 308   5                              }
 309   5                              else    */                                       
 310   5                          mStar_SetupInputPort();
 311   5                          //DETECT_printData(" PS_SwitchTo:%d", SrcInputType);
 312   5                      }
 313   4                  }
 314   3          #endif            
 315   3              }
 316   2          else                                                                                                                        //(3)
 317   2              // valid timing
 318   2              {
 319   3              
 320   3                  // check if input timing is changingæ£€æµ‹ä¿¡å·æ˜¯å¦å‘ç”Ÿæ”¹å˜
 321   3                  if (mStar_ValidTimingDetect())//å½“ä¿¡å·å˜åŒ–æ—¶è¿™é‡Œå’Œä¸­æ–­å¯çŸ¥é“ //(3)è¿”å›žfalse
 322   3                  {
 323   4                      SrcFlags |= SyncLoss;
 324   4                      Set_InputTimingChangeFlag();
 325   4                      hw_ClrBlacklit(); // 2006/9/7 8:39PM by Emily for changed mode had garbage
 326   4                      #if DEBUG_MSG
 327   4                      printMsg("have sync -> no sync");
 328   4                         printData("InputTimingStableCounter %d", InputTimingStableCounter);
 329   4                         #endif               
 330   4      #if (ENABLE_DP_INPUT&& ((CHIP_ID == CHIP_TSUMC)||(CHIP_ID == CHIP_TSUMD)||(CHIP_ID == CHIP_TSUM9)||(CHIP_I
             -D == CHIP_TSUMF)))    //130912 nick
              #if DP_RESETHTT_PATCH
                                          if(CURRENT_INPUT_IS_DISPLAYPORT())
                                              DPMSA_Reset();
              #endif
              #endif
 336   4      //msWriteByteMask( REG_1F15,0,BIT5);    //1 ÄÜ ½âDP FREESYNC ×´Ì¬±£³Ö, Ðè ´ýÑéÖ¤,ÎðÊ¹ÓÃ
 337   4                  }
 338   3              }
 339   2          }
 340   1          //=============================================================================
 341   1          //=============================================================================
 342   1          if (InputTimingChangeFlag)//ä¿¡å·ä¸æ”¹å˜ä¸º0ï¼Œä¿¡å·çŠ¶æ€å‘ç”Ÿæ”¹å˜è¿™é‡Œä¸€å®šä¸º1ï¼ˆ2ï¼‰è¿›æ
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 7   

             -¥                                                                                                        //my
 343   1          // input timing is unstable
 344   1          {
 345   2      
 346   2              #if MWEFunction
 347   2                  if (g_bAccOnOff)
 348   2                  {
 349   3                      //UserPrefMWE=OFF_W;
 350   3                      //msAccSetup(UserPrefMWE);
 351   3                      #if (CHIP_ID==CHIP_TSUMU)
                              msAccSetup( 0, 0, 0, 0 );
                              #endif
 354   3                      msAccOnOff(0);
 355   3                  }
 356   2              #endif
 357   2              // 2006/7/6 0:8AM by Emily for dec. dot clock
 358   2              Clr_DecVScaleFlag();
 359   2              DecVScaleValue = 0;
 360   2                      
 361   2              Clr_InputTimingChangeFlag();                                                                                                            //my
 362   2              Clr_DoModeSettingFlag();
 363   2              Clr_ReadyForChangeFlag();
 364   2                  //DETECT_printData(" PrepareForTimingChange:%d", SrcInputType);
 365   2      #if ENABLE_FREESYNC
                                              bHDMIFreesyncChk = TRUE;
                                              //g_bHDMIFreesyncEnable = FALSE;
              #endif   //çŠ¶æ€å‘ç”Ÿæ”¹å˜è¿›å…¥   
 369   2              mStar_PrepareForTimingChange();                                                                                                 //ï¼ˆ1,2ï¼‰è¿›å…¥
 370   2          }
 371   1          else                                                                                                                                                                //(1,2)ä¸èµ°                                                                                                           
 372   1          // input timing is stable
 373   1          {                                                                                                           //(3)è¿›æ¥
 374   2              InputTimingStableCounter++; // counter timing stable times
 375   2              if(InputTimingStableCounter == 0)
 376   2                  InputTimingStableCounter = 1;
 377   2              if (!InputTimingStableFlag)                                             //62æ¬¡åŽä¸€ç›´ä¸º1
 378   2              {
 379   3              //130625 nick
 380   3          SpeedupOrExtendSwitchPort();
 381   3      
 382   3          #if 0//ENABLE_HDMI
                          if(HDMI_SPEEDUP_SWITCH_PORT())
                          {
                              InputTimingStableCounter = SyncLossStableCount;
                          }
                  #endif
 388   3      
 389   3          #if 0//ENABLE_MHL
                          if(MHL_EXTEND_SYNCLOSS_COUNT())
                          {
                              InputTimingStableCounter = SyncLossExtenCount_MHL;   
                              MHLExtenCountFlag = 1;
                                              #if DEBUG_PRINTDATA
                                      //DETECT_printData("MHL ex3S:%d", SrcInputType);
                                              #endif
                          }
                  #endif
 399   3      
 400   3                      //æœ‰ä¿¡å· ValidTimingStableCountï¼Œvgaç¬¬12æ¬¡æ—¶è¿›å…¥ï¼ŒDVIç¬¬22æ¬¡è¿›å…¥ï¼ŒHDMIç¬¬62æ¬¡è¿›å…¥ï¼
             -ŒDPç¬¬62æ¬¡è¿›å…¥
 401   3                      //æ— ä¿¡å· SyncLossStableCount,VGAç¬¬21æ¬¡æ˜¯è¿›å…¥->HDMIï¼ŒDVI 91  ; HDMI 151->VGA ; DP 231
 402   3                  if((!SyncLossState() && InputTimingStableCounter >= ValidTimingStableCount) ||
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 8   

 403   3                      (SyncLossState() && InputTimingStableCounter >= SyncLossStableCount))
 404   3                  {
 405   4                      Set_InputTimingStableFlag(); // set flag to search for input mode                                                                       //my
 406   4                      Set_DoModeSettingFlag();                                                                                                                                                        //my
 407   4      
 408   4                                      
 409   4                    #if ENABLE_MHL
                               #if MS_PM
                                        if(SyncLossState() && PM_WAKEUP_FROM_MHL)
                                        {
                                                Set_ForcePowerSavingFlag();
                                                Clr_DoModeSettingFlag();
                                                return;
                                        }
                               #endif                         
                            #endif
 419   4      
 420   4                                
 421   4                   #if ENABLE_DP_INPUT
                              #if MS_PM
                                        if(SyncLossState() && PM_WAKEUP_FROM_DP)
                                        {
                                                Set_ForcePowerSavingFlag();
                                                Clr_DoModeSettingFlag();
                                                return;
                                        }
                              #endif
                           #endif
 431   4      #if Dual
 432   4      #if 0//ENABLE_DEBUG
                  //if(!SyncLossState())
                  //    printData("ValidCntr:%d", InputTimingStableCounter);
                  //else
                      printData("LossCntr:%d", InputTimingStableCounter);
                  printData("SrcInputType:%d", SrcInputType);
              #endif
 439   4      
 440   4                      InputTimingStableCounter = 1; // 071224
 441   4                      if(!SyncLossState())
 442   4                      {
 443   5                          SwitchPortCntr = 0;
 444   5                      #if ENABLE_MHL//130703 nick
                                      MHLExtenCountFlag = 0;
                              #endif
 447   5                      }
 448   4                              
 449   4                      if(SyncLossState() && (UserPrefInputSelectType == INPUT_PRIORITY_AUTO) &&                               //my
 450   4                          (++SwitchPortCntr <= Input_Nums)//vga+hdmi = 2                                      //æ¡ä»¶æˆç«‹ï¼Œåˆ‡æ¢ç«¯å£
 451   4                          ) // 100125 coding
 452   4                      {
 453   5                          Clr_InputTimingStableFlag(); // set flag to search for input mode
 454   5                          Clr_DoModeSettingFlag();
 455   5                          SrcInputType = (SrcInputType + 1) % Input_Nums;//HDMI 1  VGA 0 HDMIä¸‹ï¼Œï¼ˆ1+1ï¼‰% 2 
             -=0ï¼Œåˆ™HDMIåˆ‡åˆ°VGA
 456   5                                              
 457   5                              
 458   5                          #if CHIP_ID==CHIP_TSUMD
                                  //====Test 20130312  for Auto switch TMDS can't display====// 
                                  //drvADC_PowerCtrl(ADC_POWER_ON);
                                  //drvDVI_PowerCtrl(DVI_POWER_ON);
                                  //====Test 20130312 ====//
                                  #endif
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 9   

 464   5                          mStar_SetupInputPort();//åˆ‡æ¢ç«¯å£                                                                               ç«¯å£åˆ‡æ¢åŽè¿›å…¥while(1)
 465   5                              DETECT_printData(" 2-PS_SwitchTo:%d", SrcInputType);
 466   5          #if 0//ENABLE_DEBUG
                      printData("SwitchPort:%d", SrcInputType);
                  #endif
 469   5                          
 470   5                      }
 471   4      
 472   4                      #if (AudioFunc && ENABLE_DP_INPUT)//131031 xiandi               petit  20131107 update
                              PrevInputType=SrcInputType;
                              #endif
 475   4      #endif                
 476   4      
 477   4                  }
 478   3      
 479   3                  }
 480   2          }
 481   1      }
 482          //*******************************************************************
 483          // Function Name: mStar_ModeHandler
 484          //
 485          // Decscription: Programming scaler while input timing is changing
 486          //
 487          // callee: mStar_SyncLossStateDetect(), mStar_ValidTimingDetect(), mStar_AutoDVI() in detect.c
 488          //         mStar_SetInputPort(), mStar_SetAnalogInputPort() in mstar.c
 489          //
 490          // caller: main() in main.c
 491          //*******************************************************************
 492          void mStar_ModeHandler(void)
 493          {
 494   1      
 495   1          if (DisplayLogoFlag)
 496   1          {
 497   2              Menu_InitAction();
 498   2          }
 499   1              
 500   1      #if MS_PM
 501   1              #if ENABLE_MHL 
                      if(SyncLossState() && PM_WAKEUP_FROM_MHL)
                              return;
                      #endif
 505   1      
 506   1          #if ENABLE_DP_INPUT
                      if(SyncLossState() && PM_WAKEUP_FROM_DP)
                                      return;
                  #endif
 510   1      #endif
 511   1      
 512   1      
 513   1      
 514   1              
 515   1          if (!DoModeSettingFlag)
 516   1          // while timing change & stable
 517   1          {
 518   2              return ;
 519   2          }
 520   1      
 521   1      #if MS_DAC
              #if (CHIP_ID==CHIP_TSUMC ||CHIP_ID==CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF)
                  if(!SyncLossState() && w16DAC_DePopStep != INIT_FINISH)
                      return;
              #endif    
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 10  

              #endif
 527   1      
 528   1          //Clr_DoModeSettingFlag();  //0606 for Diaplay LOGO
 529   1          if (!SyncLossState())
 530   1          // no sync
 531   1          {
 532   2      #if ENABLE_MHL_COUNT
                  if(!SyncLossState() && CURRENT_INPUT_MHL_CABLE_PLUGGED())
                  {
                      //DETECT_printData("ModeHandler:%d", MHLActionCount);
                      MHLActionCount = 1;
                  }
              #endif
 539   2      
 540   2      
 541   2      {
 542   3                 BYTE  xdata Retry=0; 
 543   3      
 544   3                 if (
 545   3                     ((CURRENT_INPUT_IS_DISPLAYPORT())&& DP_INTERLACED_VIDEO_STREAM()) 
 546   3                     ||(SC0_READ_SYNC_STATUS()&INTM_B))
 547   3                 { 
 548   4                     SrcFlags |= bInterlaceMode;
 549   4                 }
 550   3                 else
 551   3                     SrcFlags&=~bInterlaceMode;
 552   3      
 553   3      
 554   3              if(SrcFlags&bInterlaceMode)
 555   3              {
 556   4                 for (Retry=0; Retry<10; Retry++)
 557   4                 {
 558   5                       Delay1ms(20);
 559   5                     if(((CURRENT_INPUT_IS_DISPLAYPORT())&& DP_INTERLACED_VIDEO_STREAM()) ||(SC0_READ_SYNC_STATU
             -S()&INTM_B))
 560   5                    {
 561   6                       SrcFlags |= bInterlaceMode;
 562   6                         //printMsg("111111111 bInterlaceMode");               
 563   6                    }
 564   5                    else 
 565   5                    {
 566   6                       SrcFlags&=~bInterlaceMode;
 567   6                         //printMsg("00000000000000");
 568   6                         break;                
 569   6                    }
 570   5                 }
 571   4              }
 572   3        }
 573   2      
 574   2              #if 0//ENABLE_FREESYNC//170118 Test 
                           if(SrcFlags&bInterlaceMode)
                              {
                                  scRegs[(SC0_E8)&0xFF]=((scRegs[(SC0_E8)&0xFF])&(~(BIT1|BIT0)));
                                  bHDMIFreesyncChk = FALSE;
                              }
                            else if((IS_HDMI_FREESYNC_ISR()))
                              {
                                  scRegs[(SC0_E8)&0xFF]=(((scRegs[(SC0_E8)&0xFF])&(~BIT1))|BIT0);
                                  bHDMIFreesyncChk = FALSE;
                                   Delay1ms(30);
                              }
                  #endif
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 11  

 587   2      
 588   2      
 589   2      #if ENABLE_FREESYNC//170118 Test 
                  
                  {
                             BYTE  xdata Retry=0; 
                  
                             if (
                                 ((CURRENT_INPUT_IS_DISPLAYPORT())&& DP_INTERLACED_VIDEO_STREAM()) 
                                 ||(SC0_READ_SYNC_STATUS()&INTM_B))
                             { 
                                 SrcFlags |= bInterlaceMode;
                             }
                         else
                                 SrcFlags&=~bInterlaceMode;
                  
                  
                          //if((UserprefFreeSyncMode==FreeSyncMenuItems_On)&&CURRENT_INPUT_IS_HDMI())
                          if(SrcFlags&bInterlaceMode)
                          {
                         for (Retry=0; Retry<10; Retry++)
                         {
                               Delay1ms(20);
                                 if(((CURRENT_INPUT_IS_DISPLAYPORT())&& DP_INTERLACED_VIDEO_STREAM()) ||(SC0_READ_SYNC_S
             -TATUS()&INTM_B))
                                {
                                   SrcFlags |= bInterlaceMode;
                             //printMsg("111111111 bInterlaceMode");       
                                }
                                else 
                                {
                                   SrcFlags&=~bInterlaceMode;
                             //printMsg("00000000000000");
                             break;        
                                }
                                //printData("00000000 SRC_FLAGS==%x",SRC_FLAGS);
                         }
                          }
                    }
                  
                      
                           if(SrcFlags&bInterlaceMode)
                              {
                                  scRegs[(SC0_E8)&0xFF]=((scRegs[(SC0_E8)&0xFF])&(~(BIT1|BIT0)));
                                  bHDMIFreesyncChk = FALSE;
                              }
                            else if((IS_HDMI_FREESYNC_ISR())||((UserprefFreeSyncMode==FreeSyncMenuItems_On)&&CURRENT_INP
             -UT_IS_HDMI()))
                              {
                              #if DEBUG_MSG
                              printMsg("try to run");
                                #endif                
                                 // if(bHDMIFreesyncChk)
                                      //MEM_SCWRITE_BYTE(SC0_E8,((scRegs[(SC0_E8)&0xFF])&(~BIT1))|BIT0);    //Enable for
             -ce P mode
                                  scRegs[(SC0_E8)&0xFF]=(((scRegs[(SC0_E8)&0xFF])&(~BIT1))|BIT0);
                                  bHDMIFreesyncChk = FALSE;
                               Delay1ms(30);
                              }
                  
                  #endif
 645   2              
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 12  

 646   2      #if 1    
 647   2      #if ENABLE_HDMI
                      if(CURRENT_INPUT_IS_TMDS()
                        )//( (SrcInputType==Input_Digital||SrcInputType==Input_Digital2))     //121130 Modify
                      {
                              if( mstar_HDMITmdsGetType() == TMDS_HDMI )
                              {
                                      BYTE ucCount = 200; //25;  2009-10-13
              
                                 //printMsg("====>TMDS_HDMI");
                          
                                      while( ucCount-- )
                                      {   
                                              gScInfo.InputAVIInfoReceived = 0;
                                              mstar_HDMIGetPktStatus();
                                              if( gScInfo.InputAVIInfoReceived )
                                              {
                                                      gScInfo.InputColor = mstar_HDMIPacketColor();
                                                          if(gScInfo.InputColor == INPUT_RGB)
                                                              InputColorFormat = INPUTCOLOR_RGB;
                                                          else
                                                              InputColorFormat = INPUTCOLOR_YUV;
                                                      gScInfo.ColorChanged = 1;
                                                      mstar_HDMIHandleColor();                        
                                                      break;
                                              }
                                              Delay1ms( 20 );
                                              if (mStar_ValidTimingDetect())                  //120526 Modify
                                              {
                                                      SrcFlags |= SyncLoss;
                                                      Set_InputTimingChangeFlag();
                                                      break;
                                              }
                              
                                      }
              
                                  #if ENABLE_HDMI_1_4
                                      msHDMI_Check_3D_Mode_Chg(0);
                                  #endif
              
                                      gScInfo.OutputDataState = HDMI_DATA_OUTPUT_ON;
                                      mstar_HDMICheckAudio();
                                       gScInfo.InputTmdsType = TMDS_HDMI;
              
                              #if 0//DEBUG_PRINTDATA
                              printData( " TMDS_HDMI Color:%x", msReadByte( REG_0580 ));
                              #endif
                           
                                      //SC0_INPUT_SELECT(ISEL_HDMI_444); //msWriteByteMask(SC0_02, SCALER_ISEL_HDMI, BIT2|BIT1|BIT0);
                              //Delay1ms(100);                        //120526 Modify
                              }
                              else if(mstar_HDMITmdsGetType()==TMDS_DVI)
                              {           
                              #if ENABLE_DEBUG
                               DETECT_printMsg("===>TMDS_DVI");
                              #endif
                                      gScInfo.InputTmdsType = TMDS_DVI;
                                      //SC0_INPUT_SELECT(ISEL_DVI); //msWriteByteMask(SC0_02, SCALER_ISEL_DVI, BIT2|BIT1|BIT0);
                                      InputColorFormat = INPUTCOLOR_RGB;
              
              #if 0//DEBUG_PRINTDATA
                      printData( " TMDS_DVI Color:%x", msReadByte( REG_0580 ));
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 13  

              #endif
                          
                              }
                      }
              #endif
 713   2      
 714   2              // 121119 coding addition
 715   2              if(InputTimingChangeFlag)
 716   2                  return;
 717   2              SettingInputColorimetry();
 718   2      #endif
 719   2              if (!ReadyForChangeFlag)
 720   2              {
 721   3                  //if(SrcInputType==Input_Digital || SrcInputType==Input_Digital2)
 722   3                  //    CheckADC();
 723   3                  if (!mStar_FindMode())                                                                                                                                                              //my  find mode
 724   3                  // search mode index
 725   3                  {
 726   4                      Set_InputTimingChangeFlag(); // search mode faile
 727   4                      SrcFlags|=SyncLoss;                     //120526 Modify
 728   4                      return ;
 729   4                  }
 730   3              }
 731   2                      
 732   2              if (!UnsupportedModeFlag)
 733   2              //supported mode
 734   2              {
 735   3                  if (!ReadyForChangeFlag)
 736   3                  {
 737   4                      ReadModeSetting(); // restore user's settings from NVRAM for each mode                                                  //my read mod
             -e
 738   4                      Set_ReadyForChangeFlag();
 739   4                  }
 740   3      #if DisplayPowerOnLogo
 741   3                  if (DisplayLogoFlag)
 742   3                  {
 743   4                      return ;
 744   4                  }
 745   3      #endif                  
 746   3                      #if CHIP_ID ==CHIP_TSUMC ||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF        //130508 Modify
                                      if(CURRENT_INPUT_IS_VGA())
                                              drvDVI_PowerCtrl(DVI_POWER_DOWN);
                              #endif
 750   3                  if (mStar_SetupMode() == FALSE)                                                                                                                                             //my setup mode
 751   3                  // setup scaler
 752   3                  {
 753   4                      DETECT_printMsg("Setup Mode False!");
 754   4                      Set_InputTimingChangeFlag(); // setup mode failed
 755   4                      mStar_SetupFreeRunMode(); // setup freerun mode//FreeRunModeFlag=1
 756   4                      SrcFlags|=SyncLoss;//edit by yz.nie .for DCR ON,change timing quickly have white screen.
 757   4                      return ;
 758   4                  }
 759   3      
 760   3      
 761   3              }
 762   2              else
 763   2              {}
 764   2                       #if ENABLE_MHL || ENABLE_DP_INPUT
                              #if MS_PM       //20151022  Alpha, clr ucWakeupStatus to avoid cannot show nosignal OSD after MHL wake up 
             -(due to ucWakeupStatus = ePMSTS_MHL_ACT)
                              SET_PM_WAKEUP_NON();
                              #endif
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 14  

                               #endif
 769   2          }
 770   1              Set_ReadyForChangeFlag();
 771   1      #if     DisplayPowerOnLogo      
 772   1          if (DisplayLogoFlag)
 773   1          {
 774   2              return ;
 775   2          }
 776   1      #endif  
 777   1          if (SyncLossState() || UnsupportedModeFlag)
 778   1          {
 779   2          
 780   2              #if MWEFunction     //110223 Modify for turn on BF and change to the source of nosignal will show 
             -garbage
 781   2              
 782   2                  #if (CHIP_ID==CHIP_TSUMU)
                              msAccSetup( 0, 0, 0, 0 );
                          #endif
 785   2                  msAccOnOff(0);
 786   2              #endif
 787   2              #if Enable_Rotate180Func
                      mStar_SetupPath();
                      #endif          
 790   2                      
 791   2              mStar_SetupFreeRunMode(); // setup freerun mode
 792   2              Power_TurnOnGreenLed();
 793   2              // printMsg("Set Free Run 1");
 794   2          }
 795   1          else
 796   1          {
 797   2              WORD vfreq, hfreq;
 798   2      #if ENABLE_FREESYNC
                              if(IS_DP_FREESYNC())
                              {
                                      WORD u16PixClk, u16Htt;
                      
                                      u16PixClk = msAPI_combo_IPGetPixelClk();
                                      u16Htt = msAPI_combo_IPGetGetHTotal();
                                      if((u16Htt!=0)&&(SrcVTotal!=0))
                                      {
                                              hfreq = ((DWORD)u16PixClk * 100 + u16Htt/2)/u16Htt;
                                              vfreq = ((DWORD)hfreq * 1000 + SrcVTotal/2)/SrcVTotal;
                                      }
                              }
                              else
              #endif
 813   2              {
 814   3              hfreq = HFreq(SrcHPeriod);
 815   3              vfreq = VFreq(hfreq, SrcVTotal);
 816   3              }
 817   2              if(SrcFlags&bInterlaceMode)            
 818   2              {
 819   3                  vfreq *= 2;
 820   3              }
 821   2      
 822   2              #if DEBUG_MSG
 823   2              printData("==hfreq===========  %d",hfreq);
 824   2              printData("==Vfreq===========  %d",vfreq);
 825   2              #endif
 826   2                      
 827   2          #if BURST_MODE
 828   2          #if ENABLE_FREESYNC
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 15  

                      if(IS_HDMI_FREESYNC()||IS_HDMI_FREESYNC())
                      {
                          SetPWMFreq(240);//set it to a fix value in SetPWMFreq (240, 27000, ...)
                      }
                      else
                  #endif
 835   2              {
 836   3                              BYTE i=4;
 837   3                              while((vfreq*i)/10<220)//set pwm freq.>=220
 838   3                              {
 839   4                                      i++;
 840   4                              }
 841   3                              SetPWMFreq((vfreq*4)/10);
 842   3              }
 843   2          #endif
 844   2      #if ENABLE_FREESYNC
                      if(!IS_HDMI_FREESYNC())
              #endif
 847   2              {
 848   3              
 849   3               #if (FRAME_BFF_SEL != FRAME_BUFFER) //20130909 nick modify
 850   3                    #if ENABLE_FREESYNC
                               if(!IS_DP_FREESYNC())
                           #endif
 853   3                      {
 854   4                      if ( hfreq > MaxInputHFreq || vfreq > (PanelMaxVfreq) )// 121101 coding modified ( hfreq > MaxInputHFreq
             - || vfreq>PanelVsyncFreq*11 )
 855   4                      {
 856   5                              SrcFlags |= bUnsupportMode;
 857   5                              #if DEBUG_MSG
 858   5                              printMsg("Unsupport  1");
 859   5                              #endif
 860   5                      }
 861   4                      else if (hfreq<MinInputHFreq ||vfreq < MinInputVFreq )
 862   4                      {
 863   5                              if (SrcInputType != Input_VGA )//&& (SrcFlags&bInterlaceMode))   //charles
 864   5                                      SrcFlags &= !bUnsupportMode;
 865   5                              else
 866   5                                      SrcFlags |= bUnsupportMode;
 867   5                              #if DEBUG_MSG
 868   5                              printMsg("Unsupport  2");
 869   5                              #endif
 870   5      
 871   5                      }
 872   4                      }
 873   3               #endif
 874   3              }
 875   2      
 876   2                      if (StandardModeHeight<=400 ||
 877   2                              (StandardModeHeight==480 && (StandardModeGroup!=Res_848x480)))//SrcModeIndex!=0))//120911 Modify for TP
             -V request
 878   2              {
 879   3                  UserPrefAutoTimes = 1;
 880   3              }
 881   2      
 882   2      
 883   2              if (PowerOnFlag)
 884   2              // system is on power-off status
 885   2              {
 886   3                  Power_TurnOnGreenLed(); // turn on green led
 887   3              }
 888   2                      //Set_ShowInputInfoFlag();//071226
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 16  

 889   2          }
 890   1      
 891   1              #if BrightFreqByVfreq
 892   1              if(!SyncLossState())
 893   1              {
 894   2                      WORD vfreq, hfreq;
 895   2                      hfreq = HFreq( SrcHPeriod );
 896   2                      vfreq = VFreq( hfreq, SrcVTotal );
 897   2              if(SrcFlags&bInterlaceMode)             //130228 Modify
 898   2              {
 899   3                  vfreq *= 2;
 900   3              }
 901   2      
 902   2                      if( abs( vfreq - 500 ) < 10 ) //when Input Vfreq=50Hz,Set Brightness freq to 250Hz
 903   2                              SetPWMFreq( 250 );
 904   2                      else
 905   2                              SetPWMFreq(( vfreq * 4 ) / 10 );
 906   2              #if ENABLE_DEBUG
 907   2                      DETECT_printData("  BrightFreqByVfreq:%d", vfreq/10);
 908   2              #endif
 909   2      
 910   2              }
 911   1              #endif
 912   1      
 913   1          #if BURST_MODE
 914   1              if(FreeRunModeFlag)     //110715 Modify
 915   1              {
 916   2                      SetPWMFreq(250);                
 917   2              }
 918   1              else
 919   1          {
 920   2              WORD vfreq, hfreq;
 921   2              hfreq = HFreq(SrcHPeriod);
 922   2              vfreq = VFreq(hfreq, SrcVTotal);
 923   2              if(SrcFlags&bInterlaceMode)             //130228 Modify
 924   2              {
 925   3                  vfreq *= 2;
 926   3              }
 927   2                      if(abs(vfreq-500)<10)//when Input Vfreq=50Hz,Set Brightness freq to 250Hz
 928   2                              SetPWMFreq(250);
 929   2                      #if 0
                              if(abs(vfreq-720)<10)
                                      SetPWMFreq((vfreq*5)/10);
                              #endif
 933   2                      else
 934   2                              SetPWMFreq((vfreq*4)/10);
 935   2          }
 936   1          #endif
 937   1      
 938   1      #if 0   //20171226
                  if (!CableNotConnectedFlag || !SyncLossState())
                  {
                      if (DoBurninModeFlag)
                      {
                              drvOSD_FrameColorEnable(FALSE);//petit 20121122 disable background color function.
                      }
                  }
              #else
 947   1         drvOSD_FrameColorEnable(FALSE);
 948   1      #endif
 949   1      
 950   1          Clr_DoModeSettingFlag(); //0606
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 17  

 951   1      
 952   1          TermBuffer = StandardModeGroup;
 953   1      
 954   1      #if ENABLE_HDMI
                  if(CURRENT_INPUT_IS_TMDS() && !SyncLossState() && CURRENT_INPUT_IS_HDMI())//( (SrcInputType==Input_Dig
             -ital||SrcInputType==Input_Digital2))  //121130 Modify
                  {
                      if(gScInfo.InputTmdsType == TMDS_HDMI)
                          SC0_INPUT_SELECT(ISEL_HDMI_444);
                      else
                          SC0_INPUT_SELECT(ISEL_DVI);
                  }
              #endif
 963   1      #if 0 // 120525 coding move position to find
              #if ENABLE_HDMI
                  if(!SyncLossState() && mstar_HDMITmdsGetType()==TMDS_HDMI && SrcInputType>=Input_Digital)
                  {
                      BYTE ucCount=200;
              
                      while(ucCount--)
                      {
                          gScInfo.InputAVIInfoReceived=0;
                          mstar_HDMIGetPktStatus();
                          if(gScInfo.InputAVIInfoReceived)
                          {
                              gScInfo.InputColor=mstar_HDMIPacketColor();
                              gScInfo.ColorChanged=1;
                              mstar_HDMIHandleColor();
                              break;
                          }
                          Delay1ms(20);
                      }
                      gScInfo.OutputDataState=HDMI_DATA_OUTPUT_ON;
                      mstar_HDMICheckAudio();
              
                      if( TermBuffer == Res_1920x1080 || TermBuffer == Res_1280x720)
                      {
                              //msSetColorFomat( HDTV  );
                      }
                      
                      else //( TermBuffer == Res_720x576      || TermBuffer == Res_720x483    || TermBuffer == Res_720x480)
                      {
                              //msSetColorFomat( SDTV );
                      }
                              
                  }
                      
                      #if MS_DAC
                      if( gScInfo.InputTmdsType == TMDS_HDMI && (CURRENT_INPUT_IS_HDMI()||CURRENT_INPUT_IS_DVI()))// && 
             -(UserPrefAudioSource == AUDIO_DIGITAL))//SrcInputType >= Input_Digital )
                      //if (gScInfo.InputTmdsType ==TMDS_HDMI && SrcInputType>=Input_Digital) 
                      {
                      msAudioLineout_SourceSel( E_LINEOUT_FROM_DAC );
                      msAudioDPGA_SetVolume( E_AUDIO_LEFT_RIGHT_CH, 0x00 );
                      #if !USE_DAC_ADJ
                      msAudioLineOutGain( Def_DACGain );
                      #endif
                      }
                      else // line in to line out: 550mVrms
                      {
                      msAudioLineout_SourceSel( E_LINEOUT_FROM_LINEIN0 );
                      msAudioDPGA_SetVolume( E_AUDIO_LEFT_RIGHT_CH, 0x00 );
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 18  

                      #if !USE_DAC_ADJ
                      msAudioLineOutGain( 0x27 );
                      #endif
                      
                  }
                      msAudioEARout_Mute( FALSE );
                      #else           
                   //   if( gScInfo.InputTmdsType == TMDS_HDMI && CURRENT_INPUT_IS_HDMI()// && (UserPrefAudioSource == A
             -UDIO_DIGITAL))//SrcInputType >= Input_Digital )
                    //      hw_Audio_HDMI();
                    //  else
                    //      hw_Audio_PC();
                      #endif
              
                      #if DEBUG_HDMI
                      printData("gScInfo.InputTmdsType=%d",gScInfo.InputTmdsType);
                      #endif
              
              #endif
                      SettingInputColorimetry();
              #endif  
1031   1      
1032   1      #if AudioFunc
              #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUM9) || (CHIP_ID == CHIP_TSU
             -MF))   // reset audio FIFO
              msWriteByteMask(REG_1427, 0x10, 0x10);
              msWriteByteMask(REG_1427, 0x00, 0x10);
              #endif
              #if MS_DAC
                 #if DiaghtAudioInput
                  if((!(SyncLossState()&&CableNotConnectedFlag&&DoBurninModeFlag))
                      &&(CURRENT_INPUT_IS_DISPLAYPORT()
                      #if ENABLE_HDMI
                      ||( gScInfo.InputTmdsType == TMDS_HDMI && CURRENT_INPUT_IS_TMDS())
                      #endif
                      ))      //130909 petit //20131022 update
                  {
                  #if 1
                      msAudioLineout_SourceSel( E_LINEOUT_FROM_DAC );
              
                      #if(!USE_DAC_ADJ)       
                              msAudioDPGA_SetVolume( E_AUDIO_LEFT_RIGHT_CH, 0x0000 );  //20121004
                      #endif
              
                              //2 ½âÉùÒôÍ»±ä
                              #if EarphoneDet_Enable
                               if (HarphoneDet_Pin)
                               {
                                msAudioLineOutGain( 0x38F );
                               }
                               else
                               #endif 
                               {
                              msAudioLineOutGain( Def_DACGain );
                               }
                               
                      #endif
                  }
                  else // line in to line out: 550mVrms
                  #endif
                  {
                      #if 1
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 19  

                      msAudioLineout_SourceSel( E_LINEOUT_FROM_LINEIN0 );
                      
                      #if(!USE_DAC_ADJ)       
                         #if 1
                      msAudioDPGA_SetVolume( E_AUDIO_LEFT_RIGHT_CH, 0x0000 );
                          #endif
                      #endif
              
                              
              
                     msAudioLineOutGain( Def_DACGain );
              
                      #endif
                  }
                  msAudioEARout_Mute( FALSE );
                  
                  msAudioGainForceToggle();  // nick add 20130528 for Audio output delay error
              #endif
              
              #if All_AudioDet
                        if (HarphoneDet_Pin) 
                        {
                          bAudioInputStatus = AudioInput_Ear;
                              #if SWAP_LR_CHANNL
                              msWriteByte(REG_2C05, 0x00);
                              #endif
                         }
                        else
                        {     
                          bAudioInputStatus = AudioInput_Spk;
                              #if SWAP_LR_CHANNL
                              msWriteByte(REG_2C05, 0x10);
                              #endif
                              }       
              #endif
              
              #endif
1108   1      
1109   1      #if ENABLE_MHL_COUNT
                  if(!SyncLossState() && CURRENT_INPUT_MHL_CABLE_PLUGGED())
                  {
                      DETECT_printData("turn on:%d", MHLActionCount);
                      MHLActionCount = 0;
                  }
              #endif
1116   1      #if ENABLE_FREESYNC
                     if((UserprefFreeSyncMode==FreeSyncMenuItems_On)&&(CURRENT_INPUT_IS_DISPLAYPORT())&&(!SyncLossState(
             -)) && (!UnsupportedModeFlag)&&(!FreeRunModeFlag))
                       DCOffOnCounter=20;
                     else
                       DCOffOnCounter=0;
              #endif
1122   1      
1123   1          Power_TurnOnPanel(); // turn on panel
1124   1          
1125   1          #if AudioFunc
                              if( UnsupportedModeFlag || (SyncLossState()&&CableNotConnectedFlag&&BurninModeFlag))            //120215 M
             -odify
                                      {
                                            mStar_AdjustVolume(0);     
                                      }
                              else if(!FreeRunModeFlag)
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 20  

                                              mStar_AdjustVolume(UserPrefVolume);   
                  #endif
1133   1          
1134   1          
1135   1      #if ENABLE_FREESYNC     
                   if((OSDFreeSyncActionFlag))
                   {
                  #if FreeSyncMenu_Enable
                    if((MenuPageIndex == FreeSyncMenu))//||(MenuPageIndex == SFreesyncMenu))
                     Osd_Show();
                    else
                    #endif
                    {
                     Clr_OSDFreeSyncActionFlag();  
                     Menu_InitAction();
                    }
                   }
                   else
               #endif 
1150   1       
1151   1      // printData("ModeHandlerAA=========>>>%d", 1);
1152   1          Menu_InitAction(); // initial menu osd state
1153   1      }
1154          void mStar_PrepareForTimingChange(void)
1155          {
1156   1      
1157   1      #if ENABLE_DUAL_LINK
                if(CURRENT_INPUT_IS_DVI())
                  msDVIDualLinkMode(DVI_SINGLE_LINK);
               #endif
1161   1      
1162   1       #if ENABLE_HDMI // wait for checking
                   if( gScInfo.InputTmdsType == TMDS_HDMI )
                       mstar_HDMIAudioMute( HDMI_AUDIO_OFF );
                   mstar_HDMIInitialVariable();
                  //mstar_HDMIResetColorSpace();
                   mstar_HDMIRst(Reset_HDMIStatus);
               #endif
1169   1       
1170   1      
1171   1      #if ENABLE_DP_INPUT     //130603 william        
              #if AudioFunc                                                                                                           //å…ˆé™éŸ³
                       if(CURRENT_INPUT_IS_DISPLAYPORT())
                      {
                              hw_SetMute();
                      }
              #endif
              #endif
1179   1      
1180   1      #if AudioFunc
                      #if  CHIP_ID==CHIP_TSUMU
                              msAudioEARout_Mute(TRUE);
                      #else
                              msAudioDPGA_Mute();
                      #endif
                          hw_SetMute();
              #endif
1188   1      
1189   1      
1190   1      #if 0//def WH_REQUEST
                    #if WH_REQUEST_DDCCI_POWERSAVING
                        #if MS_PM
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 21  

                                Clr_DDCForcePowerSavingFlag(); 
                        #endif
                   #endif
              #endif
1197   1      
1198   1          Clr_ForcePowerSavingFlag();//(1)ForcePowerSavingFlag = 0å¼ºåˆ¶çœç”µä¿å­˜æ ‡å¿—                                                    //myï¼ˆ1ï¼‰
1199   1          PowerDownCounter = 0;
1200   1          InputColorFormat = INPUTCOLOR_RGB;
1201   1      #if DisplayPowerOnLogo  
1202   1          if (!DisplayLogoFlag)
1203   1      #endif          
1204   1          {
1205   2              if (PowerSavingFlag)//åˆ¤æ–­æ˜¯å¦å¼€æœºçŠ¶æ€  1ä¸ºå…³æœº                                                                                              //my
1206   2              {
1207   3                  Power_PowerOnSystem();
1208   3                  mStar_SetupFreeRunMode();//(2)SetupFreeRunModeflag = 1
1209   3               }
1210   2              else//------------------------------------------------------------------------  //(1ï¼Œ2)æ¥è¿™
1211   2              {
1212   3                  //if (PanelOnFlag)
1213   3                    mStar_SetupFreeRunMode();
1214   3                    
1215   3      #if ENABLE_FREESYNC
                             if(UserprefFreeSyncMode==FreeSyncMenuItems_On)
                             {
                              if(BackLightActiveFlag)
                               {
                                 hw_ClrBlacklit();
                               }
                             }
                              else
               #endif 
1225   3                      Power_TurnOffPanel();
1226   3              }
1227   2                      
1228   2      
1229   2              Osd_Hide();
1230   2      
1231   2          }
1232   1              
1233   1      
1234   1      #if UseINT
1235   1              mStar_EnableModeChangeINT(FALSE);
1236   1      #endif
1237   1      
1238   1          // 120601 coding addition
1239   1          drvADC_PowerCtrl(ADC_POWER_ON);
1240   1          drvDVI_PowerCtrl(DVI_POWER_ON);
1241   1      
1242   1          if (InputTimingStableFlag)          //ï¼ˆ1,2ï¼‰ä¸ºÂ·0                                       //63æ¬¡æ¡ä»¶æˆç«‹                                                     //my
1243   1          {   //é‡ç½®å›¾å½¢ç«¯å£ï¼Œé‡æ–°è®¡æ•°è¾“å…¥ hfreq å’Œ vtotal
1244   2              SC0_SCALER_RESET(GPR_B);//msWriteByte(SC0_F1, GPR_B); 
1245   2              ForceDelay1ms(3);
1246   2              SC0_SCALER_RESET(0);//msWriteByte(SC0_F1, 0);
1247   2              ForceDelay1ms(10);
1248   2          }
1249   1      
1250   1      
1251   1              
1252   1              //å¤ä½è¾“å…¥æ—¶åºç¨³å®šï¼Œç­‰å¾…æ—¶åºç¨³å®š
1253   1              Clr_InputTimingStableFlag(); // ï¼ˆ1,2ï¼‰InputTimingStableFlag =0                                                                           my
1254   1              InputTimingStableCounter = 0;                   //(1,2)InputTimingStableCounter = 0                                                                                                                                                     //my
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 22  

1255   1          SrcFlags &= ~(bUnsupportMode | bUserMode | bNativeMode);//ï¼ˆ1,2ï¼‰SrcFlags é«˜ä¸‰ä½æ¸…é›¶           
             -                               
1256   1      
1257   1      
1258   1      
1259   1      
1260   1              
1261   1          //msWriteByte(SC0_01, 0x00);        // disable double bufer.
1262   1          mStar_ScalerDoubleBuffer(FALSE);
1263   1          //msWriteByte(REGBK, REGBANKADC);
1264   1          //msWriteByte(SC0_01, 0x00);        // enable ADC's double bufer.
1265   1          //msWriteByte(REGBK, REGBANKSCALER);
1266   1          msWriteByteMask(SC0_E8,0,(BIT0|BIT1));
1267   1          msWriteByteMask(SC0_E9,0,(BIT0|BIT1));
1268   1      
1269   1      #if ENABLE_DP_INPUT
              if(CURRENT_INPUT_IS_DISPLAYPORT())
              {    
              #if DP_RESETHTT_PATCH
                  msWriteByteMask( REG_3602, BIT5,BIT5);
                  msWriteByteMask( REG_3602, 0,BIT5);
              #endif
              }
              #endif
1278   1          
1279   1              
1280   1      }
1281          //==========================================================
1282          Bool mStar_SyncLossStateDetect(void)
1283          {
1284   1          BYTE fStatus;
1285   1          Bool result = FALSE;                                                                                                                                           //æ— ä¿¡å·èµ°false
1286   1                      //DETECT_printMsg("Sync Loss Detect Function 1");
1287   1              fStatus = mStar_GetInputStatus();//ï¼ˆ2ï¼‰æžæ€§0x10                            //æ— ä¿¡å·å’Œè¿™é‡Œæ²¡ä»€ä¹ˆå…³ç³»äº†
1288   1          // printData("status %xH", fStatus);//msReadByte(INSTA));
1289   1          // printData("stable counter %d", InputTimingStableCounter);
1290   1          if (fStatus &SyncLoss)//(2)æœ‰ä¿¡å·ï¼Œæ¡ä»¶ä¸æˆç«‹
1291   1          {
1292   2              if(CURRENT_INPUT_IS_VGA())//( SrcInputType < Input_Digital )
1293   2              {
1294   3                  if(InputTimingStableCounter%ValidTimingStableCount == 0)
1295   3                      mStar_SetAnalogInputPort((g_bInputSOGFlag?FALSE:TRUE));                         //SOGä¸Žæ™®é€šRGB+HVåˆ‡æ¢
1296   3                              //DETECT_printMsg("Sync Loss Detect Function 2");
1297   3      
1298   3                  fStatus=mStar_GetInputStatus();
1299   3                  if(!(fStatus&SyncLoss))
1300   3                      goto SyncActive;
1301   3              }
1302   2              if (CableNotConnectedFlag)
1303   2              // no Cable
1304   2              {
1305   3                  if (!IsCableNotConnected())
1306   3                  {
1307   4                                      #if ENABLE_CABLESTATUSCHANGE_CAUSESYNCSTATUS
                              // 091009 coding, add condition for waking up from power saving, comfirmed to Mark
                              if(PowerSavingFlag)
                              {
                                  if(!(fStatus&SyncLoss))
                                  {
                                      Clr_CableNotConnectedFlag();
                                                              {
                                                                      #if Dual
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 23  

                                                                      SwitchPortCntr=0;
                                                                      #endif
                                              result = TRUE;
                                                              }
                                  }
                              }
                              else
                              {
                                  Clr_CableNotConnectedFlag();
                                                      {
                                                              #if Dual
                                                              SwitchPortCntr=0;
                                                              #endif
                                          result = TRUE;
                                                      }
                              }
                                              #else
1333   4                                      Clr_CableNotConnectedFlag();
1334   4                                      #endif
1335   4                  }
1336   3              }
1337   2              else if (IsCableNotConnected())
1338   2              // no Sync
1339   2              {
1340   3                  Set_CableNotConnectedFlag();
1341   3                      #if ENABLE_CABLESTATUSCHANGE_CAUSESYNCSTATUS
              
                                      hw_SetGreenLed();
                                      hw_ClrAmberLed();
              
              
                          result = TRUE;
                          #endif
1349   3              }
1350   2              if (PowerSavingFlag)
1351   2              {
1352   3                  if(CURRENT_INPUT_IS_TMDS())//( SrcInputType == Input_Digital || SrcInputType == Input_Digital2
             - )
1353   3                  {
1354   4      #if ((CHIP_ID == CHIP_TSUMC) || (CHIP_ID == CHIP_TSUMD) || (CHIP_ID == CHIP_TSUM9) || (CHIP_ID == CHIP_TSU
             -MF))
                              if(DVI_CLK_STABLE())
              #else
1357   4                      if(!DVI_CLOCK_IS_MISSING())//(!(msReadByte(SC0_CA) & 0x40)) // coding check stable or exis
             -t
1358   4      #endif
1359   4                      {
1360   5                          //Delay1ms(150);
1361   5                          Delay1ms(50);
1362   5                          mStar_PowerUp();
1363   5                          Delay1ms(50);
1364   5                                              //DETECT_printMsg("DVI clk exist when PwSv detect");
1365   5      
1366   5                          fStatus = mStar_GetInputStatus();
1367   5                          if (fStatus &SyncLoss)
1368   5                          {           
1369   6                                                    mStar_PowerDown();
1370   6                          }
1371   5                          else
1372   5                          {
1373   6                              result = TRUE;
1374   6                          }
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 24  

1375   5                      }
1376   4      
1377   4              #if ENABLE_MHL&& (CHIP_ID == CHIP_TSUM2)        // 120529 coding modified for MHL wakeup //120509 Modify
                              //if(CURRENT_INPUT_IS_HYBRID_MHL_HDMI())
                              //if(UserPrefInputSelectType == INPUT_PRIORITY_AUTO || UserPrefInputSelectType == INPUT_PRIORITY_DVI)
                              if(MHL_CHECK_CONDITION()) // 120614 coding 
                          if(mapi_mhl_WakeupDetect())
                          {      
                              result = TRUE;
                          }
                      #endif                
1386   4                  
1387   4                  }                                                                           //my
1388   3              }
1389   2          }
1390   1          else                                                                                                                //ï¼ˆ2ï¼‰bit2 bit 3è¢«æ¸…æŽ‰ SrcFlagséžsynclossçŠ¶æ€ï¼Œè¿”å›žtrue
1391   1          {
1392   2              SyncActive: result = TRUE;
1393   2          }
1394   1          if (result)
1395   1          {
1396   2              SrcFlags = (SrcFlags &0xF0) | fStatus;
1397   2          } // clear others flags, except sync informat (polarity & w/o)
1398   1          return result;
1399   1      }
1400          #if 1//2006-07-07 Andy
1401              Bool mStar_ValidTimingDetect(void)
1402              {
1403   1          BYTE fStatus;
1404   1              //DETECT_printMsg("Valid timing detect");
1405   1      
1406   1          fStatus = mStar_GetInputStatus();
1407   1          if( fStatus & SyncLoss )        // no sync//æœ‰ä¿¡å·ä¸èµ°è¿™é‡Œ
1408   1          {
1409   2              SrcFlags = ( SrcFlags & 0xF0 ) | fStatus; // clear others flags, except sync informat (polarity & 
             -w/o)
1410   2             
1411   2            DETECT_printMsg( "Valid Timing : Sync Loss" );//20121031
1412   2        
1413   2              return TRUE;
1414   2          }
1415   1          else//ï¼ˆ3ï¼‰
1416   1          {   //mStar_SyncLossStateDetectä¸­å¯å¾—åˆ°SrcFlagsï¼Œä¸¤è€…åˆ¤æ–­ä¸ç­‰è¯´æ˜Žä¿¡å·ä¸ç¨³å®šæˆ–åˆ‡æ¢åˆ
             -†è¾¨çŽ‡   
1417   2              if( SyncPolarity( SrcFlags ) != SyncPolarity( fStatus ) )    //å°†è¿™æ¬¡çš„æžæ€§å’Œä¸Šä¸€æ¬¡ä½œå¯
             -¹æ¯”        // Sync polarity changed
1418   2              {
1419   3                  SrcFlags = ( SrcFlags & 0xF0 ) | fStatus; // clear others flags, except sync informat (polarit
             -y & w/o)
1420   3                 
1421   3                 DETECT_printMsg( "Valid Timing : Sync polarity changed" );//20121031
1422   3                if(CURRENT_INPUT_IS_DISPLAYPORT())
1423   3                    return FALSE;
1424   3                else
1425   3                  return TRUE;
1426   3              }
1427   2              else                                            //(3)
1428   2              {
1429   3                  WORD tempPeriod;
1430   3                  SrcFlags = ( SrcFlags & 0xF0 ) | fStatus; // clear others flags, except sync informat (polarit
             -y & w/o)
1431   3      #if ENABLE_FREESYNC
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 25  

                          if(!IS_DP_FREESYNC())
              #endif
1434   3                  {   //è¯»HPEROID
1435   4                     tempPeriod = SC0_READ_HPEROID();//msRead2Byte(SC0_E4) & MASK_13BIT;
1436   4                     
1437   4                     #if DEBUG_FINDMODE  //20121031
                             DETECT_printData("HPeriod1 %d", tempPeriod);
                             #endif
1440   4                                 
1441   4                     if( InputTimingStableCounter == 0 )
1442   4                     {
1443   5                        SrcHPeriod = tempPeriod;
1444   5                     }
1445   4                                 
1446   4                     if( abs( tempPeriod - SrcHPeriod ) > HPeriod_Torlance )
1447   4                     // HPeriod changed
1448   4                     {
1449   5                        // 120425 coding addition
1450   5                        DETECT_printMsg("SrcHPeriod is out of torlance!");
1451   5                        tempPeriod = SC0_READ_HPEROID();//msRead2Byte(SC0_E4) & MASK_13BIT;
1452   5                        if( abs( tempPeriod - SrcHPeriod ) > HPeriod_Torlance )
1453   5                            return TRUE;
1454   5                     }
1455   4                  }
1456   3       
1457   3      #if ENABLE_FREESYNC
              #if ENABLE_DP_INPUT
                           
                            if(CURRENT_INPUT_IS_DISPLAYPORT())
                                {
                           if(DPRxGetDRRFlag())
                               {
                                   static WORD xdata u16PixelClock=0;
                                   WORD xdata u16temp = DPRxGetPixelClk();
                                   
                                           if(abs(u16PixelClock-u16temp)>8) // 5
                                           {
                                               u16temp = DPRxGetPixelClk();
                                               if(abs(u16PixelClock-u16temp)>8) // 5
                                               {
                                                   u16PixelClock = u16temp;
                                                   return TRUE;
                                               }
                                           }
                               }
                            }
              #endif
              #endif
1480   3      #if ENABLE_FREESYNC
                          if(!IS_HDMI_FREESYNC())
              #endif
1483   3                  {
1484   4                  tempPeriod = SC0_READ_VTOTAL();//msRead2Byte(SC0_E2) & MASK_11BIT;
1485   4      
1486   4                  #if DEBUG_FINDMODE  //20121031
                              DETECT_printData("  VTotal1 %d", tempPeriod);
                          #endif
1489   4                  if( InputTimingStableCounter == 0 )
1490   4                  {
1491   5                      // 100902 coding addition
1492   5                      Delay1ms( 100 );
1493   5                      tempPeriod = SC0_READ_VTOTAL();//msRead2Byte(SC0_E2) & MASK_11BIT;
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 26  

1494   5      
1495   5                      SrcVTotal = tempPeriod;
1496   5                  }
1497   4                  if( abs( tempPeriod - SrcVTotal ) > VTotal_Torlance )
1498   4                      // vtotal changed
1499   4                  {
1500   5                              DETECT_printMsg("SrcVTotal is out of torlance!");
1501   5      #if ENABLE_HDMI // 100902 coding addition
                              Delay1ms( 10 );
                              tempPeriod = SC0_READ_VTOTAL();//msRead2Byte(SC0_E2) & MASK_11BIT;
                              if( abs( tempPeriod - SrcVTotal ) > VTotal_Torlance ) // vtotal changed
              #endif
1506   5                          return TRUE;
1507   5                  }
1508   4      
1509   4                  }
1510   3      #if ENABLE_CHECK_TMDS_DE
                                      if( CURRENT_INPUT_IS_TMDS() )
                                      {
                                              if(!InputTimingStableFlag && (InputTimingStableCounter >= (ValidTimingStableCount-1)))
                                              {
                                                      SrcTMDSWidth = SC0_READ_AUTO_WIDTH();
                                                      SrcTMDSHeight = SC0_READ_AUTO_HEIGHT();
                                                      SrcTMDSHStart = SC0_READ_AUTO_START_H();
                                                      SrcTMDSVStart = SC0_READ_AUTO_START_V();
                                              }
                                      }
              #endif
1522   3                  if(( CURRENT_INPUT_IS_TMDS() ) && !FreeRunModeFlag )
1523   3                  {
1524   4                      tempPeriod = SC0_READ_AUTO_START_H();//msRead2Byte( SC0_80 ) & MASK_12BIT;
1525   4                      if( abs( tempPeriod - UserPrefHStart ) > HVStartTorlance )
1526   4                      {
1527   5                         
1528   5                          DETECT_printData( "HStart changed%d", tempPeriod );  //20121031
1529   5                         
1530   5                          return TRUE;
1531   5                      }
1532   4                      tempPeriod = SC0_READ_AUTO_START_V();//msRead2Byte( SC0_7E ) & MASK_11BIT;
1533   4                      if( abs( tempPeriod - UserPrefVStart ) > 2 )
1534   4                      {
1535   5                        
1536   5                        DETECT_printData( "HStart changed%d", tempPeriod );  //20121031
1537   5                     
1538   5                          return TRUE;
1539   5                  }
1540   4              }
1541   3          }
1542   2          }
1543   1          return FALSE;
1544   1      }
1545          #endif
1546          #if  (MS_VGA_SOG_EN||FindModeByVwidth || SHARP_VGA_50Hz_Timing)
1547          BYTE GetVSyncWidth(void)
1548          {
1549   1          BYTE u8VSyncWidth;
1550   1          SC0_VSYNC_WIDTH_REPORT(TRUE);//msWriteByteMask(SC0_FA,BIT0,BIT0);
1551   1          u8VSyncWidth=SC0_READ_VSYNC_WIDTH();//msReadByte(SC0_E2);
1552   1          SC0_VSYNC_WIDTH_REPORT(FALSE);//msWriteByteMask(SC0_FA,0,BIT0);
1553   1          //PRINT_DATA("u8VSyncWidth=%d",u8VSyncWidth);
1554   1          return u8VSyncWidth;
1555   1      }
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 27  

1556          #endif
1557          BYTE mStar_GetInputStatus(void)
1558          {
1559   1          BYTE fStatus = 0;                                                                                                                                   //my ï¼ˆ2ï¼‰è¿›æ¥æœ‰ä¿¡å·
1560   1          WORD inputValue;
1561   1          BYTE status;
1562   1      #if ENABLE_FREESYNC
                  if(!IS_DP_FREESYNC())
              #endif                                                                                                                          //ï¼ˆ2ï¼‰ä¿¡å·æœ‰æ•ˆ
1565   1          {   //è¯»Hperoidï¼ˆæ°´å¹³å‘¨æœŸé¢‘çŽ‡ï¼‰                                                                                                                                                                    my
1566   2             inputValue = SC0_READ_HPEROID();//msRead2Byte(SC0_E4) & MASK_13BIT;
1567   2             if( inputValue == 0x1FFF || inputValue < 10 )//åˆ¤æ–­ä¿¡å·æ˜¯å¦å€¼æ˜¯å¦ç­‰äºŽ0x1fffæˆ–å°äºŽ10ï¼
             -Œæ˜¯ä¿¡å·æ— æ•ˆ
1568   2             {
1569   3                 NOSYNC_printMsg(" H peroid is Out of range!");
1570   3                 fStatus |= bHSyncLoss; //å¯¹åº”bit2
1571   3             }
1572   2          }
1573   1      #if ENABLE_FREESYNC
                  if(!IS_HDMI_FREESYNC())
              #endif
1576   1          {//è¯»Vtotal                                                                                                                                                                                        my
1577   2          inputValue = SC0_READ_VTOTAL();//msRead2Byte(SC0_E2) & MASK_11BIT;
1578   2          if( inputValue == SC_MASK_V || inputValue < 200 ) // 130530 JUN Modify//åˆ¤æ–­ä¿¡å·æ˜¯å¦å€¼æ˜¯å¦ç­‰
             -äºŽ0xfffæˆ–å°äºŽ200ï¼Œæ˜¯ä¿¡å·æ— æ•ˆ
1579   2          {
1580   3              fStatus |= bVSyncLoss;//å¯¹åº”bit3
1581   3          }
1582   2          }
1583   1      //      DETECT_printData(" V total:  %d",inputValue);
1584   1      #if TMDS_SYNC_RECHECK
                  if(CURRENT_INPUT_IS_TMDS())
                  {
                      if(!(SC0_READ_SYNC_STATUS() & BIT6))
                      {
                          if(HsyncDisappearCounter < SYNC_DISAPPEAR_COUNT)
                              HsyncDisappearCounter ++;
                          else
                              fStatus |= bHSyncLoss;
                      }
                      else
                      {
                          HsyncDisappearCounter = 0;
                      }
              
                      if(!(SC0_READ_SYNC_STATUS() & BIT7))
                      {
                          if(VsyncDisappearCounter < SYNC_DISAPPEAR_COUNT)
                              VsyncDisappearCounter ++;
                          else
                              fStatus |= bVSyncLoss;
                      }
                      else
                      {
                          VsyncDisappearCounter = 0;
                      }
              
                      if(SC0_DE_ONLY_MODE())
                      {
                          if(TMDS_INPUT_WITHOUT_HV_SYNC())
                          {
                                              //DETECT_printMsg("DE ONLY");
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 28  

                              SC0_SET_DE_OLNY_MODE(FALSE);
                              SC0_GLITCH_REMOVAL_ENABLE(FALSE);  //20130422
                          }
                      }
                  }
              #endif        
1622   1                                                                                                              //è¯»ä¿¡å·æ³¢å½¢æžæ€§                                                                         my
1623   1          status = SC0_READ_SYNC_STATUS();//msReadByte(SC0_E1);
1624   1      
1625   1          fStatus |= ( status & 0x03 ); // Get input timing polarity//ä¿å­˜bit0 bit1åŠæžæ€§                  
             -            my
1626   1      #if ENABLE_FREESYNC
                      if(IS_DP_FREESYNC())
                          {
                          if(!(status&CSP_B))
                          {
                              fStatus|=bVSyncLoss;
                          }
                      }
              #endif
1635   1              //CURRENT_INPUT_IS_TMDSåˆ¤æ–­ä»€ä¹ˆä¿¡å·                                                                                       (2ï¼Œ3)æœ‰ä¿¡å·ï¼Œèµ°if
1636   1          if(CURRENT_INPUT_IS_TMDS())//( SrcInputType == Input_Digital || SrcInputType == Input_Digital2 ) 
1637   1          {
1638   2              if(DVI_DE_STABLE() == FALSE)//æ•°å­—ä½¿èƒ½ä¿¡å·ï¼Œæ²¡ä¿¡å·ä¸ºfalse
1639   2              {
1640   3                  if(DVI_DE_STABLE() == FALSE)
1641   3                  {
1642   4                      NOSYNC_printMsg("DVI DE unstable!");
1643   4                      fStatus |= SyncLoss;
1644   4                  }
1645   3              }
1646   2          }
1647   1          else if( SyncLossState() && !( fStatus & SyncLoss ) )        // å½“å½“å‰çŠ¶æ€ä¸ºæ— åŒæ­¥æ—¶ï¼Œè¾“å…
             -¥æ—¶åºæœ‰æ•ˆ
1648   1          {
1649   2              Delay1ms( 20 );
1650   2              if( InputTimingChangeFlag )
1651   2              {
1652   3                  return fStatus;
1653   3              }
1654   2              status = status & SC0_READ_SYNC_STATUS();//msReadByte(SC0_E1);
1655   2              if(( status & 3 ) != ( fStatus & 3 ) )
1656   2                  // polarity is stable
1657   2              {
1658   3                      NOSYNC_printMsg("polarity is unstable!");
1659   3                  fStatus |= SyncLoss;
1660   3              }
1661   2              else if( status & 0x30 )
1662   2                  // SOG or CSync input
1663   2              {
1664   3                  Delay1ms( 20 );
1665   3                  if( InputTimingChangeFlag )
1666   3                  {
1667   4                      return fStatus;
1668   4                  }
1669   3                  status = SC0_READ_SYNC_STATUS();//msReadByte(SC0_E1);           // Check if SOG/CSYNC is valid
1670   3                  if( abs( SC0_READ_VTOTAL() - inputValue ) > 2 )//( abs( (msRead2Byte( SC0_E2 )&MASK_11BIT) - i
             -nputValue ) > 2 )
1671   3                  {
1672   4                      NOSYNC_printMsg("SOG or CSYNC is not valid!");
1673   4                      fStatus |= SyncLoss;
1674   4                  }
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 29  

1675   3      #if  MS_VGA_SOG_EN
              
              else if (status&SOGD_B)
                          {
                              #if 0 //Jison 100330, not find mode yet, use STD_MODE_HEIGHT is not reasonable
                              u16InputValue = msRead2Byte(SC0_E2);
                              PRINT_DATA("V_Display %d",STD_MODE_HEIGHT);
                              if ((u16InputValue - STD_MODE_HEIGHT -6)< GetVSyncWidth())
                              {
                                PRINT_MSG("SOG Det Err");
                                u8FlagStatus |= SYNC_LOSS;
                              }
                              #else
                              {
                                  BYTE u8Tmp0=SC0_READ_POWER_DOWN_STATUS();//msReadByte(SC0_F0);
                                  BYTE u8Tmp1=SC0_READ_ADC_COAST_ENABLE_VALUE();//msReadByte(SC0_ED);
                                  BYTE u8Tmp2=SC0_READ_ADC_COAST_START_VALUE();//msReadByte(SC0_EE);
                                  BYTE u8Tmp3=SC0_READ_ADC_COAST_END_VALUE();//msReadByte(SC0_EF);
                                  BYTE i;
                                  //for get stable VSyncWidth
                                  SC0_SCALER_POWER_DOWN(0, BIT0|BIT1); //to get vsyncWidth
                                  SC0_ADC_COAST_ENABLE(0x21);//msWriteByte(SC0_ED, 0x21); //_NEW_SOG_WAKEUP_DET_
                                  SC0_ADC_COAST_START(0x08);//msWriteByte(SC0_EE, 0x08);
                                  SC0_ADC_COAST_END(0x05);//msWriteByte(SC0_EF, 0x05);
                                  Delay1ms(20);
                                  inputValue=0;
                                  for (i=0;i<10;i++)
                                  {
                                      inputValue=GetVSyncWidth();
                                      if (inputValue>15)
                                          break;
                                      ForceDelay1ms(2);
                                  }
                                  if (inputValue>15)
                                  {
                                    NOSYNC_printMsg("SOG Det Err!");
                                    fStatus |= SyncLoss;
                                  }
                                  SC0_ADC_COAST_ENABLE(u8Tmp1);//msWriteByte(SC0_ED, u8Tmp1);
                                  SC0_ADC_COAST_START(u8Tmp2);//msWriteByte(SC0_EE, u8Tmp2);
                                  SC0_ADC_COAST_END(u8Tmp3);//msWriteByte(SC0_EF, u8Tmp3);
                                  SC0_SCALER_POWER_DOWN(u8Tmp0, 0xFF);
                              }
                              #endif
                          }
              
              #endif
1722   3              }
1723   2          }
1724   1          return fStatus;                                                                                                     //(3)
1725   1      }
1726          
1727          Bool IsCableNotConnected( void )
1728          {
1729   1          // wait for coding
1730   1          return TRUE;
1731   1      }
1732          
1733          
1734          #if ENABLE_MHL
              #if CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD||CHIP_ID == CHIP_TSUM9 || CHIP_ID == CHIP_TSUMF// demo 
             -board        // 130717 william For G15 compiling warning
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 30  

              Bool CurrentInputMHLCablePlugged(void)//130711 william
              {
                  bit bresult = FALSE; // false means MHL cable NC
              
              
              #if ENABLE_MHL_C1
                  if(CURRENT_INPUT_IS_HDMI0())
                  {
                      if(IS_MHL_PORT0_CABLE_CONNECT())
                      {
                          bresult = TRUE;
              #if DEBUG_HDMI_MHL_CABLE_DETECT
              printData( "MHL0 CableConnect:%x", hwDVI0Cable_Pin );
              #endif
                      }
                      else
                      {
              #if DEBUG_HDMI_MHL_CABLE_DETECT
              printData( "MHL0 CableNotConnect:%x", hwDVI0Cable_Pin );
              #endif
                      }
                  }
                  else
              #endif
                      {
              #if ENABLE_MHL_C2
                  if(CURRENT_INPUT_IS_HDMI1())
                  {
                      if(IS_MHL_PORT1_CABLE_CONNECT())
                      {
                          bresult = TRUE;
              #if DEBUG_HDMI_MHL_CABLE_DETECT
              printData( "MHL1 CableConnect:%x", hwDVI0Cable_Pin );
              #endif
                      }
                      else
                      {
              #if DEBUG_HDMI_MHL_CABLE_DETECT
              printData( "MHL1 CableNotConnect:%x", hwDVI1Cable_Pin );
              #endif
                      }
                  }
                  else
              #endif
                      {
              #if ENABLE_MHL_C3
                  if(CURRENT_INPUT_IS_HDMI2())
                  {
                      if(IS_MHL_PORT2_CABLE_CONNECT())
                      {
              #if DEBUG_HDMI_MHL_CABLE_DETECT
              printData( "MHL2 CableConnect:%x", hwDVI0Cable_Pin );
              #endif
                          bresult = TRUE;
                      }
                      else
                      {
              #if DEBUG_HDMI_MHL_CABLE_DETECT
              printData( "MHL2 CableNotConnect:%x", hwDVI2Cable_Pin );
              #endif
                      }
                  }
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 31  

              #endif
                      }
                      }
              
                  return bresult;
              }
              
              #else
              #message "please coding CurrentInputMHLCablePlugged for MHL port"
              #endif
              #endif
1809          
1810          
1811          
1812          void SpeedupOrExtendSwitchPort(void)    //130625 nick
1813          {
1814   1      #if ENABLE_MHL
                  if(CURRENT_INPUT_MHL_CABLE_PLUGGED())
                  {
                      if(MHL_EXTEND_SYNCLOSS_COUNT())
                      {
                          InputTimingStableCounter = SyncLossExtenCount_MHL;
                          MHLExtenCountFlag = 1;
                      }
                  }
                  else
              #endif
1825   1      
1826   1      #if ENABLE_HDMI
                  if(HDMI_SPEEDUP_SWITCH_PORT())
                  {
                      InputTimingStableCounter = SyncLossStableCount;
                  }
              #endif
1832   1      
1833   1      #if (ENABLE_DP_INPUT&&(CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD||CHIP_ID == CHIP_TSUM9||CHIP_ID == C
             -HIP_TSUMF)) 
              //============================================================================================
              //  Please add Cable GND pin detect in  below condition 
              //  ((SrcInputType  == Input_Displayport)&&(msReadByte(REG_0232)&BIT0)&& (Cable GND pin Detect) )
              //===================================================================================== =======
                     if(Input_Displayport_C2 != Input_Nothing)
                     {
                            EnablePBSDM();                              // Set SDM Bit as Input
                           if(DPPB_SPEEDUP_SDM_GND()&&(InputTimingStableCounter >= 50))     //  Check SDM bit Port B  //
             -130912 nick
                          {
                              InputTimingStableCounter = SyncLossStableCount;
                          }
                     }    
                     if(Input_Displayport_C3  != Input_Nothing)
                     {
                            EnablePCSDM();                                // Set SDM Bit as Input
                            if(DPPC_SPEEDUP_SDM_GND()&&(InputTimingStableCounter >= 50))       // Check SDM bit Port C        
             -//130912 nick
                           {
                              InputTimingStableCounter = SyncLossStableCount;
                           }
                    }    
              #endif
1855   1      
1856   1      }
C51 COMPILER V9.01   DETECT                                                                08/17/2023 10:55:17 PAGE 32  

1857          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2340    ----
   CONSTANT SIZE    =    121    ----
   XDATA SIZE       =   ----       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
