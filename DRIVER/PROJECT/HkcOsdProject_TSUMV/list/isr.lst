C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE ISR
OBJECT MODULE PLACED IN .\obj\isr.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\KERNEL\SYSTEM\isr.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC;..\
                    -..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL\SYS
                    -TEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\INC)
                    - DEFINE(ModelName=MODEL_T24_TCL) DEBUG OBJECTEXTEND PRINT(.\list\isr.lst) OBJECT(.\obj\isr.obj)

line level    source

   1          #include "types.h"
   2          #include "board.h"
*** MESSAGE C320 IN LINE 337 OF ..\..\CONFIG\BOARD.H: "Please remember to disable the debug function!" 
   3          #include "global.h"
   4          #include "power.h"
   5          #include "debug.h"
   6          #include "debugDef.h"
   7          #include "ddc2bi.h"
   8          #include "Menudef.h"
   9          #include "ms_reg.h"
  10          #include "Ms_rwreg.h"
  11          #include "GPIO_DEF.h"
  12          #include "mcu.h"
  13          
  14          
  15          #if ENABLE_DP_INPUT 
              #include "drvDPRxApp.h"
              #endif
  18          
  19          #if ENABLE_HDMI || ENABLE_FREESYNC
              #include "msHDMI.h"
              #endif
  22          #if MS_DAC
              #include "drvDAC.h"
              #endif
  25          #if 0//USEFLASH
              extern WORD xdata ucFlashSaveCount;
              #endif
  28          
  29          
  30          #if ENABLE_UART1
              #include "UartControl.h"
              #endif
  33          #if  ENABLE_ANDROID_IR  //131008 Modify
              #include "drv_Ir.h"
              #endif
  36          
  37          #if ENABLE_DisplayPortTX
              #include "drvDPTxApp.h"
              #endif
  40          
  41          #if ENABLE_FREESYNC
              extern xdata Bool bHDMIFreesyncChk;
              #endif
  44          #if ! EANBLE_NEW_DCR_Functing
              extern BYTE xdata DCRStepTransCnt; // 081205 dcr test
              #endif
  47          //#define ReSyncTick          255//54 // 0.2 Second for resynchorize dubug process
  48          #if EXT_TIMER0_1MS || (ENABLE_MENULOAD && ML_USE_INT)||EXT_TIMER0_1S    //111223 Modify
  49          #define EnableExt0Interrupt             1
  50          #define EnableTime0Interrupt        1
  51          #elif ENABLE_SW_DOUBLE_BUFFER
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 2   

              #define EnableExt0Interrupt          1
              #define EnableTime0Interrupt        1
              #else
              #define EnableExt0Interrupt             0
              #define EnableTime0Interrupt        1
              #endif
  58          
  59          #if UseINT
  60          #define EnableExt1Interrupt             1
  61          #define EnableSerialPortInterrupt   1 // 0
  62          #else
              #define EnableExt1Interrupt             0
              #define EnableSerialPortInterrupt   1
              #endif
  66          
  67          #if ENABLE_UART1
              #define EnableSerialPortInterrupt1  1
              #else
  70          #define EnableSerialPortInterrupt1  0
  71          #endif
  72          
  73          
  74          #if  ENABLE_ANDROID_IR  //131008 Modify
              #define EnableTime1Interrupt        1
              #else
  77          #define EnableTime1Interrupt        0
  78          #endif
  79          
  80          #define EnableTime2Interrupt        0
  81          
  82          #if CHIP_ID == CHIP_TSUM2 || CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD || CHIP_ID == CHIP_TSUM9|| CHI
             -P_ID == CHIP_TSUMF
              #if ENABLE_MHL
              #include "DRVMHL.h"
              //extern xdata WORD g_u16S2PatchCnt;
              //extern BYTE xdata g_u16S2PatchCntFlag;
              //extern xdata WORD g_u16MHLHandlerCnt;
              //extern bit g_u16MHLHandlerCntFlag;
              #endif
              
              #if ENABLE_SW_DOUBLE_BUFFER
              extern XDATA StuSWDBCtrl SWDBCtrl;
              
              void IsrML(void)
              {
                  SWDBCtrl.ucSWDB_Counter = 0;
                  SWDBCtrl.ucSWDB_OnFire = 0;
                  SWDBCtrl.ucSWDB_Num = 1;
                  msRegs[REG_3C25] &=0x3F;
              }
              #endif
              
              #if 0
              void IsrBDMA(void)
              {      
                  if(_bit2_(msRegs[REG_3302]))
                  {
                      msRegs[REG_3302] = BIT2|BIT3;
                      msRegs[REG_12C4] = 0x00;
                      msRegs[REG_2080] = 0x27;
                  }
              }
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 3   

              #endif
              #endif
 115          
 116          #if UseINT
 117          void MuteVideoAndAudio(void)
 118          {
 119   1      #if !ENABLE_ExpanderIO
 120   1      #if ENABLE_HDMI
                  if( gScInfo.InputTmdsType == TMDS_HDMI )
                  {
                      hw_SetMute(); // for changed mode have "po-po"
                  }
              #endif
 126   1      #endif
 127   1      #if ENABLE_DP_INPUT     //130603 william        
              #if AudioFunc 
                      if(CURRENT_INPUT_IS_DISPLAYPORT())
                      {
                          hw_SetMute();
                      }
              #endif
              #endif
 135   1      
 136   1      
 137   1          hw_ClrBlacklit();
 138   1      
 139   1          Set_InputTimingChangeFlag();
 140   1          Clr_ForcePowerSavingFlag();
 141   1          InputTimingStableCounter = 0;
 142   1          SrcFlags |= SyncLoss;
 143   1      }
 144          
 145          void IsrModeChangeCheck(void)
 146          {
 147   1          BYTE xdata ucBank = MEM_SCREAD_BYTE(0x00);
 148   1      #if ((ENABLE_RTE && CHIP_ID==CHIP_TSUMF))
                  bit INT_VsyncEdge;
              #endif
 151   1      
 152   1          MEM_SCWRITE_BYTE(0, 0); //bk0
 153   1      
 154   1          if (INT_STATUS_A_ISR((MEM_SCREAD_BYTE(SC0_CE))&(BIT4|BIT5|BIT6|BIT7)) || (INT_STATUS_B_ISR((MEM_SCREAD
             -_BYTE(SC0_CF))&(BIT2))))
 155   1          {
 156   2              INT_SCALER_A_ISR(0);//MEM_SCWRITE_BYTE(SC0_CE, 0); //disable INT
 157   2              INT_SCALER_B_ISR(0);//MEM_SCWRITE_BYTE(SC0_CF, 0); //disable INT
 158   2              INT_STATUS_CLEAR_ISR();
 159   2              if (!SyncLossState())
 160   2              {
 161   3                  MuteVideoAndAudio();
 162   3              }
 163   2          }
 164   1      #if 0//ENABLE_FREESYNC
                  else if (INT_STATUS_A_ISR((MEM_SCREAD_BYTE(SC0_CE))&BIT3))
                  {
                      MEM_SCWRITE_BYTE(SC0_CC,(MEM_SCREAD_BYTE(SC0_CC)&(~BIT3)));
                      if(IS_HDMI_FREESYNC_ISR())
                      {
                          if(bHDMIFreesyncChk)
                              MEM_SCWRITE_BYTE(SC0_E8,(MEM_SCREAD_BYTE(SC0_E8)&(~BIT1))|BIT0);    //Enable force P mode
                          bHDMIFreesyncChk = FALSE;
                      }
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 4   

                  }
              #endif
 176   1      
 177   1      #if ( (ENABLE_RTE && CHIP_ID==CHIP_TSUMF))
                  INT_VsyncEdge = (Bool)(INT_STATUS_A_ISR(INT_VSYNC_EDGE));
                  if(INT_VsyncEdge)
                  {
                      INT_VsyncEdge = 0;
                      
              
              
                      MEM_SCWRITE_BYTE(SC0_CC,(~INT_VSYNC_EDGE));
                  }
              #endif
 188   1          
 189   1          MEM_SCWRITE_BYTE(0x00, ucBank);
 190   1      }
 191          #endif
 192          
 193          #if EXT_TIMER0_1S   // 2012-05-23
 194          void ms1SHandler( void )
 195          {
 196   1          g_oneSecondFlag=1;
 197   1          g_second++;
 198   1          if(g_second==60)
 199   1          {
 200   2              g_oneMinuteFlag=1;
 201   2              g_second=0;
 202   2              g_minute++;
 203   2              if(g_minute==60)
 204   2              {
 205   3                  g_minute=0;
 206   3                  g_hour++;
 207   3                  if(g_hour==24)
 208   3                      g_hour=0;
 209   3              }
 210   2          }
 211   1      }
 212          #endif
 213          
 214          #if EnableExt0Interrupt
 215          void EXT0Interrupt(void)interrupt 0
 216          {
 217   1              BYTE xdata ucStatus;
 218   1              ucStatus = msRegs[REG_2B10];
 219   1              
 220   1      #if ENABLE_MENULOAD && ML_USE_INT       //111223 Modify
                      if( ucStatus & _BIT5 )
                      {
                              extern BYTE xdata u8ML_Status;
                              u8ML_Status=msRegs[REG_3C27]&(ML_STS_BUSY|ML_STS_TRIG_ERR|ML_STS_CMD_ERR|ML_STS_DONE);
                              msRegs[REG_3C25]=msRegs[REG_3C25]&~(BIT7|BIT6); //disable ML
                      }
              #endif
 228   1      
 229   1              msRegs[REG_2B08] = ucStatus;
 230   1              msRegs[REG_2B08] = 0x00;
 231   1      
 232   1      
 233   1      #if CHIP_ID == CHIP_TSUM2 || CHIP_ID == CHIP_TSUMC || CHIP_ID == CHIP_TSUMD || CHIP_ID == CHIP_TSUM9|| CHI
             -P_ID == CHIP_TSUMF
              #if  ENABLE_SW_DOUBLE_BUFFER
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 5   

                  if(_bit5_(ucStatus))
                      IsrML();
              #endif
              #endif
 239   1      
 240   1      #if EXT_TIMER0_1MS||EXT_TIMER0_1S
 241   1              if( ucStatus & _BIT0 )
 242   1              ms1SHandler();
 243   1      #endif
 244   1      
 245   1              IE0 = 0;
 246   1      }
 247          #endif
 248          #if EnableTime0Interrupt
 249          extern WORD ms_Counter;
 250          extern xdata BYTE ReSyncCounter;
 251          //extern BYTE Second;
 252          extern BYTE xdata OsdCounter;
 253          extern BYTE xdata HotKeyCounter;
 254          extern BYTE xdata PowerDownCounter;
 255          void Time0Interrupt(void)interrupt 1
 256          {
 257   1          TH0 = g_ucTimer0_TH0;
 258   1          TL0 = g_ucTimer0_TL0; // timer 1 counter
 259   1              
 260   1          ms_Counter--;
 261   1      
 262   1      #if 0  //nick add for checking timer correct or not
              if(ms_Counter%2)
              {
                  hw_SetGreenLed();
              }
              else
              {
                  hw_ClrGreenLed();
              }
              #endif
 272   1      
 273   1      #if ENABLE_DEBUG
 274   1          if (ReSyncCounter)
 275   1          {
 276   2              ReSyncCounter--;
 277   2          }
 278   1      #endif
 279   1          
 280   1          if(bDelayFlag)
 281   1          {
 282   2              if(-- DelayCounter == 0)
 283   2                  bDelayFlag = 0;
 284   2          }
 285   1      
 286   1               // if(TimeOutCounter)
 287   1                //    TimeOutCounter--;
 288   1         if( bTimeOutCounterFlag )
 289   1               if( --u16TimeOutCounter == 0 )
 290   1                       bTimeOutCounterFlag = 0;
 291   1      #if ENABLE_DP_INPUT
              #if DP_FastTraining&&(CHIP_ID==CHIP_TSUMU)      //#if CHIP_ID == CHIP_TSUMC             //130116_3 Henry For DC Off/O
             -n,Dp Source Can not Wake Up   //130912 nick
                  if(u16DPRxStableTimeout)
                     u16DPRxStableTimeout--;
              #endif
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 6   

                          
              #if (CHIP_ID==CHIP_TSUMC ||CHIP_ID==CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF)  //130912 ni
             -ck
                  if( bDPRxStableTimeoutFlag )
                      if( --u16DPRxStableTimeout == 0 )
                          bDPRxStableTimeoutFlag = 0;
              #endif
              
              #if DPCTS
              #if DP_FastTraining&&(CHIP_ID==CHIP_TSUMC ||CHIP_ID==CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_T
             -SUMF)        //130912 nick
                          if( bCDR_HPDCntFlag )
                              if( --u16CDR_HPDCnt == 0 )
                                  bCDR_HPDCntFlag = 0;
              
                              if( bSkew_HPDCntFlag )
                                  if( --u16Skew_HPDCnt == 0 )
                                      bSkew_HPDCntFlag = 0;
              #endif          
              #if (CHIP_ID==CHIP_TSUMU)       //130912 nick
                      if(CDR_HPDCnt)
                         CDR_HPDCnt--;
              
                      if(Skew_HPDCnt)
                         Skew_HPDCnt--;
               #endif
              
              #if (CHIP_ID==CHIP_TSUM9 || CHIP_ID==CHIP_TSUMF)
                       if(gDPInfo.bPacketTimer )
                                 gDPInfo.bPacketTimer --;
              #endif
              
              #if CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF //130912 n
             -ick
              #if 1
               if( bAudio_BWCntFlag )
                   if( --u16Audio_BWCnt == 0 )
                       bAudio_BWCntFlag = 0;
              #else
                   if(Audio_BWCnt)           //20130716
                          Audio_BWCnt--;   
              #endif  
              #endif        
              #endif
              #endif
 338   1      #if ENABLE_TIME_MEASUREMENT   //need enable this if test Timer0
                      if( g_u16TimeMeasurementCounter )
                              g_u16TimeMeasurementCounter--;
              #endif
 342   1      
 343   1      #if MS_DAC && (CHIP_ID==CHIP_TSUMC ||CHIP_ID==CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF)
              #if InitialDACByISR
                                              if( bDAC_DePopCountFlag )
                                              {
                                                      if( (--w16DAC_DePopCounter) == 0 )
                                                      {
                                                              bDAC_DePopCountFlag = 0;
                                                              bDAC_DePopFlag = 1;
                                                      }
                                              }
              #endif
              #endif
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 7   

 355   1      
 356   1          if(!g_bMcuPMClock) // system runs at normal speed
 357   1          {
 358   2              if(bPanelDelayFlag)
 359   2              {
 360   3                  if(--PanelOffOnDelayCntr == 0)
 361   3                      bPanelDelayFlag = 0;
 362   3              }
 363   2      
 364   2      #if ENABLE_MHL
                  #if CHIP_ID == CHIP_TSUM2
                      if(g_u16S2PatchCntFlag)
                      {
                          if(--g_u16S2PatchCnt == 0)
                              g_u16S2PatchCntFlag = 0;
                      }
              
                      if(g_u16MHLHandlerCntFlag)
                      {
                          if(--g_u16MHLHandlerCnt == 0)
                              g_u16MHLHandlerCntFlag = 0;
                      }
                  #elif (CHIP_ID == CHIP_TSUMC)||(CHIP_ID == CHIP_TSUMD||CHIP_ID == CHIP_TSUM9|| CHIP_ID == CHIP_TSUMF)
                      mapi_mhl_CbusTimerInterrupt();
                  #endif
              #endif
 381   2      
 382   2      
 383   2          }
 384   1      
 385   1          if (ms_Counter == 0)
 386   1          {
 387   2      
 388   2              
 389   2              Set_SecondFlag();
 390   2              ms_Counter=SystemTick;
 391   2      
 392   2          }
 393   1      
 394   1          if((ms_Counter % 10) == 0)
 395   1          {
 396   2              Set_ms10Flag();
 397   2      
 398   2      #if ENABLE_MHL_COUNT
                      if(MHLActionCount)
                          MHLActionCount++;
              #endif
 402   2      
 403   2              if((ms_Counter % 50) == 0)
 404   2              {
 405   3                  Set_ms50Flag();
 406   3      
 407   3      #if CHIP_ID == CHIP_TSUM2
                          if(FPLLTimeoutCounter)
                              FPLLTimeoutCounter--;
              #endif
 411   3      
 412   3      #if  EANBLE_NEW_DCR_Functing
 413   3                        if(( ms_Counter % 100 ) == 0 )
 414   3                              {
 415   4                                      if ( DCRStepTransCnt )
 416   4                                      {
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 8   

 417   5                               DCRStepTransCnt --;
 418   5                                       }      
 419   4                              }
 420   3      #endif
 421   3      
 422   3                  
 423   3      #if 0//ENABLE_FREESYNC
                          if(( ms_Counter % 250 ) == 0 )
                          {
                              Set_ms250Flag();
                          }
              #endif
 429   3                  if ((ms_Counter % 500) == 0)
 430   3                  {
 431   4                      Set_ms500Flag();
 432   4                  }
 433   3              }
 434   2          }
 435   1          
 436   1          if(TF0)
 437   1          {
 438   2              TH0 = g_ucTimer0_TH0;
 439   2              TL0 = g_ucTimer0_TL0; // timer 1 counter
 440   2          }
 441   1      
 442   1          TF0 = 0; // timer 1 flag
 443   1      }
 444          #endif
 445          #if EnableExt1Interrupt
 446          //外部中断函数，接收数据触发中断
 447          
 448          void EXT1Interrupt(void)interrupt 2//每接收一次数据触发中断一次中断，到495行
 449          {
 450   1          BYTE xdata ucBank = MEM_SCREAD_BYTE(0x00);       //110926 Rick add to store the current bank - Verify 
             -A036, A039
 451   1      
 452   1      
 453   1      #if (ENABLE_DP_INPUT&& ((CHIP_ID == CHIP_TSUMC)||(CHIP_ID == CHIP_TSUMD)||(CHIP_ID == CHIP_TSUM9)||(CHIP_I
             -D == CHIP_TSUMF)))
                  if((_bit2_(msRegs[REG_2B2A]))||(_bit3_(msRegs[REG_2B2A])))
                  {
                          DPISR_AUX0();
                  }
              #endif
 459   1      
 460   1      
 461   1      #if (CHIP_ID == CHIP_TSUMC)||(CHIP_ID == CHIP_TSUMD) ||(CHIP_ID == CHIP_TSUM9)||(CHIP_ID == CHIP_TSUMF)
              
                  if(_bit7_(msRegs[REG_2B29]))
                  {
                         TMDSISR();
              #if ENABLE_DP_INPUT
                         DPISR();
              #endif
                  }
              
              #if ENABLE_MHL
                  if(_bit0_(msRegs[REG_2B2A]))
                  {
                      mapi_mhl_IsrHandler();
                  }
              
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 9   

              #endif
              
              #endif
 480   1      
 481   1      #if CHIP_ID == CHIP_TSUMU
              #if ENABLE_DP_INPUT
                      if(_bit6_(msRegs[REG_2B29])) { DPISR(); }       // read status
              #endif
              
              #if ENABLE_DisplayPortTX
                  if(_bit7_(msRegs[REG_2B29])) { DPISR_TX(); }   // read status
              #endif
              
              #endif
 491   1      
 492   1              
 493   1          if( INT_STATUS_D2B_ISR() )  //if( DDC_MCCS_IRQ_DET() )
 494   1          {
 495   2              ISR_DDC2Bi();//进入到DDC/CI的中断处理函数
 496   2          }
 497   1      
 498   1      #if UseINT
 499   1          if(INT_STATUS_DISP_ISR())
 500   1          {
 501   2              IsrModeChangeCheck();
 502   2          }
 503   1      #endif
 504   1          #if 0
              #if CHIP_ID == CHIP_TSUM2 || CHIP_ID == CHIP_TSUMC||CHIP_ID == CHIP_TSUM9||CHIP_ID == CHIP_TSUMF
                      if(_bit0_(msRegs[REG_2B2A]))
                          IsrBDMA();
              #elif CHIP_ID == CHIP_TSUMD
                  if(_bit5_(msRegs[REG_2B2A]))
                  {
                      IsrBDMA();
                  }
                  #endif
              #endif
 515   1      
 516   1      #if ENABLE_ANDROID_IR   //131008 Modify
              {
                  BYTE  final_status;                 // use idata to speedup
                  final_status = msRegs[REG_2B29];    // read status
                  if(IR_PinStatus(final_status))
                  {
                      IR_INT1();
                  }
                  msRegs[REG_2B29] = final_status;    // clear status
                  msRegs[REG_2B29] = 0x00;
              }
              #endif
 528   1      
 529   1      
 530   1          MEM_SCWRITE_BYTE(0x00, ucBank);
 531   1          IE1 = 0;
 532   1          //  EX1=1;
 533   1      }
 534          #endif
 535          
 536          
 537          #if EnableTime1Interrupt
              void Time1Interrupt( void ) interrupt 3
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 10  

              {
              #if 0
                          BYTE test;
                          test++;
                      
                          if(test%2)
                              hw_SetDDC_WP();
                          else
                              hw_ClrDDC_WP();
              #endif
              
                  TH1 = Timer1_TH1;  //200us reload
                  TL1 = Timer1_TL1;  //200us reload   
              
              #if ENABLE_ANDROID_IR   //131008 Modify
                  if(IRstateHighCount > 32)
                  {
                      return;
                  }
              
                  if(IR_Pin)  //high
                      IRstateHighCount++;
                  else        
                      IRstateLowCount++;      
              
                  if(TF1)
                  {
                      TH1=Timer1_TH1;  //200us reload
                      TL1=Timer1_TL1;  //200us reload 
                  }
              
                  TF1 = 0;
              #endif
              #if ENABLE_TIME_MEASUREMENT  //need enable this if test Timer1
                      if(bTimeMeasurementFlag)
                      {
                              if(--g_u16TimeMeasurementCounter == 0)
                                      bTimeMeasurementFlag = 0;
                      }
              #endif
              
              }
              #endif
 582          
 583          
 584          #if EnableSerialPortInterrupt
 585          
 586          
 587          void SerialPortInterrupt(void)interrupt 4
 588              {
 589   1              BYTE xdata sioData;
 590   1      
 591   1              if( RI )
 592   1              {
 593   2                  RI = 0;
 594   2                  sioData = SBUF;
 595   2                  if( SIORxIndex < _UART_BUFFER_LENGTH_ )
 596   2                  {
 597   3                      ReSyncCounter = ReSyncTick;
 598   3                      SIORxBuffer[SIORxIndex++] = sioData;
 599   3                  }
 600   2              }
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 11  

 601   1      
 602   1              if( TI )
 603   1              {
 604   2                  TI = 0;
 605   2                  TI0_FLAG = 1;
 606   2              }
 607   1      }
 608          
 609          
 610          #endif
 611          
 612          
 613          
 614          #if EnableTime2Interrupt
                  void Time2Interrupt(void)interrupt 5
                  {
                      TF2 = 0;
                  }
              #endif
 620          
 621          
 622          #if EnableSerialPortInterrupt1
              
              #if ENABLE_UART_CONTROL
              
              #define UART1UseChecksum                0
              void SerialPortInterrupt1( void ) interrupt 16
                  {
                      BYTE sioData;
                      if( S1CON & RI1)
                      {
                          S1CON &= ~RI1;    // clear RI1
                          sioData = S1BUF;        
                          if(rxARMUartIndex<(_ARM_UART_CMD_BUFFER_LENGTH_-1))
                          {
                                if(rxARMUartIndex==0)
                                {
                                    AndroidRxCounter = 2;
                                    }
                              rxARMUartBuffer[rxARMUartIndex++]=sioData;
                          }
                      #if 0   
                          switch(rxARMUartStatus)
                          {
                              case ARM_UART_IDLE:
                                  rxARMUartIndex=0;
                                  Checksum = sioData; // 20121101 ChunHan add
                                  rxARMUartBuffer[rxARMUartIndex++]=sioData;
                                  rxARMUartStatus=ARM_START_RECV;
                                  AndroidRxCounter = 3;
                              break;
                  
                              case ARM_START_RECV:
                              Checksum ^= sioData;    // 20121101 ChunHan add
                              if(rxARMUartIndex>(_ARM_UART_CMD_BUFFER_LENGTH_-1))
                              {
                                  rxARMUartStatus=ARM_UART_IDLE;
                                  break;
                              }
                              rxARMUartBuffer[rxARMUartIndex++]=sioData;
                              if(rxARMUartIndex>((ARM_UART_FIELD_PKTSIZE& ~DDC2Bi_CONTROL_STATUS_FLAG)+3))    // 2012110
             -1 ChunHan modify
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 12  

                              {
                                  rxARMUartStatus=ARM_UART_IDLE;
                                  rxARMUartIndex=0;
                                      rxARMUartFlag=1;
                              }
                              else if((rxARMUartIndex>(rxARMUartBuffer[2]+2) )&& ((rxARMUartBuffer[0]+ rxARMUartBuffer[1
             -])==0xFF))
                              {
                                  rxARMUartStatus=ARM_UART_IDLE;
                                  rxARMUartIndex=0;
                                  rxARMUartFlag=1;
                              }
                              else
                                  AndroidRxCounter = 3;
                  
                              break;
                  
                              default:
                                      rxARMUartStatus=ARM_UART_IDLE;
                                      rxARMUartIndex=0;
                  
                              break;
                          }
              #endif
                  
                      }
                      if( S1CON & TI1 )     // check TI1;
                      {
                          S1CON &= ~TI1;    // clear TI1
                          TI1_FLAG = 1;
                      }
                  }
              
              #else
              void SerialPortInterrupt1( void ) interrupt 16
              {
                  // SFR: 0x9B
                  // s1con        [7]: 0:9-bit        1: 8-bit
                  //              [6]: not used
                  //              [5]: multiple processor enable
                  //              [4]: reception enable
                  //              [3]: tb81
                  //              [2]: rb81
                  //              [1]: ti1
                  //              [0]: ri1
              
                      BYTE ucTmp;
              
                      if( S1CON & RI1 )     // check RI1;
                      {
                              S1CON &= ~RI1;    // clear RI1
                              ucTmp = S1BUF;
                              #if ENABLE_DEBUG
                              if( SIORxIndex < _UART_BUFFER_LENGTH_  ) // Protect buffer overflow
                              {
                                      ReSyncCounter = ReSyncTick;
                                      SIORxBuffer[SIORxIndex++] = ucTmp; // recieve byte
                              }
                              #endif
                      }
                      if( S1CON & TI1 )     // check TI1;
                      {
C51 COMPILER V9.01   ISR                                                                   08/17/2023 10:54:58 PAGE 13  

                              S1CON &= ~TI1;    // clear TI1
                              TI1_FLAG = 1;
                      }
              }
              
              #endif
              
              #endif
 731          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    616    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
