C51 COMPILER V9.01   DRVOSD                                                                08/17/2023 10:55:16 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DRVOSD
OBJECT MODULE PLACED IN .\obj\drvOSD.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\KERNEL\SCALER\drvOSD.c OPTIMIZE(SIZE) BROWSE INCDIR(..\..\DRIVER\INC;
                    -..\..\KERNEL\SCALER\INC;..\..\KERNEL\SYSTEM\INC;..\..\LIB\INC;..\..\PANEL\INC;..\..\BOARD;..\..\DRIVER\INC;..\..\KERNEL\
                    -SYSTEM\INC\AOC2011;..\..\DRIVER\extDEVICE\INC;..\..\MODEL;..\..\CONFIG;..\..\PANEL;..\..\UI\F_LOGO\INC;..\..\UI\HkcOsd\I
                    -NC) DEFINE(ModelName=MODEL_T24_TCL) DEBUG OBJECTEXTEND PRINT(.\list\drvOSD.lst) OBJECT(.\obj\drvOSD.obj)

line level    source

   1          
   2          #define _DRVOSD_C
   3          
   4          #include "types.h"
   5          #include "board.h"
*** MESSAGE C320 IN LINE 337 OF ..\..\CONFIG\BOARD.H: "Please remember to disable the debug function!" 
   6          #include "ms_reg.h"
   7          #include "drvOSD.h"
   8          #include "ms_rwreg.h"
   9          #include "msosd.h"
  10          #include "halrwreg.h"
  11          extern  xdata BYTE  OsdFontColor;
  12          
  13          #if 0//ENABLE_OSD_ROTATION
              WORD drvOSD_GetTxtCAStart(BYTE u8Wnd, BYTE u8XPos, BYTE u8YPos)
              {
                  BYTE u8LineOffset=msReadByte((u8Wnd<<5)+OSD2_12);
                  WORD u16CABase=msRead2Byte((u8Wnd<<5)+OSD2_10);
                  if ((msReadByte(OSD1_03)>>6)==1) //for 90 degree only
                      u16CABase=GET_CABASE_90_0(u16CABase,u8LineOffset);
                  
                  return (u16CABase+(WORD)u8YPos*u8LineOffset+u8XPos);
              }
              #endif
  24          
  25          #if defined(_MANHATTAN_OSD_)
              void drvOSD_DrawVContinuousChar(BYTE u8Wnd, BYTE u8XPos, BYTE u8YPos, BYTE u8Char, BYTE u8Num)
              {
                  WORD u16TempValue;
                  BYTE i;
                  BYTE u8DrawCode = (!(u8YPos & BIT7));
              
                  u8YPos &= 0x7F;
              
                  //u8Wnd<<=5;
                  //u16TempValue=msRead2Byte((u8Wnd)+OSD2_10)+(WORD)u8YPos*msReadByte((u8Wnd)+OSD2_12)+u8XPos; // get re
             -al address
                  u16TempValue=GET_TXT_CASTART(u8Wnd,u8XPos,u8YPos); // get real address
                  #define LINE_OFFSET u8Wnd
                  LINE_OFFSET=msReadByte((u8Wnd<<5)+OSD2_12);
                  for (i=0;i<u8Num;i++)
                  {
                       WRITE_CAFSRAM_ADDR();
                      msWrite2Byte(PORT_ATTR_ADDR, u16TempValue);
                       WRITE_ATTRIBUTE(); 
                      msWriteByte(PORT_ATTR_DATA, OsdFontColor);
                      u16TempValue+=LINE_OFFSET;
                  }
                  if (u8DrawCode)
                  {
                      for(i=0;i<u8Num;i++)
                      {
C51 COMPILER V9.01   DRVOSD                                                                08/17/2023 10:55:16 PAGE 2   

                          u16TempValue-=LINE_OFFSET;
                           WRITE_CAFSRAM_ADDR();      
                          msWrite2Byte(PORT_CODE_ADDR, u16TempValue);
                           WRITE_CODE(); 
                          msWriteByte(PORT_CODE_DATA, u8Char);
                      }
                  }
                  #undef LINE_OFFSET
              }
              #endif
  61          void drvOSD_DrawBlankPlane(BYTE u8Wnd,BYTE u8XPos,BYTE u8YPos,BYTE u8Width,BYTE u8Height)
  62          {
  63   1          BYTE xdata i,j;
  64   1          WORD xdata u16TempValue;
  65   1          BYTE xdata IsDrawCode=(!(u8YPos & BIT7));
  66   1      
  67   1          u8YPos&=0x7F;
  68   1          //u8Wnd<<=5;
  69   1          //u16TempValue=msRead2Byte((u8Wnd)+OSD2_10)+(WORD)u8YPos*msReadByte((u8Wnd)+OSD2_12)+u8XPos; // get re
             -al address
  70   1          u16TempValue=GET_TXT_CASTART(u8Wnd,u8XPos,u8YPos); // get real address
  71   1          #define LINE_OFFSET u8Wnd
  72   1          LINE_OFFSET=msReadByte((u8Wnd<<5)+OSD2_12);
  73   1          for (i = 0; i < u8Height; i++)
  74   1          {
  75   2               WRITE_CAFSRAM_ADDR();
  76   2              msWrite2Byte(PORT_ATTR_ADDR, u16TempValue);
  77   2               WRITE_ATTRIBUTE(); 
  78   2              for(j=0;j<u8Width;j++)
  79   2              {
  80   3                  msWriteByte(PORT_ATTR_DATA, OsdFontColor);
  81   3              }
  82   2              u16TempValue+=LINE_OFFSET;
  83   2          }
  84   1          if (!IsDrawCode)
  85   1              return;
  86   1          u16TempValue-=(LINE_OFFSET*u8Height); // recover real address
  87   1          for (i = 0; i < u8Height; i++)
  88   1          {
  89   2               WRITE_CAFSRAM_ADDR();
  90   2              msWrite2Byte(PORT_CODE_ADDR, u16TempValue);
  91   2               WRITE_CODE();   
  92   2              for(j=0;j<u8Width;j++)
  93   2              {
  94   3                  msWriteByte(PORT_CODE_DATA, SPACE_FONT);
  95   3              }
  96   2              u16TempValue+=LINE_OFFSET;
  97   2          }
  98   1          #undef LINE_OFFSET
  99   1      
 100   1      }
 101          
 102          void drvOSD_SetWndLineOffset(BYTE u8Wnd, BYTE u8LineOffset)
 103          {
 104   1          msWriteByte((u8Wnd<<5)+OSD2_12,u8LineOffset);
 105   1      }
 106          #if !ENABLE_MENULOAD//||!ENABLE_SW_DOUBLE_BUFFER
 107          void drvOSD_SetWndHPosition(BYTE u8Wnd, WORD u16HStart, WORD u16HEnd)
 108          {
 109   1          u8Wnd<<=5;
 110   1          msWrite2Byte((u8Wnd)+OSD2_04,u16HStart);
 111   1          msWrite2Byte((u8Wnd)+OSD2_08,u16HEnd);
C51 COMPILER V9.01   DRVOSD                                                                08/17/2023 10:55:16 PAGE 3   

 112   1      }
 113          void drvOSD_SetWndVPosition(BYTE u8Wnd, WORD u16VStart, WORD u16VEnd)
 114          {
 115   1          u8Wnd<<=5;
 116   1          msWrite2Byte((u8Wnd)+OSD2_06,u16VStart);
 117   1          msWrite2Byte((u8Wnd)+OSD2_0A,u16VEnd);
 118   1      }
 119          #endif
 120          WORD drvOSD_GetWndInfo(BYTE u8Wnd,BYTE u8Info)
 121          {
 122   1          u8Wnd<<=5;
 123   1          if (u8Info==OSD_WND_INFO_H_START)
 124   1              return  msRead2Byte((u8Wnd)+OSD2_04);
 125   1          if (u8Info==OSD_WND_INFO_V_START)
 126   1              return msRead2Byte((u8Wnd)+OSD2_06);
 127   1          if (u8Info==OSD_WND_INFO_V_END)
 128   1              return msRead2Byte((u8Wnd)+OSD2_0A);
 129   1          if (u8Info==OSD_WND_INFO_LINE_OFFSET)
 130   1              return msReadByte((u8Wnd)+OSD2_12);
 131   1          if (u8Info==OSD_WND_INFO_CABASE)
 132   1              return msRead2Byte((u8Wnd)+OSD2_10);
 133   1          return 0;
 134   1      }
 135          void drvOSD_SetWndOn(BYTE u8Wnd,Bool u8On)
 136          {
 137   1          msWriteByteMask((u8Wnd<<5)+OSD2_00,(u8On?BIT0:0),BIT0);
 138   1      }
 139          void drvOSD_SetWndCtrl(BYTE u8Wnd, BYTE u8CtrlType, WORD u16Value,WORD u16Mask)
 140          {
 141   1          u8Wnd<<=5;
 142   1          if (u8CtrlType==OSD_WND_CTRL0)
 143   1              msWrite2ByteMask((u8Wnd)+OSD2_00,u16Value,u16Mask);
 144   1          else if (u8CtrlType==OSD_WND_CTRL1)
 145   1              msWrite2ByteMask((u8Wnd)+OSD2_02,u16Value,u16Mask);
 146   1          else if (u8CtrlType==OSD_WND_CTRL2)
 147   1              msWrite2ByteMask((u8Wnd)+OSD2_14,u16Value,u16Mask);
 148   1          else if (u8CtrlType==OSD_WND_CTRL3)
 149   1              msWrite2ByteMask((u8Wnd)+OSD2_1A,u16Value,u16Mask);
 150   1      }
 151          void drvOSD_SetWndFixAlpha(BYTE u8Wnd,BYTE u8Lvl,BYTE u8Value)
 152          {
 153   1          u8Wnd<<=5;
 154   1          if (u8Lvl==OSD_ALPHA_OUT)
 155   1              msWriteByteMask((u8Wnd)+OSD2_0C,u8Value,0x3F);
 156   1          else if (u8Lvl==OSD_ALPHA_LV1)
 157   1              msWriteByteMask((u8Wnd)+OSD2_0D,u8Value,0x3F);
 158   1          else if (u8Lvl==OSD_ALPHA_LV2)
 159   1              msWriteByteMask((u8Wnd)+OSD2_19,u8Value,0x3F);
 160   1      }
 161          void drvOSD_SetWndFixColor(BYTE u8Wnd,BYTE u8Red,BYTE u8Green,BYTE u8Blue)
 162          {
 163   1          u8Wnd<<=5;
 164   1          msWriteByte((u8Wnd)+OSD2_16,u8Red);
 165   1          msWriteByte((u8Wnd)+OSD2_17,u8Green);
 166   1          msWriteByte((u8Wnd)+OSD2_18,u8Blue);
 167   1      }
 168          void drvOSD_SetWndShiftPixel(BYTE u8Wnd,u8X,u8Y)
 169          {
 170   1          u8Wnd<<=5;
 171   1          msWriteByte((u8Wnd)+OSD2_0E,u8X);
 172   1          msWriteByte((u8Wnd)+OSD2_0F,u8Y);
 173   1      }
C51 COMPILER V9.01   DRVOSD                                                                08/17/2023 10:55:16 PAGE 4   

 174          void drvOSD_SetWndCABaseAddr(BYTE u8Wnd,WORD u16Addr)
 175          {
 176   1          msWrite2Byte((u8Wnd<<5)+OSD2_10,u16Addr);
 177   1      }
 178          void drvOSD_SetWndFixAttr(BYTE u8Wnd,BYTE u8Enable,BYTE u8Attr)
 179          {
 180   1          u8Wnd<<=5;
 181   1          #if CHIP_ID>=CHIP_TSUM2
                  msWriteByteMask((u8Wnd)+OSD2_15,(u8Enable?(BIT7|BIT6):0),BIT7|BIT6);
                  #else
 184   1          #endif
 185   1          msWriteByte((u8Wnd)+OSD2_1A,u8Attr);
 186   1          msWriteByteMask((u8Wnd)+OSD2_1B,(u8Enable?BIT7:0),BIT7);
 187   1      }
 188          #if CHIP_ID >= CHIP_TSUM2
              #define DEF_ARRANGE_WIN(i) void OSDArrangeWin##i(WORD hs, WORD he, WORD vs, WORD ve) { \
                  SET_OSD_WIN_REG_WIN##i##_HEND_PIX(he); \
                  SET_OSD_WIN_REG_WIN##i##_HSTR_PIX(hs); \
                  SET_OSD_WIN_REG_WIN##i##_VEND_PIX(ve); \
                  SET_OSD_WIN_REG_WIN##i##_VSTR_PIX(vs); }
              
              #define DEF_BLENDING_WIN(i) void OSDBlendingWin##i(BYTE r_gd, BYTE g_gd, BYTE b_gd, BYTE fix_r, BYTE fix_g
             -, BYTE fix_b, BYTE l1a_sel, BYTE fix_al1, BYTE l2a_sel, BYTE fix_al2, BYTE outa_sel, BYTE fix_aout) { \
                  SET_OSD_WIN_REG_WIN##i##_CLR_B_SEL(b_gd); \
                  SET_OSD_WIN_REG_WIN##i##_CLR_G_SEL(g_gd); \
                  SET_OSD_WIN_REG_WIN##i##_CLR_R_SEL(r_gd); \
                  SET_OSD_WIN_REG_WIN##i##_FIX_CLR_R(fix_r); \
                  SET_OSD_WIN_REG_WIN##i##_FIX_CLR_G(fix_g); \
                  SET_OSD_WIN_REG_WIN##i##_FIX_CLR_B(fix_b); \
                  SET_OSD_WIN_REG_WIN##i##_FIX_ALPHA_LV1(fix_al1); \
                  SET_OSD_WIN_REG_WIN##i##_FIX_ALPHA_LV2(fix_al2); \
                  SET_OSD_WIN_REG_WIN##i##_FIX_ALPHA_OUT(fix_aout); \
                  SET_OSD_WIN_REG_WIN##i##_LV1_A_SEL(l1a_sel); \
                  SET_OSD_WIN_REG_WIN##i##_LV2_A_SEL(l2a_sel); \
                  SET_OSD_WIN_REG_WIN##i##_OUT_A_SEL(outa_sel); }
              #if 0
              SET_OSD_WIN_REG_WIN0_CLR_B_SEL(r_gd); \
              SET_OSD_WIN_REG_WIN0_CLR_G_SEL(g_gd); \
              SET_OSD_WIN_REG_WIN0_CLR_R_SEL(b_gd); \
              SET_OSD_WIN_REG_WIN0_FIX_CLR_R(fix_r);
              SET_OSD_WIN_REG_WIN0_FIX_CLR_G(fix_g);
              SET_OSD_WIN_REG_WIN0_FIX_CLR_B(fix_b);
              SET_OSD_WIN_REG_WIN0_FIX_ALPHA_LV1(fix_al1); \
              SET_OSD_WIN_REG_WIN0_FIX_ALPHA_LV2(fix_al2); \
              SET_OSD_WIN_REG_WIN0_FIX_ALPHA_OUT(fix_aout); \
              SET_OSD_WIN_REG_WIN0_LV1_A_SEL(l1a_sel); \
              SET_OSD_WIN_REG_WIN0_LV2_A_SEL(l2a_sel); \
              SET_OSD_WIN_REG_WIN0_OUT_A_SEL(outa_sel); }
              #endif
              
              
              #define DEF_CONF_SRAM_WIN(i) void OSDConfSramWin##i(BYTE fh, WORD base_addr, BYTE l_off, BYTE sh_x, BYTE s
             -h_y) { \
                  SET_OSD_WIN_REG_WIN##i##_CHARHIGH(fh); \
                  SET_OSD_WIN_REG_WIN##i##_BASE(base_addr); \
                  SET_OSD_WIN_REG_WIN##i##_LINE_OFFSET(l_off); \
                  SET_OSD_WIN_REG_WIN##i##_SHIFT_PIX_X(sh_x); \
                  SET_OSD_WIN_REG_WIN##i##_SHIFT_PIX_Y(sh_y); }
              #if 0
              SET_OSD_WIN_REG_WIN0_CHARHIGH(fh); \
              SET_OSD_WIN_REG_WIN0_BASE(base_addr); \
              SET_OSD_WIN_REG_WIN0_LINE_OFFSET(l_off); \
C51 COMPILER V9.01   DRVOSD                                                                08/17/2023 10:55:16 PAGE 5   

              SET_OSD_WIN_REG_WIN0_SHIFT_PIX_X(sh_x); \
              SET_OSD_WIN_REG_WIN0_SHIFT_PIX_Y(sh_y); }
              #endif
              
              #define DEF_CONF_SRAM_TEXT_WIN(i) void OSDConfSramTextWin##i(BYTE fh, WORD base_addr, BYTE l_off, BYTE sh_
             -x, BYTE sh_y) { \
                  SET_OSD_WIN_REG_WIN##i##_CHARHIGH(fh); \
                  SET_OSD_WIN_REG_WIN##i##_BASE_TX(base_addr); \
                  SET_OSD_WIN_REG_WIN##i##_LINE_OFFSET_TX(l_off); \
                  SET_OSD_WIN_REG_WIN##i##_SHIFT_PIX_X(sh_x); \
                  SET_OSD_WIN_REG_WIN##i##_SHIFT_PIX_Y(sh_y); }
              #if 0
              SET_OSD_WIN_REG_WIN0_CHARHIGH(fh); \
              SET_OSD_WIN_REG_WIN0_BASE_TX(base_addr); \
              SET_OSD_WIN_REG_WIN0_LINE_OFFSET_TX(l_off); \
              SET_OSD_WIN_REG_WIN0_SHIFT_PIX_X(sh_x); \
              SET_OSD_WIN_REG_WIN0_SHIFT_PIX_Y(sh_y); }
              #endif
              
              #define DEF_CONF_GD_TG(i) void OSDConfGDTimingGenerator##i(unsigned hs, unsigned he, unsigned vs, unsigned
             - ve) { \
                  _CTRL_OSD_GD_REGISTERS(); \
                  SET_OSD_GD_REG_GD_TG##i##_HST(hs); \
                  SET_OSD_GD_REG_GD_TG##i##_VST(vs); \
                  SET_OSD_GD_REG_GD_TG##i##_HEND(he); \
                  SET_OSD_GD_REG_GD_TG##i##_VEND(ve); }
              #if 0
              SET_OSD_GD_REG_GD_TG0_HST(hs); \
              SET_OSD_GD_REG_GD_TG0_VST(vs); \
              SET_OSD_GD_REG_GD_TG0_HEND(he); \
              SET_OSD_GD_REG_GD_TG0_VEND(ve); }
              #endif
              
              
              void OSDSetMask0(BYTE item, BYTE v)
              {
                  _CTRL_OSD_CTRL_REGISTERS();
                  SET_OSD_CTRL_REG_TRIG_MODE(_TRIG_MODE_P0_ADDR);
                  SET_OSD_CTRL_REG_WR_PORT(item);
                  SET_OSD_CTRL_REG_TRIG_MODE(_TRIG_MODE_P0_MASK);
                  SET_OSD_CTRL_REG_WR_PORT(v);
              }
              
              /*
              void OSDSetColorKey0(BYTE item, BYTE v)
              {
                  _CTRL_OSD_CTRL_REGISTERS();
                  SET_OSD_CTRL_REG_TRIG_MODE(_TRIG_MODE_P0_ADDR);
                  SET_OSD_CTRL_REG_WR_PORT(item);
                  SET_OSD_CTRL_REG_TRIG_MODE(_TRIG_MODE_P0_CKEY);
                  SET_OSD_CTRL_REG_WR_PORT(v);
              }
              */
              
              void OSDConfGDCurveH(BYTE ci, BYTE pixel_init, BYTE delta_init, 
                              BYTE step, BYTE data_sign, BYTE delta_sign, BYTE delta, WORD length0, WORD length1,
                              BYTE hv_sign, BYTE overflow_en, BYTE md)
              {
                  BYTE tmp;
                  
                  _CTRL_OSD_GD_REGISTERS();
                  CLR_OSD_GD_REG_CURVE_RDATA_EN();
C51 COMPILER V9.01   DRVOSD                                                                08/17/2023 10:55:16 PAGE 6   

                  _CTRL_OSD_CTRL_REGISTERS();
                  SET_OSD_CTRL_REG_TRIG_MODE(_TRIG_MODE_GD_ADDR);
                  ci <<= 1; SET_OSD_CTRL_REG_WR_PORT(ci);
                  SET_OSD_CTRL_REG_TRIG_MODE(_TRIG_MODE_GD_DATA);
                  SET_OSD_CTRL_REG_WR_PORT(pixel_init);
                  SET_OSD_CTRL_REG_WR_PORT(delta_init);
                  SET_OSD_CTRL_REG_WR_PORT(step);
                  tmp = ( (0 != data_sign) << 7 ) | ( (0 != delta_sign) << 6 ) | ( delta & 0x3f );
                  SET_OSD_CTRL_REG_WR_PORT(tmp);
                  SET_OSD_CTRL_REG_WR_PORT(length0&0xff);
                  tmp = ( (length1 & 0x0f) << 4 ) | ( (length0 & 0x700) >> 8 );
                  SET_OSD_CTRL_REG_WR_PORT(tmp);
                  tmp = ( ( 0 != hv_sign ) << 7 ) | ( (length1 & 0x7f0) >> 4 );
                  SET_OSD_CTRL_REG_WR_PORT(tmp);
                  tmp = ( (0 != overflow_en) << 7 ) | (md & 0x3);
                  SET_OSD_CTRL_REG_WR_PORT(tmp);
              }
              
              
              void OSDConfGDCurveV(BYTE ci, BYTE pixel_init, BYTE delta_init, 
                              BYTE step, BYTE data_sign, BYTE delta_sign, BYTE delta, WORD length0, WORD length1,
                              BYTE overflow_en, BYTE md)
              {
                  BYTE tmp;
                  
                  _CTRL_OSD_GD_REGISTERS();
                  CLR_OSD_GD_REG_CURVE_RDATA_EN();
                  _CTRL_OSD_CTRL_REGISTERS();
                  SET_OSD_CTRL_REG_TRIG_MODE(_TRIG_MODE_GD_ADDR);
                  ci <<= 1; ci++; SET_OSD_CTRL_REG_WR_PORT(ci);
                  SET_OSD_CTRL_REG_TRIG_MODE(_TRIG_MODE_GD_DATA);
                  SET_OSD_CTRL_REG_WR_PORT(pixel_init);
                  SET_OSD_CTRL_REG_WR_PORT(delta_init);
                  SET_OSD_CTRL_REG_WR_PORT(step);
                  tmp = ( (0 != data_sign) << 7 ) | ( (0 != delta_sign) << 6 ) | ( delta & 0x3f );
                  SET_OSD_CTRL_REG_WR_PORT(tmp);
                  SET_OSD_CTRL_REG_WR_PORT(length0);
                  tmp = ( (length1 & 0x0f) << 4 ) | ( (length0 & 0x700) >> 8 );
                  SET_OSD_CTRL_REG_WR_PORT(tmp);
                  tmp = ( (length1 & 0x7f0) >> 4 );
                  SET_OSD_CTRL_REG_WR_PORT(tmp);
                  tmp = ( (0 != overflow_en) << 7 ) | (md & 0x3);
                  SET_OSD_CTRL_REG_WR_PORT(tmp);
              }
              
              void OSDGDCurveSelectionForWindow(BYTE gi, BYTE wi, BYTE ci)
              {
              #define SET_GDX_WINY_CURV_SEL(gi, wi, ci) SET_OSD_GD_REG_GD##gi##_WIN##wi##_CUR_SEL(ci);
                  
              #define DEF_SET_GD_WINX_CURV_SEL(gi, wi, ci) switch (wi) { \
                      case 0: SET_GDX_WINY_CURV_SEL(gi, 0, ci); break; \
                      case 1: SET_GDX_WINY_CURV_SEL(gi, 1, ci); break; \
                      case 2: SET_GDX_WINY_CURV_SEL(gi, 2, ci); break; \
                      case 3: SET_GDX_WINY_CURV_SEL(gi, 3, ci); break; \
                      case 4: SET_GDX_WINY_CURV_SEL(gi, 4, ci); break; \
                      case 5: SET_GDX_WINY_CURV_SEL(gi, 5, ci); break; \
                      case 6: SET_GDX_WINY_CURV_SEL(gi, 6, ci); break; \
                      case 7: SET_GDX_WINY_CURV_SEL(gi, 7, ci); break; \
                      default: ; }
                  
              #define DEF_SET_GDX_WINY_CURV_SEL(gi, wi, ci) switch (gi) { \
                      case 0: DEF_SET_GD_WINX_CURV_SEL(0, wi, ci); break; \
C51 COMPILER V9.01   DRVOSD                                                                08/17/2023 10:55:16 PAGE 7   

                      case 1: DEF_SET_GD_WINX_CURV_SEL(1, wi, ci); break; \
                      case 2: DEF_SET_GD_WINX_CURV_SEL(2, wi, ci); break; \
                      case 3: DEF_SET_GD_WINX_CURV_SEL(3, wi, ci); break; \
                      case 4: DEF_SET_GD_WINX_CURV_SEL(4, wi, ci); break; \
                      case 5: DEF_SET_GD_WINX_CURV_SEL(5, wi, ci); break; \
                      default: ; }       
                  
              #if 0
                  SET_OSD_GD_REG_GD0_WIN0_CUR_SEL(V);
              #endif
              
              
              
              
                  _CTRL_OSD_GD_REGISTERS();
                  DEF_SET_GDX_WINY_CURV_SEL(gi, wi, ci);
              }
              
              void drvOSD_SetGDEngineEnableWnd(void)
              {
                  BYTE i;
                  for (i=0;i<255;i++)
                  {
                      OSDSetMask0(i,0);
                  }
              #if 0        
                  OSDGDCurveSelectionForWindow(OSD_GD_EG3, OSD_CURSOR_WND, 0);
               //OSDConfGDCurveH( ci, Hpixel_init, Hdelta_init, Hstep, Hdata_sign, Hdelta_sign, Hdelta, Hlength0, Hlengt
             -h1, hv_sign, Hoverflow_en, Hmd );
                  OSDConfGDCurveH( 0,        0x00,        0x00,     0,          0,           0,      0,   0xffff,   0xff
             -ff,       0,            0,   0 );
               //OSDConfGDCurveV( ci, Vpixel_init, Vdelta_init, Vstep, Vdata_sign, Vdelta_sign, Vdelta, Vlength0, Vlengt
             -h1, Voverflow_en, Vmd );
                  OSDConfGDCurveV( 0,        0xFF,        0x0F,     0,          1,           0,      0,       18,       
             - 0,            0,   0 );
              
                  OSDGDCurveSelectionForWindow(OSD_GD_EG4, OSD_MAIN_WND, 1);
               //OSDConfGDCurveH( ci, Hpixel_init, Hdelta_init, Hstep, Hdata_sign, Hdelta_sign, Hdelta, Hlength0, Hlengt
             -h1, hv_sign, Hoverflow_en, Hmd );
                  OSDConfGDCurveH( 1,        0x00,        0x00,     0,          0,           0,      0,   0xffff,   0xff
             -ff,       0,            0,   0 );
               //OSDConfGDCurveV( ci, Vpixel_init, Vdelta_init, Vstep, Vdata_sign, Vdelta_sign, Vdelta, Vlength0, Vlengt
             -h1, Voverflow_en, Vmd );
                  OSDConfGDCurveV( 1,        0xFF,        0x03,     0,          1,           0,      0,       90,   216-
             -90,            0,   0 );
              #endif
              }
              
              #elif CHIP_ID == CHIP_TSUMV
 397          
 398          void drvOSD_SetGDEngineEnableWnd(BYTE u8GDEngine, WORD u16EnableFlags,WORD u16Mask)
 399          {
 400   1          BYTE xdata u8Bank=msReadByte(OSD1_00);
 401   1          WORD xdata u16Addr;
 402   1          msWriteByte(OSD1_00,0x01);//subbank 1
 403   1          if (u8GDEngine<OSD_GD_EG4)
 404   1              u16Addr=OSD1_44+u8GDEngine;
 405   1          else
 406   1              u16Addr=OSD1_EC+(u8GDEngine-OSD_GD_EG4);// gd4/gd5 //110627
 407   1          if (u16EnableFlags&0xFF) //for wnd
 408   1          {
 409   2              msWriteByteMask(u16Addr,(u16EnableFlags&0xFF),(u16Mask&0xFF));
C51 COMPILER V9.01   DRVOSD                                                                08/17/2023 10:55:16 PAGE 8   

 410   2          }
 411   1          u16EnableFlags&=0x0F00;
 412   1          u16Mask&=0x0F00;
 413   1          if (u16Mask) //for timing gen
 414   1          {
 415   2              if (u8GDEngine&0x01) //GD1/GD3/GD5
 416   2              {
 417   3                  u16EnableFlags>>=4;
 418   3                  u16Mask>>=4;
 419   3              }
 420   2              else //GD0/GD2/GD4
 421   2              {
 422   3                  u16EnableFlags>>=8;
 423   3                  u16Mask>>=8;
 424   3              }
 425   2              msWriteByteMask(OSD1_EE+(u8GDEngine>>1),u16EnableFlags,u16Mask); //110627
 426   2          }
 427   1      
 428   1          msWriteByte(OSD1_00,u8Bank);
 429   1      }
 430          #endif
 431          
 432          void drvOSD_FrameColorEnable(Bool bEnable)
 433          {
 434   1          msWriteByteMask(SC0_32,(bEnable?BIT0:0),BIT0);
 435   1      }
 436          void drvOSD_FrameColorRGB(BYTE u8Red,BYTE u8Green,BYTE u8Blue)
 437          {
 438   1          msWriteByte(SC0_33, u8Red);
 439   1          msWriteByte(SC0_34, u8Green);
 440   1          msWriteByte(SC0_35, u8Blue);
 441   1      }
 442          
 443          // wait for coding
 444          //extern void Osd_LoadColorPalette( void );
 445          
 446          void drvOSD_uncall(void)
 447          {
 448   1          drvOSD_DrawBlankPlane(0, 0, 0, 0, 0);
 449   1          drvOSD_GetWndInfo(0, 0);
 450   1          drvOSD_SetWndOn(0, 0);
 451   1          drvOSD_SetWndCtrl(0, 0, 0, 0);
 452   1          drvOSD_SetWndFixAlpha(0, 0, 0);
 453   1          drvOSD_SetWndFixColor(0, 0, 0, 0);
 454   1          drvOSD_SetWndShiftPixel(0, 0, 0);
 455   1          drvOSD_SetWndCABaseAddr(0, 0);
 456   1          drvOSD_SetWndFixAttr(0, 0, 0);
 457   1          drvOSD_SetWndLineOffset(0, 0);
 458   1          //Osd_LoadColorPalette();
 459   1          
 460   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1104    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      38
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.01   DRVOSD                                                                08/17/2023 10:55:16 PAGE 9   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
